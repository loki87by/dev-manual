export const ABOUT_OOP = [
  {
    text1: `Итак представим себе фирму, производящую самолеты и конструкторское бюро при этой фирме (ну, скажем, Боинг).
Нам заказали несколько моделей: военный самолет, грузовой и пассажирский.
Первое, что мы сделаем, это начнем чертить некоторый общий чертеж для всех моделей.
По этому чертежу еще нельзя построить реальный самолет, но он уже содержит общие детали реализации. Это абстрактный класс.`,
    code1: `//Код на Java
public abstract class ЧертежСамолета {  // чертеж нашей универсальной модели самолета;
  public abstract void взлет();
  public void полет() {
    // описание как наш самолет летит
  }
  public abstract void посадка();
}`,
    text2: `Второе, нам нужно описать требования для унифицированного самолета, у него должны быть определенны такие параметры как грузоподъемность, крейсерская и максимальная скорость, практический потолок (они могут отличаться у разных моделей, но они должны быть), он должен уметь взлетать и, крайне желательно, уметь садиться. Требования к самолетам это интерфейс.`,
    code2: `//Код на Java
public interface ТребованияКСамолету { // то что должен уметь наш самолет
  long getМаксимальнуюСкорость();
  double getГрузоподьемность();
  long getПрактическийПотолок();
  void взлет();
  void полет();
  void посадка();
}
public abstract class ЧертежСамолета implements ТребованияКСамолету {
  ...
}`,
    text3: `Параметры унифицированного самолета, которые заданы, но еще не определенны, или действия, которые он должен делать (взлет/посадка) это виртуальные методы и члены класса.
Параметры унифицированного самолета, которые заданы, но еще не определенны, или действия, которые он должен делать (взлет/посадка) это виртуальные методы и члены класса.`,
    code3: `//Код на Java
public abstract class ЧертежСамолета {  // чертеж нашей универсальной модели самолета;
  public abstract void взлет(); // виртуальные метод
  public void полет() {
    // описание как наш самолет летит
  }
  public abstract void посадка(); // виртуальные метод
}`,
    text4: `Дальше мы приступаем к чертежам конкретных моделей, по которым уже можно построить реальные самолеты.
Это классы. Да, класс это именно чертеж и только чертеж, У конкретных классов должны определены все параметры унифицированного самолета и возможно добавлены новые. Мы должны определить как наш будущий самолет будет садиться, взлетать, как он будет летать.
Это методы класса.`,
    code4: `Код на Java
public class ЧертежПассажирскогоСамолета extends ЧертежСамолета {
  public int getКолВоПассажиров() {
    return 120;
  }
  public void взлет() {
    поздороваться_с_пассажирами();
    провести_инструктаж();
    получить_разрешение_на_взлет();
    взлететь():
  }
  ...
}
public class ЧертежВоенногоСамолета  extends ЧертежСамолета {
  public int getКолВоРакет() {
    return 5;
  }
  public void взлет() {
    получить_приказ();
    доложить_командиру();
    взлететь():
  }
  ...
}`,
    text5: `Если мы произведем реальный самолет это будет инстанс (объект) класса.
Он построен по конкретным чертежам, но его параметры изменяются со временем, например,
его максимальная и крейсерская скорость может чуть уменьшиться после определенных лет налета.
То есть реальный существующий самолет это инстанс (объект) класса.`,
    code5: `//Код на Java
ЧертежСамолета тотСамыйПотрепанныйБоингНаКоторомМыЛетелиВТурцию = new ЧертежПассажирскогоСамолета();
тотСамыйПотрепанныйБоингНаКоторомМыЛетелиВТурцию.setПотрепаность(0.99);`,
    image: "image88.png",
    text6: `У каждой модели самолета есть общие параметры, например, процент аварийности.
Каждое происшествие с любым самолетом этой модели его может изменить. Это статические методы и переменные класса.`,
    code6: {
      lang: "java",
      value: `//Код на Java
ЧертежПассажирскогоСамолета.setАварийностьМодели(0.0);`},
    text7: `Если мы сделали унифицированную модель самолет с определенным размахом крыльев и 2 реактивными двигателями, мы можем быть уверены, что любой из наших самолетов (военных, гражданских или грузовых) сможет сесть на ВВП, предназначенную для данного типа самолета (не зависимо от того, что как они будут садиться). Это полиморфизм.`,
    code7: {
      lang: "java",
      value: `//Код на Java
public class ЧертежПассажирскогоСамолета extends ЧертежСамолета {
  ...
  public void посадка() {
    предупредить_пассажиров();
    проверить_все_пассажирские_места();
    получить_разрешение_на_посадку();
    сесть():
  }
  ...
}
public class ЧертежВоенногоСамолета  extends ЧертежСамолета {
  public void посадка() {
    получить_приказ();
    доложить_командиру();
    сесть():
  }
  ...
}`},
    text8: `Если мы делаем самолет, но двигатель разрабатывает другая команда, нам проще не указывать его на самом чертеже самолета (тем более что один двигатель может использовать на большом количестве самолетов), а только указать «смотри чертеж такого-то двигателя».
Это композиция.`,
    code8: `//Код на Java
public class ЧертежПассажирскогоСамолета extends ЧертежСамолета {
  private ЧертежДвигателя двигатель = new ДвигательМ45ФирмыАстинМартин()
  ...
}`,
    text9: `Если мы разрабатываем трап, подходящий под этот тип самолета (и, возможно, другие подробные самолеты), пилот самолета при приземлении просит подать именно этот трап. Это будет ассоциация.
Если мы создали модель пассажирского самолета на 120 мест, а потом чуть-чуть доработали увеличив количество мест до 130 (за счет сокращения бизнес класса), нам не потребуется создавать новый чертеж, достаточно лишь указать изменения.
Тут же становится легко понятно, почему если поменяется что-то в чертеже модели самолета на 120 мест, так же измениться самолет на 130 мест, так мы не делаем копию чертежей, мы только описываем, что изменилось в проекте. Это наследование.`,
    code9: `//Код на Java
public class ЧертежПассажирскогоСамолетаНа130Мест extends ЧертежПассажирскогоСамолета {
  @Override
  public int getКолВоПассажиров() {
    return 130;
  }
  ...
}`,
    subtitle: `Вопрос зачем вообще нужно ООП?`,
    text10: `Все просто, вы не будете разрабатывать каждый самолет с нуля, вы в любом случае возьмете успешную модель и просто доработаете ее.
Вам нет смысла создавать двигатель только для одного самолета, его может разработать другая совсем команда.
Чтобы вставить двигатель в самолет, но должен соответствовать каким-то параметрам (размеры, тяга, топливо), то есть без спецификаций-контрактов (интерфейсов) вам не обойтись.
В идеале, части самолета должны быть независимыми друг от друга, это плохо если при включении кондиционера, отключается навигационная система.
То есть каждый из модулей самолета должен быть максимально независимым и предоставлять только запланированные органы управления.
Это тот черный ящик и сокрытие данных.
На мой взгляд (если я не прав пишите в комментариях), принципы ООП становятся простыми и понятными, если перестать их пытаться объяснить на уровне реального мира, а представлять, как некоторую разработку чего-то нового (самолетов, машин, домов, электроники), тогда классы будут чертежами, схемами.
Интерфейсы — контрактами или требованиями к новой продукции. А готовая продукция — объектами класса и т.д.`,
  },
];
