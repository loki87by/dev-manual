export const AUTH = [
  {
    title: `Аутентификация и авторизация: в чём отличия?`,
    text1: `Для начала разберёмся с тремя длинными словами, которые многие путают: идентификация, аутентификация и авторизация.`,
    subtitle1: `Идентификация`,
    text2: `Идентифицировать — значит присвоить кому-то или чему-то имя, номер или какой-то символ, который позволит отделить объект от других.
Стас выпивает в баре с друзьями и решает познакомиться с девушкой за соседним столиком. Он подходит и спрашивает, как её зовут.
Девушка отвечает: «Стася». В этот момент произошла идентификация.
Сначала это была абстрактная девушка, а теперь у неё есть идентификатор — «Стася».`,
    subtitle2: `Аутентификация`,
    text3: `Аутентифицировать — значит доказать, что идентифицированный является тем, кем назвался.
Идентификация — это часть процесса аутентификации. Стася могла назвать не своё имя и быть на самом деле Мариной.
Но если бы кроме идентификации Стася прошла аутентификацию, это было бы невозможно.
Стас проводил Стасю и пошёл домой. Поскольку час поздний, его остановили полицейские и потребовали предъявить паспорт.
Когда Стас показывает паспорт полицейскому, тот его аутентифицирует.
В этом случае доказательством того, что Стас — это Стас, выступает его паспорт.
В интернете процесс аутентификации часто сводится к вводу имени пользователя и пароля.
Но бывают и другие способы: ввод кода из смс, ответ на секретный вопрос, снятие отпечатка пальца или снимка лица.`,
    subtitle3: `Авторизация`,
    text4: `Авторизация происходит после аутентификации. Это процесс, при котором система принимает решение, какие права вам можно выдать.
Стас зашёл в магазин. На кассе перед ним стоит молодой человек, покупающий сигареты. Кассир спрашивает у него паспорт.
Это авторизация: кассир принимает решение, можно продавать этому человеку сигареты или нет.
После авторизации в соцсети юзеры получают права на редактирование собственных публикаций, отправку сообщений от своего имени.`,
    subtitle4: `Итого`,
    text5: `Ещё пример. Стас просыпается с утра от звонка в дверь. Он подходит и спрашивает: «Кто там?». «Это Колян, твой сосед,» — отвечают Стасу.
Это была идентификация. Затем Стас смотрит в глазок и определяет, действительно ли это Колян. Это аутентификация.
И, наконец Стас решает, пустить Коляна или сказать, чтобы тот приходил в другой раз — это авторизация.
Эти три понятия важно отличать одно от другого: так вы избежите путаницы при изучении этой темы.`,
  },
  {
    title: `Как не проходить аутентификацию при каждом заходе на сайт. JWT`,
    text1: `Вы узнали, что такое авторизация и аутентификация, и чем они отличаются. Наверняка вы замечали, что при посещении одной и той же социальной сети вам не приходится каждый раз проходить аутентификацию. Другими словами вам не нужно повторно вводить почту и пароль при каждом посещении сайта. Это реализуется путём создания токена.`,
    subtitle1: `Алгоритм`,
    text2: `Мы реализуем аутентификацию так:
Пользователь входит в аккаунт по почте и паролю.
Сервер генерирует токен — уникальный набор символов — и отправляет его пользователю.
Токен сохраняется в браузере пользователя.
При повторном открытии сайта пользователь отправляет токен серверу.
Сервер проверяет есть ли токен в запросе и тот ли это токен, что был выдан пользователю раньше.
Если проверка токена прошла успешно, пользователь авторизуется, иначе — получает сообщение об ошибке.
Когда пользователь выходит из системы, браузер удаляет токен из памяти.
После этого пользователю нужно входить в систему по почте и паролю заново.
Весь алгоритм построен на формировании токена. Рассмотрим, что он собой представляет.`,
    subtitle2: `Как создавать токен. Структура`,
    text3: `Токен — набор символов, сгенерированный согласно структуре и правилам. Эти структура и правила определяет стандарт создания токена.
Мы будем пользоваться стандартом JWT (JSON Web Token). JWT основан на стандарте JSON.
Токен, созданный по этому стандарту, состоит из трёх частей, каждая несёт в себе определённую информацию:
header (англ. «хедер») — служебную информацию;
payload (англ. «полезная нагрузка») — данные, которые токен в себе несёт;
signature (англ. «подпись») — подпись, которая предотвращает подмену информации в токене.
Эти три части разделены точками:`,
    image1: "image58.png",
    text4: `Разберём каждую из них подробнее.`,
    subtitle3: `Header`,
    text5: `Хедер, как правило, содержит два поля:
тип токена — это строка "JWT";
алгоритм создания подписи — обычно применяется алгоритм HMAC SHA256 или RSA:`,
    code1: `{
  "alg": "HS256",
  "typ": "JWT"
}`,
    text6: `Полученный JSON-объект кодируется в строку распространённым алгоритмом Base64Url. Это первая часть токена.`,
    subtitle4: `Payload`,
    text7: `Пейлоуд — содержит саму информацию, которая была закодирована. В нашем случае это информация о пользователе:`,
    code2: `{
  "name": "Стас Басов",
  "_id": "39dow8ak8402jf23u4do057s"
}`,
    text8: `Аналогично хедеру, пейлоуд кодируется в строку. Получаем вторую часть токена.`,
    subtitle5: `Signature`,
    text9: `Подпись гарантирует, что содержимое хедера и пейлоуда не были изменены после создания токена.
Специальный алгоритм высчитывает подпись, исходя из содержимого хедера и пейлоуда.
Также этот алгоритм использует секретный ключ, который известен только серверу.`,
  },
  {
    title: `Дополнительно: другие способы аутентификации/авторизации`,
    subtitle1: `Сессии`,
    text1: `Сессии — один из самых популярных способов авторизации.
Когда пользователь вводит логин и пароль, сервер создаёт так называемую сессию и сохраняет её в базу данных.
Сессия представляет собой объект с данными о входе в систему.
Клиент вместо токена получает идентификатор сессии, который отправляется на сервер в каждом запросе.
При выходе из аккаунта сервер удаляет сессию из базы, так что пользователю нужно проходить аутентификацию снова.`,
    link1: {
      uri: "https://medium.com/@evangow/server-authentication-basics-express-sessions-passport-and-curl-359b7456003d",
      text: "Подробное руководство по созданию авторизации на основе сессий",
    },
    link2: {
      uri: "https://www.npmjs.com/package/express-session",
      text: "Модуль для работы с сессиями в express",
    },
    subtitle2: `Авторизация через социальные сети: OAuth`,
    text2: `Способ авторизации через аккаунты в социальных сетях: Facebook, Yandex, Google.
Эта возможность доступна благодаря протоколу OAuth (сокращение от Open Authorization — «открытая авторизация»).
При этом подходе пользователь даёт приложению доступ к некоторым данным аккаунта в социальной сети.
Логин и пароль при этом не передаются, передаётся только часть данных и возможность совершать определённые действия.
Авторизацию через протокол OAuth реализуют методами модуля Passport.js — популярной библиотеки для аутентификации.
С этой библиотекой сравнительно просто интегрировать в свой сайт аутентификацию через социальные сети или другие веб-сервисы.`,
    link3: {
      uri: "Passport.js: http://www.passportjs.org",
      text: "Официальный сайт",
    },
    subtitle3: `Мультифакторная аутентификация`,
    text3: `Пока мы рассматривали только однофакторную аутентификацию, при которой используется только один фактор для подтверждения личности клиента — пароль. Но факторов может быть несколько. Самый распространённый случай — код из смс, который приходит на привязанный к аккаунту номер телефона. Такой метод аутентификации часто применяют в интернет-банках.
Кроме смс применяются коды из электронных писем или заранее сгенерированные последовательности символов.
Если факторов два, аутентификацию называют двухфакторной, если три — трёхфакторной. Общее название для методов, где участвует более одного способа подтвердить личность, — мультифакторная аутентификация.
Мультифакторная аутентификация заметно повышает безопасность. Даже если злоумышленник украл пароль пользователя, ему также придётся украсть телефон, перехватить смс или взломать электронную почту. Это повышает сложность взлома аккаунта.
Основа мультифакторной аутентификации — TOTP (англ. time-based one-time password — «зависящий от времени одноразовый пароль»).
Именно его приложение банка присылает пользователю, когда тот входит в аккаунт.
Есть уже готовая Node.js-библиотека, реализующая механизм выпуска и проверки одноразовых паролей.`,
    link4: {
      uri: "https://github.com/yeojz/otplib",
      text: "Ссылка на библиотеку на Github",
    },
    subtitle4: `Другие способы аутентификации`,
    text4: `Есть ещё множество способов аутентификации: на основе геолокации, слепка устройства, отпечатка пальца, снимка лица...
Если вам интересна тема аутентификации, попробуйте разобраться в ней глубже. Это не только увлекательно, но и развивает важный навык самостоятельного поиска материалов.`,
  },
  {
    title: `Переадресация пользователя`,
    text1: `Рассмотрим уже знакомый компонент App.js. Именно внутри него мы будем настраивать роуты. Так код выглядит сейчас:`,
    code1: `// App.js
import React from 'react';
import { Route, Switch } from 'react-router-dom';
// импортируем компоненты приложения
import Login from './Login.js';
import Register from './Register.js';
import Ducks from './Ducks.js';
import MyProfile from './MyProfile.js';
// импортируем CSS
import './styles/App.css';
class App extends React.Component {
  constructor(props){
    super(props);
  }
  render(){
    return (
      <Switch>
        <Route path="/ducks">
          <Ducks />
        </Route>
        <Route path="/my-profile">
          <MyProfile />
        </Route>
        <Route path="/login">
          <div className="loginContainer">
            <Login  />
          </div>
        </Route>
        <Route path="/register">
          <div className="registerContainer">
            <Register />
          </div>
        </Route>
      </Switch>
    )
  }
}
export default App;`,
    text2: `В коде компонента App можно насчитать четыре роута и столько же компонентов: Ducks, MyProfile, Login и Register.
Но есть две проблемы. Когда пользователь загружает приложение, путь по умолчанию / не имеет соответствующего роута.
При переходе по этому адресу ничего не отрисуется — пользователь увидит чёрный экран.
Кроме этого, неавторизованные и незарегистрированные пользователи могут посетить любой из этих роутов,
введя URL вручную в адресной строке браузера. То есть роуты не защищены.
Перейдя по /, пользователь увидит почти «Чёрный квадрат» Малевича, а точнее прямоугольник
Роут /register отрисует экран регистрации:
По адресу /login пользователь увидит экран авторизации:
Роут /ducks покажет пользователю важную информацию о криптоутках:
Обратившись к /my-profile, пользователь увидит экран с плейсхолдерами вместо реальных данных:
Что бы вы исправили в первую очередь?`,
  },
  {
    title: `Переадресация`,
    text1: `Мы бы начали с роута, которого нет внутри приложения. Когда пользователь переходит по нему, он видит чёрный экран.
Чтобы такого не происходило, нужно перенаправить пользователя обратно в приложение в зависимости от того, авторизован он или нет.
Сделаем так, чтобы авторизованные пользователи были перенаправлены в /ducks, а неавторизованные — на страницу входа в приложение.
Внутри App.js подготовим стейт-переменную loggedIn. Она будет содержать статус пользователя — вошёл он в систему или нет.
Установим значение этой переменной false,  позже сделаем так, чтобы значение подставлялось динамически в зависимости от статуса:`,
    code1: `// App.js
constructor(props){
  super(props);
  this.state = {
    loggedIn: false
  }
}`,
    text2: `В уроке про программную навигацию вы узнали о компоненте Redirect. Его можно использовать как последний компонент внутри Switch, чтобы перенаправить пользователя на определённый путь в зависимости от статуса его авторизации. Сначала мы импортируем компонент Redirect из react-router-dom, а затем размещаем Redirect внутри компонента Route.`,
    code2: {
      lang: "javascript",
      value: `// App.js
<Route>
  {<Redirect to={\`/\${this.state.loggedIn ? 'ducks' : 'login'}\`} />}
</Route>`,
    },
    text3: `Мы проверяем тернарным оператором значение loggedIn. Если пользователь посетит / или любой другой маршрут, который не определён в приложении, неавторизованные пользователи будут перенаправлены на /login.
Одна проблема решена. Но пользователи по-прежнему могут посещать адреса /ducks и /my-profile, введя вручную их в адресную строку браузера — даже если значение loggedIn равно false.`,
  },
  {
    title: `Защита маршрутов на фронте`,
    subtitle1: `Немного о компонентах более высокого порядка`,
    text1: `Мы уже говорили о компонентах более высокого порядка в «Реакте». Создадим такой компонент, чтобы защитить роуты.
Компоненты Ducks и MyProfile отличаются друг от друга. Ducks отображает одну и ту же информацию для авторизованных и неавторизованных пользователей. А компонент MyProfile — личную информацию для конкретного авторизованного пользователя.
Но есть и схожая функциональность: оба компонента проверяют, авторизован ли пользователь, и в зависимости от этого либо отрисовывают соответствующий компонент, либо переадресовывают пользователя на страницу входа /login.
Добавлять логику проверки и переадресации в каждый компонент было бы избыточно. Поэтому поместим её в одном месте.
Для этого нам понадобится компонент более высокого порядка.
Как вы помните, НОС-компоненты позволяют добавить функциональность одному или нескольким компонентам.
Если какие-то компоненты нуждаются в общей функциональности, можно обернуть их в HOC-компонент и описать в нём всё, что нужно.
В больших проектах компоненты более высокого порядка позволяют лучше структурировать код и сделать его понятнее.
Для начала создадим HOC-компонент ProtectedRoute в директории /components:`,
    code1: `// ProtectedRoute.js
import React from 'react';
import { Route, Switch } from 'react-router-dom';
// этот компонент принимает другой компонент в качестве пропса
// он также может взять неограниченное число пропсов и передать их новому компоненту
const ProtectedRoute = ({ component: Component, ...props  }) => {
  return (
    <Route>
      {
        () => props.loggedIn ? <Component {...props} /> : <Redirect to="./login" />
      }
    </Route>
)}
export default ProtectedRoute;`,
    text2: `Чтобы понять, что происходит внутри нового HOC-компонента, посмотрим на строку ({ component: Component, ...props }).
Для получения компонентов, переданных через пропс component, HOC-компонент ProtectedRoute использует деструктуризацию.
Пропсы пробрасываются в него также при помощи деструктуризации. Это значит, что данные могут поступать от родителя к
HOC-компоненту, который потом будет использован повторно для создания любых новых компонентов.
HOC-компонент ProtectedRoute возвращает компонент Route. Если значение loggedIn — true, Route либо отрисует компонент, который передан HOC-компоненту как пропс, включая переданные пропсы, либо вернёт компонент Redirect и переадресует пользователя на страницу авторизации. Реализуем компонент более высокого порядка в файле App.js:`,
    code2: `// App.js
import React from 'react';
import { Route, Switch } from 'react-router-dom';
import Login from './Login.js';
import Register from './Register.js';
import Ducks from './Ducks.js';
import MyProfile from './MyProfile.js';
import ProtectedRoute from './ProtectedRoute'; // импортируем HOC
import './styles/App.css';
class App extends React.Component {
  constructor(props){
    super(props);
    this.state = {
      loggedIn: false
    }
  }
  render(){
    return (
      <Switch>
        {/* ниже разместим защищённые маршруты */}
        {/* и передадим несколько пропсов: loggedIn, path, component */}
        <ProtectedRoute path="/ducks" loggedIn={this.state.loggedIn} component={Ducks} />
        <ProtectedRoute path="/my-profile" loggedIn={this.state.loggedIn} component={MyProfile} />
        <Route path="/login">
          <div className="loginContainer">
            <Login handleLogin={this.handleLogin} />
          </div>
        </Route>
        <Route path="/register">
          <div className="registerContainer">
            <Register />
          </div>
        </Route>
        <Route>
          {this.state.loggedIn ? <Redirect to="/ducks" /> : <Redirect to="/login" />}
        </Route>
      </Switch>
    )
  }
}
export default App;`,
    text3: `Мы убрали компоненты Route для роутов /ducks и /my-profile, поскольку они теперь находятся в HOC-компоненте ProtectedRoute.
Новый компонент, который создаётся при помощи компонента ProtectedRoutes, имеет доступ ко всем пропсам, переданным на вход при его создании. В нашем случае это пропсы path и loggedIn. Мы можем передать эти пропсы новому компоненту, применив оператор spread:
...props. Иными словами, и у Ducks, и у MyProfile есть доступ ко всем пропсам родительского компонента.
Теперь роуты /ducks/ и /my-profile защищены. Если не авторизоваться в приложении и просто набрать их адреса в браузере, пользователь будет автоматически переадресован на страницу компонента Login.`,
    subtitle2: `Посторонним вход воспрещён`,
    text4: `Роуты-то мы защитили, но образовалась новая проблема — пользователи не могут зарегистрироваться в приложении и, как следствие, войти в систему. Поэтому значение loggedIn всегда будет false`,
  },
  {
    title: `Регистрация`,
    text1: `Если пользователь не авторизован, приложение переадресует его на страницу входа. Чтобы войти в приложение, сперва нужно зарегистрироваться. На странице авторизации есть ссылка, которая ведёт на форму регистрации.
Перейдя по ссылке, пользователь попадёт с экрана компонента Login на экран Register.
Этот маршрут доступен для всех пользователей.
Разберём код компонента Register:`,
    code1: `// Register.js
import React, { Button } from 'react';
import { Link } from 'react-router-dom';
import Logo from './Logo.js';
import './styles/Register.css';
class Register extends React.Component {
  constructor(props){
    super(props);
    this.state = {
      username: '',
      email: '',
      password: '',
      confirmPassword: ''
    }
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  handleChange(e) {
    const {name, value} = e.target;
    this.setState({
      [name]: value
    });
  }
  handleSubmit(e){
    e.preventDefault()

    if (this.state.password === this.state.confirmPassword){
      // сюда добавим логику обработки формы регистрации
    }
  }
  render(){
    return(
      <div className="register">
        <Logo title={'CryptoDucks'}/>
        <p className="register__welcome">
          Please register.
        </p>
        <form onSubmit={this.handleSubmit} className="register__form">
          <label for="username">
            Username:
          </label>
          <input id="username" name="username" type="text" value={this.state.username} onChange={this.handleChange} />
          <label for="email">
            Email:
          </label>
          <input id="email" name="email" type="email" value={this.state.email} onChange={this.handleChange} />
          <label for="password">
            Password:
          </label>
          <input id="password" name="password" type="password" value={this.state.password} onChange={this.handleChange} />
          <label for="confirmPassword">
            Confirm password:
          </label>
          <input id="confirmPassword" name="confirmPassword" type="password" value={this.state.confirmPassword} onChange={this.handleChange} />
          <div className="register__button-container">
            <button type="submit" className="register__link">Sign up</button>
          </div>
        </form>
        <div className="register__signin">
          <p>Already a member?</p>
          <Link to="login" className="register__login-link">Log in here</Link>
        </div>
      </div>
    )
  }
}
export default Register;`,
    text2: `Код может показаться монструозным и напугать, но на самом деле в нём нет ничего нового. Это уже знакомый вам управляемый компонент для обработки инпутов формы, а также обработчики изменений и отправки формы. Также обратите внимание, что если оба пароля в форме совпадают, то внутри метода handleSumbit нужно что-то сделать с данными, например, отправить их на сервер.`,
    subtitle1: `Создаём файл Auth`,
    text3: `Придётся написать много кода для авторизации пользователей, поэтому поместим JavaScript-код в отдельный файл.
Так мы избежим повторяющегося кода, если проект разрастётся. В директории /src создадим файл duckAuth.js:`,
    code2: {
      lang: "javascript",
      value: `// duckAuth.js
export const BASE_URL = 'https://api.nomoreparties.co';
export const register = (username, password, email) => {
return fetch(\`\${BASE_URL}/auth/local/register\`, {
  method: 'POST',
  headers: {
    Accept': 'application/json',
    Content-Type': 'application/json'
  },
  body: JSON.stringify({username, password, email})
})
  .then((response) => {
    try {

    if (response.status === 200){
      return response.json();
    }
    } catch(e){
      return (e)
    }
  })
  .then((res) => {
    return res;
  })
  .catch((err) => console.log(err));
};`,
    },
    text4: `На бекенде приложений создают методы, добавляющие пользователей в базу данных. В следующем спринте вы их создадите сами.
Сейчас научимся вызывать их с фронтенда. Чтобы создать пользователя, вызовем функцию register в файле duckAuth.js.
Эта функция принимает три аргумента: username, password и email. Используя fetch, она создаёт POST-запрос.
После этого в первом обработчике then мы получим объект res, который содержит информацию об ответе и статус ответа.
При успешном ответе вернётся статус 200, а второй обработчик then вернёт ещё один res, содержащий данные пользователя (которые он ввёл в форму регистрации), адрес запроса и уникальный подписанный JWT-токен.
Теперь нужно импортировать файл duckAuth.js в Register.js: import * as duckAuth from '../duckAuth.js';.
Следующий шаг — добавить новую функцию в обработчик handleSubmit:`,
    code3: {
      lang: "javascript",
      value: `// Register.js
handleSubmit(e){
  e.preventDefault()

  if (this.state.password === this.state.confirmPassword){
    const { username, password, email } = this.state;
    duckAuth.register(username, password, email);
  }
}`,
    },
    text5: `Для этого применим синтаксис деструктуризации к this.state. Затем передадим серверу username, password и email.`,
    subtitle2: `HOC-компонент withRouter`,
    text6: `Теперь пользователи смогут зарегистрироваться в приложении. При успешной регистрации второй обработчик then вернёт токен JWT.
Мы могли бы запустить этот код, сохранить токен в браузере и сразу залогинить пользователей. Но это слишком просто, поэтому переадресуем пользователя на страницу входа, чтобы он самостоятельно авторизовался. Кстати, теперь вы знаете, почему на некоторых сайтах приходится повторно вводить логин-пароль, заполнив форму регистрации с теми же данными буквально мгновением ранее, — не написана логика.
Register — классовый компонент, поэтому использовать в нём хуки не получится. Чтобы получить доступ к объекту history и перенаправить пользователя на страницу авторизации, воспользуемся сторонним HOC-компонентом из библиотеки React Router — WithRouter.
Сперва импортируем его в Register.js. Для этого добавим в список импортов такую строку:`,
    code4: `// Register.js
import { Link, withRouter } from 'react-router-dom';`,
    text7: `Всё, что остаётся сделать, — поправить директиву export в конце файла:`,
    code5: `// изменим последнюю строку в файле Register.js
export default withRouter(Register);`,
    text8: `Теперь компонент Register точно обёрнут в HOC-компонент. Он сможет получить доступ к объекту history в props. Объект history позволяет использовать метод push. В качестве аргумента он принимает путь, на который мы перенаправляем пользователя. В нашем случае — '/login'.
Добавим ещё один then() в метод handleSubmit(). Юзер переадресуется, только если форма регистрации заполнена правильно и отправлена:`,
    code6: `// Register.js
handleSubmit(e){
  e.preventDefault();

  if (this.state.password === this.state.confirmPassword){
    let { username, password, email } = this.state;
    duckAuth.register(username, password, email).then((res) => {

      if(res){
        this.setState({
          message: ''
          }, () => {
            this.props.history.push('/login');
        })
        } else {
          this.setState({
            message: 'Что-то пошло не так!'
          })
        }
    });
  }
}`,
    text9: `Мы прописали условие в коде, что если statusCode равен 200, значит, форма отправлена успешно.
Тогда при помощи обработчика then перенаправим пользователя на страницу авторизации.
У нас две новости: плохая и хорошая. Плохая — компонент Login всё ещё не работает.
Хорошая — у зарегистрированных пользователей теперь есть JWT-токен, привязанный к их данным.`,
  },
  {
    title: `Локальное хранилище`,
    text1: `Чтобы пользователю не приходилось вводить свой пароль при каждом посещении сайта, нужно как-то верифицировать его данные.
Один из способов — проверить наличие валидного JWT-токена на стороне пользователя.`,
    subtitle1: `Два браузерных хранилища`,
    text2: `В зависимости от цели токен хранят в одном из двух браузерных хранилищ:
Session storage (с англ. сессионное хранилище). Данные отсюда удаляются в конце сессии — т.е. когда пользователь закрывает браузер.
Можно сравнить сессионное хранилище с оперативной памятью:
при выключении компьютера все несохранённые документы пропадут, потому как они будут удалены из оперативной памяти.
Local storage (с англ. локальное хранилище). Данные хранятся тут до тех пор, пока их не удалят вручную.
Локальное хранилище работает как постоянная память: после перезагрузки компьютера все документы на жёстком диске остаются целы.
Оба хранилища принадлежат домену, то есть невозможно обратиться к данным из хранилища yandex.ru, находясь на google.com.
Мы будем пользоваться локальным, ведь мы не хотим заставлять пользователя вводить логин и пароль при каждом посещении сайта.
Данные в local storage хранятся как JS-объекты, которые доступны глобально. У каждого объекта есть встроенные методы. Самые важные:
setItem для сохранения данных,
getItem для получения сохранённых данных,
removeItem для удаления данных из памяти.`,
    code1: `// сохраняем username
localStorage.setItem('username', 'Стас Басов');
// получаем username
localStorage.getItem('username'); // "Стас Басов"
// удаляем username
localStorage.removeItem('username');
// если ключа нет, вернётся null
localStorage.getItem('username'); // null`,
    text3: `setItem принимает два аргумента: ключ и его значение. Значением может быть только строка. Потому метод setItem приведёт любой аргумент к строке. Для перевода объекта в строку пользуйтесь методом JSON.stringify. Если просто передать методу setItem объект, он будет приведён к строке встроенным методом toString, результатом работы которого будет [Object object] для любого объекта.
Метод JSON.stringify работает иначе: он создаст строку из объекта ровно в том виде, в каком он оформлен.
Чтобы превратить JSON-строку обратно в объект, вызовите метод JSON.parse:`,
    code2: `// сохраняем username
localStorage.setItem('user', JSON.stringify({
  firstName: 'Стас',
  lastName: 'Басов'
}));
// достаём username
JSON.parse(localStorage.getItem('user'));
//  {
  //    firstName: 'Стас',
  //    lastName: 'Басов'
//  }`,
    subtitle2: `Сохраняем токен`,
    text4: `Напишем код для сохранения токена в локальном хранилище. Напомним, что мы выбрали localStorage, чтобы пользователю не нужно было повторно логиниться после закрытия браузера:`,
    code3: `// отправляем запрос на роут аутентификации
fetсh('https://api.mywebsite.com/signin', {
  method: 'POST',
  body: JSON.stringify({
    email: 'stasbasov@yandex.ru',
    password: 'StasBasov1989'
  })
})
  .then(res => res.json())
  .then((data) => {
    // сохраняем токен
    localStorage.setItem('token', data.token);
  });`,
    text5: `Теперь токен сохранён в локальном хранилище. Осталось настроить его отправку на сервер.`,
    subtitle3: `Отправляем токен в запросах`,
    text6: `Сделаем запросы авторизованными. Для этого внутри запроса нужно отправлять токен — по нему сервер понимает, есть у клиента права на выполнение действия или нет.
Токен отправляют в заголовке authorization. Кроме самого токена заголовок должен содержать схему аутентификации — она сообщает серверу, что проверять наличие прав у пользователя нужно по токену. Имя такой схемы — Bearer. Есть и другие, но не будем углубляться.
В заголовок authorization нужно записать через пробел схему аутентификации и токен:`,
    code4: `// отправляем запрос на роут аутентификации
fecth('https://api.mywebsite.com/posts', {
  method: 'GET',
  headers: {
    authorization: \`Bearer \${localStorage.getItem('token')}\`
  }
});`,
  },
  {
    title: `Вход в систему`,
    text1: `Когда пользователь впервые входит в систему, нужно проверить введённые им учётные данные.
Если они верны, в ответ с сервера отправляется JWT. Затем нужно сохранить этот JWT-токен в localStorage браузера.
При последующих входах пользователя в систему нужно получить токен из localStorage, а затем сделать запрос к серверу с этим токеном, чтобы проверить его достоверность. Если всё хорошо, пользователь получит доступ к своим данным, которые были бы скрыты без токена.
Продолжим совершенствовать приложение. Мы закончили на том, что после регистрации пользователи перенаправляются на экран входа.
Обратимся к компоненту Login:`,
    code1: `// Login.js
import React from 'react';
import { Link } from 'react-router-dom';
import Logo from './Logo.js';
import * as duckAuth from '../duckAuth.js';
import './styles/Login.css';
class Login extends React.Component {
constructor(props){
  super(props);
  this.state = {
    username: '',
    password: ''
  }
  this.handleChange = this.handleChange.bind(this);
  this.handleSubmit = this.handleSubmit.bind(this);
  }
  handleChange(e) {
  const {name, value} = e.target;
    this.setState({
      [name]: value
    });
  }
  handleSubmit(e){
    e.preventDefault()

    if (!this.state.username || !this.state.password){
      return;
    }
    // здесь авторизуем пользователя
    // далее проверяем токен
    // наконец, перенаправляем пользователя на страницу \`/ducks\`
  }
  render(){
    return(
      <div className="login">
        <Logo title={'CryptoDucks'}/>
        <p className="login__welcome">
          Это приложение содержит конфиденциальную информацию.
          Пожалуйста, войдите или зарегистрируйтесь, чтобы получить доступ к CryptoDucks.
        </p>
        <form onSubmit={this.handleSubmit} className="login__form">
          <label for="username">
            Логин:
          </label>
          <input id="username" required name="username" type="text" value={this.state.username} onChange={this.handleChange} />
          <label for="password">
            Пароль:
          </label>
          <input id="password" required name="password" type="password" value={this.state.password} onChange={this.handleChange} />
          <div className="login__button-container">
            <button type="submit" className="login__link">Войти</button>
          </div>
        </form>
        <div className="login__signup">
          <p>Ещё не зарегистрированы?</p>
          <Link to="/register" className="signup__link">Зарегистрироваться</Link>
        </div>
      </div>
    )
  }
}
export default withRouter(Login);`,
    text2: `Этот компонент аналогичен компоненту Register. Мы уже обернули компонент Login в HOC withRouter.
Теперь применим history.push для отправки пользователей на страницу /ducks после авторизации в приложении.
Нам потребуется функция, которая будет проверять логин и пароль пользователя на соответствие какому-либо профилю, хранящемуся в базе данных. Вызывать её будем внутри handleSubmit.
Создадим такую функцию в duckAuth.js и назовём её authorize:`,
    code2: {
      lang: "javascript",
      value: `// duckAuth.js
export const authorize = (identifier, password) => {
return fetch(\`\${BASE_URL}/auth/local\`, {
  method: 'POST',
  headers: {
    Accept': 'application/json',
    Content-Type': 'application/json'
  },
  body: JSON.stringify({identifier, password})
  })
    .then((response => response.json()))
    .then((data) => {

      if (data.user){
        localStorage.setItem('jwt', data.jwt);
        return data;
      }
  })
  .catch(err => console.log(err))
};`,
    },
    text3: `Сейчас код выглядит довольно массивно. Разобьём его на части и разберёмся, что там происходит:`,
    code3: {
      lang: "javascript",
      value: `// duckAuth.js
return fetch(\`\${BASE_URL}/auth/local\`, {
  method: 'POST',
  headers: {
    Accept': 'application/json',
    Content-Type': 'application/json'
  },
  body: JSON.stringify({identifier, password})
})
  .then((response => response.json()))`,
    },
    text4: `Мы делаем API запрос, применяя fetch. В теле этого запроса отправляем учётные данные пользователя:
identifier — логин и password — пароль пользователя. Этот запрос возвращает промис с response.
Затем внутри первого обработчика then вызываем response.json. Этот then также возвращает промис.
Вы можете получить доступ к data внутри второго обработчика then.
Изучите этот код — именно тут происходит магия:`,
    code4: {
      lang: "javascript",
      value: `// duckAuth.js
.then((data) => {

  if (data.jwt){
    localStorage.setItem('jwt', data.jwt);
    return data;
  } else {
    return;
  }
})`,
    },
    text5: `Проверяем, есть ли свойство jwt в объекте data, который вернул сервер. Если пользователь нашёлся и его учётные данные действительны, у нас есть доступ к токену. Токен сохраним в localStorage пользователя, чтобы он был там всякий раз, когда пользователь вернётся в приложение. Наконец, вернём объект с данными пользователя. В противном случае, если свойство user отсутствует, ничего не вернётся и токена не будет. Теперь нужно настроить это внутри Login.js:`,
    code5: {
      lang: "javascript",
      value: `// Login.js
handleSubmit(e){
e.preventDefault();

if (!this.state.username || !this.state.password){
  return;
}
duckAuth.authorize(this.state.username, this.state.password)
  .then((data) => {

    if (data.jwt){
      this.setState({username: '', password: ''} ,() => {
        this.props.handleLogin();
        this.props.history.push('/ducks');
      })
    }
  })
  .catch(err => console.log(err)); // запускается, если пользователь не найден
}`,
    },
    text6: `После запуска authorize, если всё получилось, возвращается объект с JWT-токеном. После этого нужно очистить стейт и перенаправить пользователя на страницу /ducks, применив метод history.push. Обратите внимание, что мы не изменили значение loggedIn на true внутри App.js. Поэтому пользователи будут немедленно перенаправляться обратно на страницу авторизации. Ведь ProtectedRoute будет отображать маршрут /ducks только в том случае, если loggedIn равно true.
Чтобы поменять значение loggedIn, создадим метод внутри App.js, поскольку loggedIn находится в state внутри компонента App:`,
    code6: `// App.js
constructor(props){
  super(props);
  this.state = {
    loggedIn: false
  }
  this.handleLogin = this.handleLogin.bind(this);
  }
  componentDidMount() {
    // позже здесь тоже нужно будет проверить токен пользователя!
  };
  handleLogin(e){
    e.preventDefault();
    this.setState({
      loggedIn: true
    })
  }
}`,
    text7: `Передадим Login этот новый метод как пропс:`,
    code7: `<Route path="/login">
  <div className="loginContainer">
    <Login handleLogin={this.handleLogin} />
  </div>
</Route>`,
    text8: `Затем вызовем его в Login.js:`,
    code8: {
      lang: "javascript",
      value: `handleSubmit(){

  if (!this.state.username || !this.state.password){
    return;
  }
  duckAuth.authorize(this.state.username, this.state.password)
    .then((data) => {

      if (data.jwt){
        this.setState({email: '', password: ''} ,() => {
          this.props.handleLogin(); // обновляем стейт внутри App.js
          this.props.history.push('/ducks'); // и переадресуем пользователя!
        })
      }
    })
    .catch(err => console.log(err)); // запускается, если пользователь не найден
}`,
    },
    text9: `Когда пользователь входит в систему, из Login.js вызывается метод handleLogin, который изменяет состояние loggedIn внутри App.js на true.
Теперь, когда пользователь входит в систему, он сразу попадает на страницу /ducks.
Но не всё гладко. Если пользователь покидает приложение, а потом возвращается, ему нужно снова войти в систему!
Мы знаем, как это исправить. Для этого мы сохранили JWT-токен пользователя внутри localStorage.`,
  },
  {
    title: `Проверка токенов`,
    text1: `Научимся проверять токены авторизованных пользователей. Это нужно, чтобы им не пришлось снова вводить логин и пароль.
Для этого сначала напишем код, который проверит, есть ли токен в localStorage. Если он там есть, то можно сделать запрос API с токеном, чтобы убедиться, что он действительно принадлежит пользователю. Затем изменим значение loggedIn внутри App на true и перенаправим пользователя в /ducks. Для этого импортируем HOC-компонент withRouter() из react-router-dom.
Теперь нужно решить, в каком файле написать код проверки токена.
В нашем случае подойдёт метод жизненного цикла компонента componentDidMount().
Создадим внутри App.js метод, который будет вызываться в componentDidMount() при монтировании компонента. Назовём его tokenCheck().
Не забывайте, что строку this.tokenCheck = this.tokenCheck.bind(this); нужно поместить в функцию constructor():`,
    code1: {
      lang: "javascript",
      value: `// В App.js
constructor(props){
  super(props);
  this.state = {
    loggedIn: false
  }
  this.tokenCheck = this.tokenCheck.bind(this);
  this.handleLogin = this.handleLogin.bind(this);
  }
  componentDidMount() {
    // настало время проверить токен
    this.tokenCheck();
  };
  handleLogin(){
    this.setState({
      loggedIn: true
    })
  }
  tokenCheck () {
    // если у пользователя есть токен в localStorage,
    // эта функция проверит, действующий он или нет

    if (localStorage.getItem('jwt')){
      const jwt = localStorage.getItem('jwt');
      // здесь будем проверять токен
    }
  }
}`,
    },
    text2: `Этот код проверяет наличие токена у пользователя. Если он есть в localStorage — берём токен оттуда.
Теперь, чтобы проверить токен и получить данные пользователя, создадим ещё один метод авторизации внутри duckAuth.js:`,
    code2: {
      lang: "javascript",
      value: `export const getContent = (token) => {
return fetch(\`\${BASE_URL}/users/me\`, {
  method: 'GET',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json',
    'Authorization': \`Bearer \${token}\`,
  }
})
  .then(res => res.json())
  .then(data => data)
}`,
    },
    text3: `Функция getContent() принимает в качестве параметра один аргумент — JWT. Он будет отправлен на сервер (API) по маршруту /users/me, и, если токен действителен, вернёт ответ с информацией о пользователе.
Импортируем новую функцию в App.js, а затем вызовем её внутри метода tokenCheck():`,
    code3: `tokenCheck () {
// если у пользователя есть токен в localStorage,
// эта функция проверит валидность токена
const jwt = localStorage.getItem('jwt');

  if (jwt){
    // проверим токен
    duckAuth.getContent(jwt).then((res) => {

      if (res){
        // авторизуем пользователя
        this.setState({
        loggedIn: true,
        }, () => {
          // обернём App.js в withRouter
          // так, что теперь есть доступ к этому методу
          this.props.history.push("/ducks");
        });
      }
    });
  }
}`,
    text4: `Теперь, когда пользователь вернётся в приложение, всё будет отображаться так, будто он и не уходил!`,
    subtitle1: `Работа с данными`,
    text5: `Пользователь, посещающий эту страницу, по-прежнему будет видеть стандартные плейсхолдеры:`,
    image1: "image59.png",
    text6: `Внутри метода tokenCheck() вызов duckAuth.getContent() возвращает некоторые данные. Можем использовать их для заполнения полей:`,
    code4: `// В App.js
tokenCheck () {
  // если у пользователя есть токен в localStorage,
  // эта функция проверит валидность токена
  const jwt = localStorage.getItem('jwt');

  if (jwt){
    // проверим токен
    duckAuth.getContent(jwt).then((res) => {

      if (res){
        // здесь можем получить данные пользователя!
        const userData = {
          username: res.username,
          email: res.email
        }
        // поместим их в стейт внутри App.js
        this.setState({
          loggedIn: true,
          userData
          }, () => {
            this.props.history.push("/ducks");
        });
      }
    });
  }
}`,
    text7: `Мы нашли пользовательские данные и обновили state с помощью userData. Теперь внутри App.js просто нужно передать userData компоненту ProtectedComponent, который отвечает за отрисовку MyProfile внутри Switch:`,
    code5: {
      lang: "javascript",
      value: `// защищённые роуты должны выглядеть так
// обратите внимание, что мы передаём userData второму роуту
<ProtectedRoute path="/ducks" loggedIn={this.state.loggedIn} component={Ducks} />
<ProtectedRoute path="/my-profile" loggedIn={this.state.loggedIn} userData={this.state.userData} component={MyProfile} />`,
    },
    text8: `Данные будут переданы через ProtectedRoute в MyProfile, и там у нас будет доступ к ним:`,
    code6: `// MyProfile.js
import React from 'react';
import NavBar from './NavBar.js';
import './styles/MyProfile.css';
function MyProfile (props) {
  let { username, email} = props.userData;
  return (
    <>
      <NavBar />
      <div className="my-profile">
        <div className="my-profile__container">
          <div className="my-profile__header">
            <p>Мой профиль</p>
            <hr className="my-profile__rule"/>
          </div>
          <div className="my-profile__info">
            <div className="my-profile__user">
              <p className="my-profile__key">Логин:</p>
              <p className="my-profile__value">{username}</p>
            </div>
            <div className="my-profile__user">
              <p className="my-profile__key">Email:</p>
              <p className="my-profile__value">{email}</p>
            </div>
          </div>
        </div>
      </div>
    </>
  )
}
export default MyProfile;`,
    text9: `Авторизованные пользователи теперь могут часами любоваться своими данными.`,
  },
  {
    title: `Выход из системы`,
    text1: `В NavBar расположена кнопка «Выйти», которая ещё не работает. Разберёмся, как это исправить.
Сам компонент NavBar используется внутри компонентов MyProfile и Ducks:`,
    code1: `import React from 'react';
import { Link } from 'react-router-dom';
import Logo from './Logo.js';
import './styles/NavBar.css';
function NavBar () {
  return (
    <div className="navbar">
      <div className="navbar__logo">
        <Logo/>
      </div>
      <ul className="navbar__nav">
        <li><Link to="ducks" className="navbar__link">Утки</Link></li>
        <li><Link to="my-profile" className="navbar__link">Мой профиль</Link></li>
        <li><button className="navbar__link navbar__button">Выйти</button></li>
      </ul>
    </div>
  )
}
export default NavBar;`,
    text2: `Для реализации выхода из системы нужно удалить JWT-токен из localStorage и переадресовать пользователя на страницу /login.
Поскольку NavBar — функциональный компонент, воспользуемся «Реакт-хуком» useHistory:`,
    code2: `import React from 'react';
import { Link, useHistory } from 'react-router-dom';
import Logo from './Logo.js';
import './styles/NavBar.css';
function NavBar () {
const history = useHistory();
function signOut(){
  localStorage.removeItem('jwt');
  history.push('/login');
  }
  return (
    <div className="navbar">
      <div className="navbar__logo">
        <Logo/>
      </div>
      <ul className="navbar__nav">
        <li><Link to="ducks" className="navbar__link">Утки</Link></li>
        <li><Link to="my-profile" className="navbar__link">Мой профиль</Link></li>
        <li><button onClick={signOut} className="navbar__link navbar__button">Выйти</button></li>
      </ul>
    </div>
  )
}
export default NavBar;`,
    text3: `Мы добавили метод signOut. Он удаляет JWT из localStorage и затем использует метод history.push, чтобы направить пользователя обратно к роуту /login. Мы также добавили обработчик onClick, который будет вызывать этот метод всякий раз, когда пользователь нажимает на элемент <button> внутри компонента NavBar. Теперь всё работает как надо.`,
  },
  {
    title: `Создание пользователя`,
    text1: `Теперь начнём работать с процессами аутентификации и регистрации на стороне сервера.
С точки зрения сервера регистрация — это создание нового пользователя в базе данных.`,
    subtitle1: `Добавление пользователя в базу данных`,
    text2: `Сначала создадим, затем запишем пользователя в базу данных.`,
    subtitle2: `Создание`,
    text3: `Создадим модель пользователя с двумя полями:`,
    code1: {
      lang: "javascript",
      value: `// models/user.js
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true,
    minlength: 8
  }
});
module.exports = mongoose.model('user', userSchema);`,
    },
    text4: `Email должен быть уникальным, поскольку пользователь проходит аутентификацию по электронной почте.
Для этого мы добавляем свойство unique со значением true. Так в базе не могут оказаться несколько пользователей с одинаковым email.`,
    subtitle3: `Запись пользователя в БД`,
    text4: `Настроим запись пользователя в базу данных при запросе к серверу. Для этого создадим контроллер createUser.
Внутри него мы получим пришедшие в запросе почту и пароль и запишем их в базу:`,
    code2: `// controllers/users.js
const User = require('../models/user');
exports.createUser = (req, res) => User.create({
  email: req.body.email,
  password: req.body.password,
})
  .then((user) => res.send(user))
  .catch((err) => res.status(400).send(err));`,
    text5: `Если пользователь с такой почтой уже есть в базе, сработает блок catch и записи не произойдёт.`,
    subtitle4: `Хеширование пароля`,
    text6: `Пароль в базе следует хранить в зашифрованном виде. Иначе пользователи окажутся в уязвимом положении: если злоумышленник получит доступ к базе данных, он получит доступ и к аккаунтам.
Пароли хранят в виде хеша. Получить из него пароль невозможно — в этом суть хеша.
Поэтому злоумышленник не сможет получить доступ к аккаунтам пользователей, даже завладев базой данных.
Для хеширования пароля нам понадобится модуль bcryptjs.
Его нужно установить, как мы делали это с другими модулями, а затем импортировать в проект:`,
    code3: `// controllers/users.js
const bcrypt = require('bcryptjs'); // импортируем bcrypt
const User = require('../models/user');`,
    text7: `Добавим код для хеширования в контроллер создания пользователя. За это отвечает метод hash:`,
    code4: `// controllers/users.js
const bcrypt = require('bcryptjs'); // импортируем bcrypt
const User = require('../models/user');
exports.createUser = (req, res) => {
  // хешируем пароль
  bcrypt.hash(req.body.password, 10)
    .then(hash => User.create({
      email: req.body.email,
      password: hash, // записываем хеш в базу
    }))
    .then((user) => res.send(user))
    .catch((err) => res.status(400).send(err));
};`,
    text8: `Метод принимает на вход два параметра: пароль и длину так называемой «соли» — случайной строки, которую метод добавит к паролю перед хешированем.`,
    subtitle5: `Зачем нужна «соль»? Таблица поиска`,
    text9: `Хешировать пароль без прибавления «соли» небезопасно. Можно сгенерировать множество хешей и собрать их в таблицу.
Затем украсть базу данных и попытаться найти соответствие между двумя хешами.
Если такое совпадение найдётся, злоумышленник получит пароль пользователя.`,
    image1: "image60.png",
    text10: `«Соль» решает эту проблему. Прежде чем хешировать пароль, к нему будут добавлены случайные символы — это полностью поменяет итоговый хеш. Даже для двух одинаковых паролей получатся разные хеши.
Тогда злоумышленнику нужно составить по отдельной таблице хешей для каждой соли. Это по сути прямой перебор.`,
    image2: "image61.png",
  },
  {
    title: `Аутентификация на практике`,
    text1: `Переходим к аутентификации. Мы реализуем базовый способ аутентификации — по адресу почты и паролю.`,
    subtitle1: `Создаём контроллер аутентификации`,
    text2: `Чтобы войти в систему, пользователь отправляет на сервер почту и пароль. Это удобно делать в теле запроса:`,
    code1: `// controllers/users.js
module.exports.login = (req, res) => {
  const { email, password } = req.body;
  // ...
};`,
    text3: `Если почта и пароль совпадают с теми, что есть в базе, пользователь входит на сайт. Иначе — получает сообщение об ошибке.
Проверить корректность данных можно по-разному:
поискать пользователя с полученной почтой в базе, и, если пользователь нашёлся, высчитать хеш пароля и сравнить его с хешем в базе;
посчитать хеш пароля и проверить, есть ли в базе пользователь с полученной почтой и хешем пароля.
Будем пользоваться первым способом, потому что он более эффективен, т.к. при втором подходе считать хеш пароля придётся в любом случае, даже если пользователя с указанной почтой не существует.`,
    subtitle2: `Ищем пользователя`,
    text4: `Проверим, есть ли пользователь в базе:`,
    code2: `// controllers/users.js
module.exports.login = (req, res) => {
  const { email, password } = req.body;
  User.findOne({ email })
    .then((user) => {

      if (!user) {
        // пользователь с такой почтой не найден
      }
      // пользователь найден
    });
};`,
    text5: `Если пользователь не найден, перейдём в блок catch и вернём ответ с ошибкой:`,
    code3: `// controllers/users.js
module.exports.login = (req, res) => {
  const { email, password } = req.body;
  User.findOne({ email })
    .then((user) => {

      if (!user) {
        // пользователь не найден — отклоняем промис
        // с ошибкой и переходим в блок catch
        return Promise.reject(new Error('Неправильные почта или пароль'));
      }
      // пользователь найден
    })
    .catch((err) => {
      // возвращаем ошибку аутентификации
      res
        .status(401)
        .send({ message: err.message });
    });
};`,
    subtitle3: `Проверяем пароль`,
    text6: `Если пользователь найден, проверим пароль. Для этого захешируем его и сравним с хешем в базе. Для этого есть метод bcrypt.compare.
Он принимает на вход пароль и его хеш. Метод посчитает хеш и сравнит его с тем хешем, который мы передали вторым аргументом:`,
    code4: `// controllers/users.js
module.exports.login = (req, res) => {
  const { email, password } = req.body;
  User.findOne({ email })
    .then((user) => {

      if (!user) {
        return Promise.reject(new Error('Неправильные почта или пароль'));
      }
      // сравниваем переданный переданный пароль и хеш из базы
      return bcrypt.compare(password, user.password);
    })
    .catch((err) => {
      res
        .status(401)
        .send({ message: err.message });
    });
};`,
    text7: `Метод bcrypt.compare работает асинхронно, поэтому результат его работы нужно вернуть и обработать в следующем then.
Если хеши совпали, в следующий then придёт true, иначе — false:`,
    code5: `// controllers/users.js
module.exports.login = (req, res) => {
  const { email, password } = req.body;
  User.findOne({ email })
  .then((user) => {

    if (!user) {
      return Promise.reject(new Error('Неправильные почта или пароль'));
    }
    return bcrypt.compare(password, user.password);
  })
  .then((matched) => {

    if (!matched) {
      // хеши не совпали — отклоняем промис
      return Promise.reject(new Error('Неправильные почта или пароль'));
    }
    // аутентификация успешна
    res.send({ message: 'Всё верно!' });
  })
  .catch((err) => {
    res
      .status(401)
      .send({ message: err.message });
    });
};`,
    text8: `Мы намеренно сделали текст ошибки независимым от проблемы. Неважно, была ли не найдена почта или пароль неверный — мы всегда передаём ответ «Неправильные почта или пароль». Иначе злоумышленник мог бы подобрать зарегистрированные почты и попытаться взломать именно их. В нашем же случае мошенник не будет знать, где допустил ошибку.`,
  },
  {
    title: `Собственные методы моделей Mongoose`,
    text1: `Мы написали код контроллера логина:
Эта цепочка промисов работает так:
проверяет, есть ли пользователь с указанной почтой в базе;
если пользователь найден, сверяет хеш его пароля;
который принимает на вход два параметра — почту и пароль, — и возвращает объект пользователя или ошибку.
Мы улучшим код: сделаем код проверки почты и пароля частью схемы User. Для этого напишем метод findUserByCredentials,
Mongoose позволяет это делать. Чтобы добавить собственный метод, нужно записать его в свойство statics нужной схемы:`,
    code1: {
      lang: "javascript",
      value: `// models/user.js
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true
  },
    password: {
    type: String,
    required: true,
    minlength: 8
  }
});
// добавим метод findUserByCredentials схеме пользователя
// у него будет два параметра — почта и пароль
userSchema.statics.findUserByCredentials = function (email, password) {
};
module.exports = mongoose.model('user', userSchema);`,
    },
    text2: `Осталось написать код этого метода. В будущем мы хотим использовать метод вот так:`,
    code2: `User.findUserByCredentials('stasbasov@yandex.ru', 'StasBasov1989')
  .then(user => {
    // получаем объект пользователя, если почта и пароль подошли
  })
  .catch(err => {
    // получаем ошибку, если нет
  });`,
    subtitle1: `Описываем метод findUserByCredentials`,
    text3: `Чтобы найти пользователя по почте, нам потребуется метод findOne, которому передадим на вход email.
Метод findOne принадлежит модели User, поэтому обратимся к этому методу через ключевое слово this:`,
    code3: `// models/user.js
userSchema.statics.findUserByCredentials = function (email, password) {
  // попытаемся найти пользовател по почте
  return this.findOne({ email }) // this — это модель User
    .then((user) => {
      // не нашёлся — отклоняем промис

      if (!user) {
        return Promise.reject(new Error('Неправильные почта или пароль'));
      }
      // нашёлся — сравниваем хеши
      return bcrypt.compare(password, user.password);
    });
};
module.exports = mongoose.model('user', userSchema);`,
    text4: `Функция findUserByCredentials не должна быть стрелочной. Это сделано для того, чтобы мы могли пользоваться this.
Иначе оно было бы задано статически, ведь стрелочные функции запоминают значение this при объявлении.
Осталось добавить обработку ошибки, когда хеши не совпадают. Опишем этот код в ещё одном обработчике then.
Сначала разберём, как делать не стоит:`,
    code4: `// models/user.js
userSchema.statics.findUserByCredentials = function (email, password) {
// попытаемся найти пользователя по почте
  return this.findOne({ email }) // this — это модель User
    .then((user) => {
      // не нашёлся — отклоняем промис

      if (!user) {
        return Promise.reject(new Error('Неправильные почта или пароль'));
      }
      // нашёлся — сравниваем хеши
      return bcrypt.compare(password, user.password);
    })
    .then((matched) => {

      if (!matched) // отклоняем промис
        return user; // но переменной user нет в этой области видимости
      });
};
module.exports = mongoose.model('user', userSchema);`,
    text5: `Здесь во втором then мы обращаемся к объекту user, которого нет в этой области видимости. Он остался в предыдущем then.
Чтобы решить эту проблему, следует организовать цепочку промисов иначе: добавить обработчик then вызову метода bcrypt.compare:`,
    code5: `// models/user.js
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true,
    minlength: 8
  }
});
userSchema.statics.findUserByCredentials = function (email, password) {
  return this.findOne({ email }) // this — это модель User
    .then((user) => {

    if (!user) {
      return Promise.reject(new Error('Неправильные почта или пароль'));
    }
    return bcrypt.compare(password, user.password);
      .then((matched) => {

        if (!matched) {
          return Promise.reject(new Error('Неправильные почта или пароль'));
        }
        return user; // теперь user доступен
      });
    });
};
module.exports = mongoose.model('user', userSchema);`,
    text6: `Код метода готов. Теперь мы можем применить его в обработчике аутентификации:`,
    code6: `// controllers/users.js
module.exports.login = (req, res) => {
const { email, password } = req.body;
return User.findUserByCredentials(email, password)
  .then((user) => {
    // аутентификация успешна! пользователь в переменной user
  })
  .catch((err) => {
    // ошибка аутентификации
    res
      .status(401)
      .send({ message: err.message });
  });
};`,
    text7: `Теперь нужно сделать так, чтобы система запоминала пользователя и ему не приходилось вводить свои данные каждый раз...
О собственных методах схем в документации Mongoose: https://mongoosejs.com/docs/guide.html#statics.`,
  },
  {
    title: `Как не проходить аутентификацию при каждом заходе на сайт. JWT`,
    text1: `Вы уже разобрали алгоритм аутентификации. Пользователи могут логиниться, вводя электронную почту и пароль. Это хорошо.
Но плохо, что вводить почту и пароль нужно при каждом переходе на сайт.
Удобнее, когда браузер запоминает, что на этот сайт уже был выполнен вход.
Так пользователю не нужно вводить данные повторно — он сразу оказывается залогинен в свой аккаунт, как только откроет страницу.
Вы уже выполнили сохранение токена в предыдущей теме. Теперь разберёмся с серверной частью — научимся создавать токен на сервере.`,
    subtitle1: `Как создавать токен. Практика`,
    text2: `Для создания токенов воспользуемся пакетом jsonwebtoken. Его нужно установить и импортировать в проект:`,
    code1: `// controllers/users.js
const jwt = require('jsonwebtoken'); // импортируем модуль jsonwebtoken`,
    text3: `Затем вызовем метод jwt.sign, чтобы создать токен:`,
    code2: `// controllers/users.js
const jwt = require('jsonwebtoken');
module.exports.login = (req, res) => {
  const { email, password } = req.body;
  return User.findUserByCredentials(email, password)
    .then((user) => {
      // создадим токен
      const token = jwt.sign({ _id: user._id }, 'some-secret-key');
      // вернём токен
      res.send({ token });
    })
    .catch((err) => {
      res
        .status(401)
        .send({ message: err.message });
    });
};`,
    text4: `Методу sign мы передали два аргумента: пейлоуд токена и секретный ключ подписи:`,
    code3: {
      lang: "javascript",
      value: `const token = jwt.sign({ _id: user._id }, 'some-secret-key');`,
    },
    text5: `Пейлоуд токена — зашифрованный в строку объект пользователя. Для шифрования в плейлоуд можно передать сколько угодно информации.
Но ни к чему занимать трафик и отправлять лишнюю информацию. Рекомендуем шифровать только самое необходимое — идентификатор.
Этого достаточно, чтобы однозначно определить пользователя.
У метода sign есть третий необязательный параметр — объект опций. Полный список опций описан в документации модуля jsonwebtoken.
Нас интересует одна — expiresIn. Это время, в течение которого токен остаётся действительным.
Можно передать число, тогда метод sign сочтёт его за количество секунд:`,
    code4: {
      lang: "javascript",
      value: `const token = jwt.sign(
  { _id: user._id },
  'some-secret-key',
  { expiresIn: 3600 } // токен будет просрочен через час после создания
);`,
    },
    text6: `Можно передать строку, состоящую из числа и буквы. Буква означает единицы измерения — миллисекунды, минуты, часы или дни:`,
    code5: `expiresIn: '120ms' // 120 миллисекунд
expiresIn: '15m' // 15 минут
expiresIn: '2h' // 2 часа
expiresIn: '7d' // 7 дней`,
    text7: `Если опцию expiresIn не передать вовсе, токен никогда не будет просрочен.`,
  },
  {
    title: `Защищаем роуты авторизацией`,
    text1: `Чтобы действительно облегчить жизнь пользователю и избавить его от постоянной необходимости авторизовываться в приложении, нужно научиться извлекать и проверять токен, а также защищать роуты от неавторизованных пользователей.`,
    subtitle1: `Достаём токен из заголовка`,
    text2: `Авторизация в приложении работает как мидлвэр. Если предоставлен верный токен, запрос проходит на дальнейшую обработку.
Иначе запрос переходит контроллеру, который возвращает клиенту сообщение об ошибке.
Создадим для мидлвэров папку middlewares и в ней файл auth.js — тут мы напишем код для авторизации запроса:`,
    code1: `// middlewares/auth.js
module.exports = (req, res, next) => {
  // тут будет вся авторизация
};`,
    text3: `Достанем из заголовка токен. Сначала обработаем ошибку — случай, когда токена нет в заголовке:`,
    code2: `// middlewares/auth.js
module.exports = (req, res, next) => {
  // достаём авторизационный заголовок
  const { authorization } = req.headers;
  // убеждаемся, что он есть и начинается с Bearer

  if (!authorization && !authorization.startsWith('Bearer ')) {
    return res
      .status(401)
      .send({ message: err.message });
  };
};`,
    text4: `Если токен на месте, извлечём его. Для этого вызовем метод replace, чтобы выкинуть из заголовка приставку 'Bearer ':`,
    code3: `// middlewares/auth.js
module.exports = (req, res, next) => {
  const { authorization } = req.headers;

  if (!authorization && !authorization.startsWith('Bearer ')) {
    return res
      .status(401)
      .send({ message: err.message });
  }
  // извлечём токен
  const token = authorization.replace('Bearer ', '');
};`,
    text5: `Таким образом в переменную token запишется только JWT.`,
    subtitle2: `Верифицируем токен`,
    text6: `После извлечения токена из запроса нужно убедиться, что пользователь прислал именно тот токен, который был выдан ему ранее.
Такую проверку осуществляет метод verify модуля jsonwebtoken.
Метод принимает на вход два параметра: токен и секретный ключ, которым этот токен был подписан:`,
    code4: `// middlewares/auth.js
const jwt = require('jsonwebtoken');
module.exports = (req, res, next) => {
  const { authorization } = req.headers;

  if (!authorization && !authorization.startsWith('Bearer ')) {
    return res
      .status(401)
      .send({ message: err.message });
  }
  const token = authorization.replace('Bearer ', '');
  // верифицируем токен
  const payload = jwt.verify(token, 'some-secret-key');
};`,
    text7: `Метод jwt.verify вернёт пейлоуд токена, если тот прошёл проверку. Если же с токеном что-то не так, вернётся ошибка.
Чтобы её обработать, нужно обернуть метод jwt.verify в try...catch:`,
    code5: `// middlewares/auth.js
const jwt = require('jsonwebtoken');
module.exports = (req, res, next) => {
  const { authorization } = req.headers;
  if (!authorization && !authorization.startsWith('Bearer ')) {

    return res
      .status(401)
      .send({ message: 'Необходима авторизация' });
    }
  const token = authorization.replace('Bearer ', '');
  let payload;
  try {
    // попытаемся верифицировать токен
    payload = jwt.verify(token, 'some-secret-key');
  } catch (err) {
    // отправим ошибку, если не получилось
    return res
      .status(401)
      .send({ message: 'Необходима авторизация' });
  }
};`,
    text8: `Поскольку у let и const блочная область видимости, мы не можем объявить переменную payload внутри блока try — так она будет не видна снаружи. Поэтому мы объявляем её до try ключевым словом let, а записываем значение позже — в фигурных скобках блока try.`,
    subtitle3: `Записываем пейлоуд в запрос`,
    text9: `Токен верифицирован, пейлоуд извлечён. Теперь нужно записать пейлоуд в запрос — свойство req.user.
Так следующий мидлвэр сможет определить, кем этот запрос был выполнен:`,
    code6: `// middlewares/auth.js
const jwt = require('jsonwebtoken');
module.exports = (req, res, next) => {
  const { authorization } = req.headers;

  if (!authorization && !authorization.startsWith('Bearer ')) {
    return res
      .status(401)
      .send({ message: 'Необходима авторизация' });
  }
  const token = authorization.replace('Bearer ', '');
  let payload;
  try {
    payload = jwt.verify(token, 'some-secret-key');
  } catch (err) {
    return res
      .status(401)
      .send({ message: 'Необходима авторизация' });
  }
  req.user = payload; // записываем пейлоуд в объект запроса
  next(); // пропускаем запрос дальше
};`,
    subtitle4: `Защищаем роуты`,
    text10: `Авторизационный мидлвэр готов — применим его. Один из вариантов: добавить мидлвэр всему приложению:`,
    code7: {
      lang: "javascript",
      value: `// app.js
const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const { createUser, login } = require('./controllers/auth');
const auth = require('./middlewares/auth');
const app = express();
// роуты не требующие авторизации
// например, регистрация и логин
app.post('/signup', createUser);
app.post('/signin', login);
// авторизация
app.use(auth);
// роуты, которым авторизация нужна
app.use('/cards', require('./routes/cards'));`,
    },
    text11: `Другой вариант — добавить мидлвэр отдельному маршруту. Тогда его следует передать вторым аргументом обработчику запроса:`,
    code8: {
      lang: "javascript",
      value: `// сначала вызовется auth, а затем,
// если авторизация успешна, createCard
app.post('/cards', auth, createCard);`,
    },
    subtitle5: `Достаём объект пользователя`,
    text12: `При успешной авторизации в объекте запроса появится свойство user, в которое запишется пейлоуд токена.
Его можно использовать в обработчиках:`,
    code9: `// controllers/cards.js
module.exports.createCard = (req, res) => Card.create({
  name: req.body.name,
  link: req.body.link,
  owner: req.user._id // используем req.user
});`,
  },
];
