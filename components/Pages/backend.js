export const BACKEND = [
  {
    title: `Введение в серверную разработку
Вы закончили часть курса, посвящённую фронтенду. Всё это время вы писали код для браузера. Но браузер — это лишь видимая часть сайта.
Теперь мы переходим к невидимой части — к серверу.`,
    image1: "image25.png",
    subtitle1: `Что такое сервер?`,
    text1: `Сервер — это компьютер, который всегда включён. На сервере работают специальные программы: они обрабатывают входящие запросы и дают на них ответы. Вы уже создавали запросы к серверу в одной из практических работ по JavaScript:`,
    code1: {
      lang: "javascript",
      value: `fetch('https://praktikum.tk/cohort42/cards', {
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6'
  }
});`,
    },
    text2: `Получив такой запрос, сервер выполнил три шага:
проверил, что запрос корректный: токен и идентификатор группы правильные;
получил карточки от базы данных;
вернул ответ.
Если на одном из этапов возникала ошибка, сервер сообщал о ней.
У сервера есть своя логика работы. И она не появляется сама по себе — её нужно программировать.`,
    subtitle2: `На каком языке пишут серверный код?`,
    text3: `Продолжительное время серверный код нельзя было писать на JavaScript. В основном для программирования сервера использовались языки C/C++, Java, Ruby, Python или PHP. Но в 2009 году американский программист Райан Даль презентовал платформу Node.js.
В следующих уроках мы подробнее разберёмся в основных предпосылках создания Node.js и в том, что включает в себя эта платформа.
Приятный бонус в том, что изучать новый язык вам не придётся, всё будет написано на уже знакомом вам JavaScript.`,
    subtitle3: `Зачем изобрели Node.js?`,
    text4: `Здесь мы говорим о Node.js как об инструменте для программирования сервера на JavaScript. Но создана Node.js была с другой целью.
Раньше большинство веб-серверов работали так: каждый пользователь, подключаясь к серверу, получал свой поток — часть ресурсов сервера.
Соответственно, чем больше потоков, тем больше ресурсов необходимо серверу, чтобы обслужить всех пользователей.
Кроме того, при обработке запросов пользователя применялась блокирующая модель ввода-вывода. Это значит, что все наши запросы серверу будут выполняться в той же последовательности, в которой мы их отправили. А это неудобно: один запрос может требовать много времени на обработку (например, загрузка файла), а другой может быть лёгким — просто вернуть строку с данными; но сервер не примется за вторую задачу, пока не обработает первую. А значит, ответа по простой задаче вы будете ждать очень долго.`,
    image2: "image26.png",
    text5: `В случае блокирующего ввода/вывода, если на сервер приходит миллион запросов, создаётся миллион потоков, многие из которых просто ждут пока что-то выполнится и больше ничего не делают. Райан Даль — создатель Node.js — полагал, что ввод и вывод должны быть неблокирующими. И реализовать это позволяет асинхронность: если от пользователя приходит запрос, требующий обращения в базу данных, можно просто зарегистрировать колбэк, поставить его в очередь и пойти выполнять запросы других пользователей. В JavaScript мы уже привыкли к асинхронности, нас не удивишь колбэками и промисами. Именно поэтому JavaScript и стал основным языком Node.js.`,
  },
  {
    title: `За гранью браузера: что такое Node.js?`,
    text1: `Языки программирования не появляются просто так. Их создают для решения каких-то задач. JavaScript придумали, чтобы писать код для браузера, Objective-C и SWIFT — для приложений под macOS и iOS, PHP — для программирования серверов. Если язык работает только для работы в определённой среде, его называют языком конкретной предметной области.
Но языки программирования не стоят на месте. Они развиваются, обрастают новой функциональностью и инструментами — и иногда выходят за пределы изначально поставленных целей. В результате язык становится универсальным: на нём можно писать код для совершенно разных платформ. Например, на C++ можно запрограммировать и сервер, и холодильник. Такие языки называют языками общего назначения.
Именно это и произошло с JavaScript, когда вышла Node.js, или на сленге — «нода». JS эволюционировал из языка конкретной предметной области в язык общего назначения.`,
    subtitle1: `Что такое Node.js?`,
    text2: `Для ответа на этот вопрос разберёмся, что из чего собран Node.js. Основных составляющих — две:
Движок JavaScript. Он нужен для компиляции и исполнения кода — так же, как в браузере.
В Node.js используется движок V8, разработанный компанией Google для браузеров Chrome.
Набор модулей. Это утилиты, позволяющие JavaScript взаимодействовать с системами компьютера: файловой системой, сетью и другими.
Именно модули высвобождают JS из браузера и позволяют ему работать в более широких рамках. Теперь на JavaScript можно писать логику работы сервера, программировать роботов и создавать десктопные приложения.`,
    subtitle2: `Как работает Node.js?`,
    text3: `Мы говорили, что сервер — это удалённый компьютер, который умеет принимать запросы и возвращать ответы. Разберёмся, как именно он это делает. У сервера есть сетевая карта, которая может принимать запросы, поступающие из сети. Поэтому, чтобы обрабатывать запросы, нужно получить доступ к сетевой карте — научиться получать и отправлять через неё данные. JavaScript не может получить никаких данных от сетевой карты, поскольку в нём нет функциональности для взаимодействия с «железом». Это проблему решают так: пишут библиотеку команд на другом языке, у которого такая возможность есть: например, на C.
В библиотеке описаны дополнительные JavaScript-функции. Если подключить библиотеку к проекту и обратиться к одной из новых функций, движок найдёт её по имени в библиотеке и выполнит описанный там код.
Получается, что каждый модуль — это своего рода интерфейс для работы с C посредством JavaScript-команд. Код, написанный на JavaScript, взаимодействует с библиотекой libuv, написанной на C, а она обращается к файловой системе, сетевой карте и другим системам компьютера.`,
    image1: "image27.png",
    subtitle3: `Начинаем кодить`,
    text4: `В предыдущей теме вы уже установили ноду. Если вы её удалили или взяли другой компьютер, установите Node.js сейчас
Пришло время написать код. Создайте локально файл index.js с кодом:`,
    code1: `console.log('In Node We Trust');`,
    subtitle4: `Сохраните файл и запустите в терминале командой node index.js (предварительно нужно попасть в папку с файлом командой cd):`,
    image1: "image.png",
    text5: `Написанный на JavaScript код исполнился вне браузера. Node.js позволяет это делать. Также можно запускать JavaScript-команды прямо в bash.
Терминал будет работать примерно как браузерная консоль. Для этого нужно запустить команду node, а дальше писать JS-код:`,
    image1: "image28.png",
    text6: `Чтобы выйти из этого режима, нажмите Ctrl+D.`,
    subtitle5: `Нода не браузер`,
    text7: `Знакомые вам API вроде DOM и fetch есть только в браузере. Из ноды к ним обратиться не выйдет. Проверьте сами. Отредактируйте index.js:`,
    code2: `console.log(window);`,
    text8: `Запустите файл из терминала. Вы увидите такую ошибку: ReferenceError: window is not defined.
В Node.js нет объекта window, потому как нет и браузерного окна. Вместо window в Node.js есть глобальный объект global. Его свойства и методы также доступны глобально — на этом их сходство с window заканчиваются. Объект global содержит собственные методы и свойства, их мы будем изучать по ходу курса. Ну, хватит теории — пора переходить к практике. В следующем уроке создадим сервер на Node.js.`,
  },
  {
    title: `Сервер на Node.js`,
    subtitle1: `Подключите API`,
    text1: `Пришло время создать простейший сервер. Для этого нужно научить серверную программу принимать сообщения, приходящие на сетевую карту. В JavaScript нет такой встроенной возможности, но она есть в специальном API из Node.js. Имя этого API — http. Импортируйте его в код файла index.js командой require:`,
    code1: `const http = require('http');`,
    subtitle2: `Создайте сервер`,
    text2: `Для этого достаточно одной строчки кода:`,
    code2: `const http = require('http');
const server = http.createServer(); // создаём сервер`,
    text3: `Так мы даём команду библиотеке на C++ подключиться к сетевухе и принимать приходящие сообщения и получаем к ним доступ из JS-кода.`,
    subtitle3: `Настройте порт`,
    text3: `На компьютере может работать несколько программ, которым нужно принимать сообщения, приходящие на сетевую карту. Чтобы это было возможно, у сетевой карты есть много точек входа — портов. Всего портов 65536. Чтобы Node.js знала, с какого порта нужно принимать сообщения, это указывают методом listen. Укажите ноде принимать сообщения с 3000 порта:`,
    code3: `const http = require('http');
const server = http.createServer(); // создаём сервер
server.listen(3000); // будем принимать сообщения с 3000 порта`,
    subtitle4: `Установите ответ`,
    text4: `Теперь мы сможем принимать входящие сообщения. Но на них ещё нужно реагировать. Для этого функция createServer принимает колбэк — в нём и описывают код, который нужно запустить при получении запроса:`,
    code4: `const http = require('http');
// передадим обработчик
const server = http.createServer(() => {
  console.log('Пришёл запрос!');
});
server.listen(3000);`,
    text5: `Функция-обработчик, переданная createServer, будет вызываться при каждом входящем запросе, пришедшем на 3000 порт.
Сохраните этот код в файле index.js и запустите его в терминале:`,
    subtitle5: `Настройте запрос и ответ`,
    text6: `Откройте в браузере  http://localhost:3000. В терминале появится сообщение — значит, наш сервер принимает запросы и реагирует на них.
Но пока его реакция — сообщение в консоли. Нам же нужно отправить пользователю ответ. Чтобы это сделать, нужно сначала разобраться с параметрами колбэка. Первый параметр — объект запроса, второй — объект ответа:`,
    code5: `const http = require('http');
const server = http.createServer((request, response) => {
  console.log('Пришёл запрос!');
  console.log(request);
  console.log(response);
});
server.listen(3000);`,
    subtitle6: `Объект запроса`,
    text7: `Обычно его называют request или сокращённо req. Вся информация о запросе содержится в свойствах этого объекта:`,
    code6: `// запустите этот файл и перейдите
// в браузере по адресу: http://localhost:3000/hello
const http = require('http');
const server = http.createServer((req, res) => {
  console.log(req.url); // /hello
  console.log(req.method); // GET
  console.log(req.headers); // здесь будут заголовки запроса
  console.log(req.body); // а здесь тело запроса, но у GET запроса его нет
});
server.listen(3000);`,
    subtitle7: `Объект ответа`,
    text8: `Второй параметр обработчика называют response или res — это объект ответа. Он содержит свойства и методы для работы с ответом:`,
    code7: `// запустите этот файл и перейдите
// в браузере по адресу: http://localhost:3000
const http = require('http');
const server = http.createServer((req, res) => {
  res.statusCode = 200; // статус ответа
  res.statusMessage = 'OK'; // сообщение ответа
  res.setHeader('Content-Type', 'text/plain'); // добавить ответу заголовок
  res.write('Hello, '); // отправить часть ответа — строку "Hello, "
  res.write('world!'); // отправить часть ответа — строку "world!"
  res.end(); // закончить отправку ответа
});
server.listen(3000);`,
    text9: `Ответ от сервера получен! Мы отправляем ответ частями методом res.write. Как все данные получены, мы вызываем метод res.end.
Так мы обозначаем, что ответ пришёл полностью. Обратите внимание: отправку всех частей ответа мы прописываем до вызова res.end.
А вот код в примере ниже приведёт к ошибке:`,
    code8: `const http = require('http');
const server = http.createServer((req, res) => {
  res.write('Hello, ');
  res.end();
  res.write('world!'); // вызовет ошибку
});
server.listen(3000);`,
    text10: `Код статуса ответа и заголовки можно передать одним методом — writeHead:`,
    code9: {
      lang: "javascript",
      value: `const http = require('http');
const server = http.createServer((req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/html'
  });
  // в методе end тоже можно передать данные
  res.end('<h1>Привет, мир!</h1>', 'utf8');
});
server.listen(3000);`,
    },
    text11: `Вторым аргументом метод end принимает кодировку отправляемых данных. Каждый запрос должен заканчиваться вызовом этого метода.`,
    subtitle8: `Пользуйтесь переменными окружения`,
    text12: `Наш сервер готов, но у него есть одна проблема. Дело в том, что сейчас мы захардкодили входящий порт, то есть явно указали его в коде.
Это не лучшая практика: входящие данные лучше всегда передавать параметрами. В Node.js это позволяют сделать переменные окружения.
Они доступны из любой части программы, поэтому мы можем передать их при запуске сервера из терминала.
Для этого перед командой запуска прописывают имена переменных и их значения:`,
    code10: `NODE_ENV=production node app.js`,
    text13: `Внутри скриптов переменные окружения хранятся в объекте process.env:`,
    code11: `if (process.env.NODE_ENV !== 'production') {
  console.log('Код запущен в режиме разработки');
}`,
    text14: `Все переменные окружения принято называть заглавными буквами в snake case (слова разделены нижними подчёркиваниями). В переменных
окружения обычно передают необходимую приложеню конфигурационную информацию. Именно так мы укажем порт — при запуске сервера:`,
    code12: `PORT=3000 node app.js`,
  },
  {
    title: `Тело запроса: потоки`,
    text1: `В теме «Асинхронность» мы говорили, что получение ответа от сервера, не означает, что пришли данные. Так работает протокол передачи данных: информация бьётся на небольшие пакеты, а на стороне клиента они собираются воедино.
Поэтому мы вызывали метод json асинхронно: нужно было дождаться события загрузки данных, и уже затем превратить ответ в объект JSON:`,
    code1: `fetch('https://api.kanye.rest')
  .then(res => res.json())
  .then((result) => {
    console.log(result);
  });`,
    text2: `Сначала обрабатываем приход ответа, а затем — данных. Отсюда и асинхронный код.
С запросом ситуация такая же: если до сервера дошёл запрос, это ещё не значит, что пользовательские данные пришли полностью.`,
    subtitle1: `Как обрабатываются данные запроса?`,
    text3: `Заранее нам неизвестно, сколько данных пользователь отправит на сервер. При этом информация не приходит на сервер просто так — с ней нужно что-то сделать, например, записать на диск. Если бы мы ждали, пока вся информация дойдёт до сервера, и после этого начинали её обрабатывать, мы бы потеряли уйму времени. И если пользователей тысячи, сайт бы безнадёжно тормозил, а пользование им превратилось в страдание. Чтобы этого избежать, обработку запроса реализовали так: приход каждого пакета данных — это отдельное событие, которое нужно обработать асинхронно. Получается, мы устанавливаем слушатель, который отслеживает приход пакетов, и добавляем очередной пакет ко всем остальным. Так мы «попакетно» собираем запрос целиком. Обратите внимание: пока мы ждём прихода очередного пакета, мы можем работать с другими пакетами на сервере. В итоге всё работает быстро и без зависаний.`,
    subtitle2: `Как собрать данные запроса?`,
    text4: `Для работы с телом запроса есть специальный структура — поток (англ. stream). Поток — это последовательность данных, идущих от какого-то источника, например, из сети или файловой системы. Данные в потоке передаются блоками по 64 килобайта (англ. chunks). Чтобы получить тело запроса полностью, нужно получить все блоки и склеить их.`,
    subtitle3: `Что обрабатывать, когда приходит блок? Событийная модель`,
    text5: `Как мы уже говорили, приход каждого блока — отдельное событие. Чтобы его обработать пользуйтесь методом on объекта запроса:`,
    code2: `const http = require('http');
const server = http.createServer((req, res) => {
  req.on('data', (chunk) => {
    console.log(chunk); // <Buffer 66 69 65 6c 64 3d 76 61 6c 75 65>
  });
});
server.listen(3000);`,
    text6: `Событие data, которое мы обрабатываем, происходит при получении очередного пакета данных. Когда на наш сервер придёт запрос, у которого есть тело, то в консоли окажутся вот такие сообщения: <Buffer 66 69 65 6c 64 3d 76 61 6c 75 65>. Количество сообщений зависит от размера запроса: больше данных — больше сообщений. Данные из сети приходят в бинарном виде. Получить их в JavaScript мы можем благодаря специальному объекту Buffer.
Каждый пришедший блок нужно добавлять в одну переменную. После того как придёт последний пакет, мы получим тело ответа целиком:`,
    code3: `const http = require('http');
const server = http.createServer((req, res) => {
  let data = '';
  req.on('data', (chunk) => {
    data += chunk.toString();
  });
});
server.listen(3000);`,
    text7: `Когда приходит последний пакет, происходит событие end. Его и нужно обработать, чтобы превратить запрос в JSON-объект.`,
    code4: `const http = require('http');
const server = http.createServer((req, res) => {
  let data = '';
  req.on('data', (chunk) => {
    data += chunk.toString();
  });
  req.on('end', () => {
    console.log(JSON.parse(data));
  });
});
server.listen(3000);`,
    text8: `На самом деле ответ от сервера обрабатывается по той же самой схеме. Вы не писали код для склеивания блоков в единый ответ только потому, что вся эта логика скрыта под капотом браузера. Так обрабатывать входные данные значительно проще.
Такой же способ есть и для обработки запроса.`,
  },
  {
    title: `Система модулей Node.js`,
    text1: `Мы уже говорили, что модули — это то, что позвояет работать с системами компа из JavaScript. Вы создали сервер, импортировав модуль http:`,
    code1: `const http = require('http');`,
    text2: `http — встроенный модуль Node.js. Как импортировать модуль, прописывают в документации, обычно достаточно передать имя функции require.`,
    code2: `const md5 = require('md5');`,
    text3: `Так устанавливаются пакеты из npm. Но вы можете создавать свои собственные модули и импортировать в проект. Любой файл c JS-кодом может быть модулем. Для этого его лишь нужно оформить по определённым правилам. О них мы и расскажем в этом уроке.`,
    subtitle1: `Как импортировать модули?`,
    text4: `Код модуля описывают в отдельном файле, а затем импортируют в точку входа — файл index.js.
Создадим файл utils.js в папке проекта и импортируем его в index.js:`,
    code3: `// index.js
const utils = require('./utils');
// Поскольку все модули имеют расширение .js, при импорте его можно опустить и ограничиться названием модуля — utils.`,
    text5: `Точка в начале названия модуля означает, что файл нужно искать в той же директории, в которой лежит index.js. Если в папке с проектом файла utils.js нет, движок будет искать папку с именем utils, а в ней — файл index.js.
Также мы можем импортировать модуль из других папок, задав относительный путь:`,
    code4: `const utils = require('../utils'); // две точки означают переход в директорию на уровень выше
const helpers = require('../../helpers');`,
    subtitle2: `Как экспортировать модули?`,
    text6: {
      lang: "javascript",
      value: `Как мы уже сказали, чтобы модули работали, их нужно правильно оформить. Нам нужно показать, какие переменные и функции мы хотим получить снаружи. То есть нужно явно указать, что нужно экспортировать из модуля.
Для этого внутри файла доступен специальный объект module.exports. Всё, что нужно экспортировать, записывают в свойства этого модуля:`,
    },
    code5: `// utils.js
module.exports.someFunction = () => {
  console.log('Меня экспортировали');
};
module.exports.someValue = 42;`,
    text7: `Не важно, как именно вы записываете значения в свойства module.exports. Такой код тоже сработает:`,
    code6: `// utils.js
const someFunction = () => {
  console.log('Меня экспортировали');
};
const someValue = 42;
module.exports = {
  someFunction,
  someValue
};`,
    text8: `Объект module.exports — это то, что мы получим при импорте. Останется достать из этого объекта свойства:`,
    code7: `// index.js
const utils = require('./utils');
const someFunction = utils.someFunction;
const someValue = utils.someValue;`,
    text9: `Проще сделать это деструктуризацией:`,
    code8: `// index.js
const { someFunction, someValue } = require('./utils');`,
    subtitle3: `Как именовать модули?`,
    text10: `Только строчными буквами. Дело в том, что у Node.js есть свой алгоритм кеширования файлов. При этом заглавные и строчные буквы — разные символы для ноды. Поэтому прописные буквы часто ломают кеширование, и ничего не работает.
Так что пользуйтесь маленькими буквами для именования модулей.`,
  },
  {
    title: `ES6 модули работают в ноде?`,
    text1: `Да, но только начиная с 8 версии Node.js. Кроме того, есть особые правила импорта: ноду нужно запустить со специальным флагом -experimental-modules; все файлы должны иметь расширение .mjs.`,
    code1: `node -experimental-modules index.mjs`,
    text2: `Экспорт ES6-модулей выполняется иначе. Нужно экспортировать каждое нужное значение директивой export:`,
    code2: `// test.mjs
export const theme = 'ES6-module';
export const method = (name) => { return \`Здравствуйте, \${name}!\` };`,
    text3: `При импорте такого модуля мы получим объект. Ключи этого объекта такие же, как у экспортированных переменных.`,
    code3: `// index.js
import { theme, method } from './test'; // из test вернулся объект
console.log(method('Стас Басов')); // "Здравствуйте, Стас Басов!"`,
    text4: `ES6-модули работают в строгом режиме по умолчанию. Поэтому вам не нужно прописывать 'use strict'.
Но это не касается node-модулей в целом. Они работают в обычном режиме. Так что, если хотите писать код в строгом режиме, не забывайте прописывать это явно директивой 'use strict' внутри каждого модуля.`,
  },
  {
    title: `Работа с файловой системой`,
    subtitle1: `Чем занят сервер?`,
    text1: `Как мы уже говорили, Node.js позволяет взаимодействовать с системами компьютера. И одна из таких систем — файловая. Работать с файловой системой серверу приходится постоянно. Когда мы отправляем пост в Instagram, сервер должен получить фотографию или видео и записать на диск.
То же происходит при просмотре ленты: мы запрашиваем с сервера фото, и сервер находит нужный файл и отправляет нам данные.`,
    subtitle2: `Какой нужен модуль?`,
    text2: `Для работы с файлами в ноде есть модуль fs. Для каждой операции у него есть по методу. Начнём с чтения данных из файла. Это делают функцией readFile (англ. «прочитать файл»). Она работает асинхронно и принимает два аргумента: имя файла, из которого нужно прочитать данные, и колбэк. В колбэке описывают логику: что нужно сделать с прочитанными данными.
На вход колбэк принимает два аргумента: ошибку и данные файла.`,
    code1: `const fs = require('fs');
fs.readFile('data.json', (err, data) => {

  if (err) {
    console.log(err);
    return;
  }
  console.log('data: ', data.toString('utf8'));
});`,
    text3: `В первый параметр колбэка может попасть одно из двух значений:
в случае ошибки при чтении файла — объект ошибки;
null, если ответ пришёл и всё хорошо.
Второй параметр — данные файла. Они приходят в виде двоичных данных — буфера. Поэтому чтобы работать с данными, их сначала нужно преобразовать в строку одним из двух способов: методом toString, как в примере: data.toString('utf8'). Он принимает на вход строку — кодировку читаемого файла. Передать кодировку внутри свойства encoding объекта опций. В таком случае объект опций становится вторым параметром метода readFile. Данные при этом приходят сразу в виде строки, так что преобразовывать их не нужно:`,
    code2: `const fs = require('fs');
fs.readFile('data.json', { encoding: 'utf8' }, (err, data) => { // передали вторым аргументом объект опций. Он содержит свойство encoding, куда записывают кодировку данных

  if (err) {
    console.log(err);
    return;
  }
console.log('data: ', data); // здесь мы не вызываем метод toString, поскольку данные уже пришли в виде строки
});`,
  },
  {
    title: `Что ещё может модуль fs?`,
    subtitle1: `Читать все файлы директории`,
    text1: `Для этого есть метод fs.readdir. Он читает все файлы внутри директории. Первый аргумент метода — путь к директории. Второй — колбэк, в котором описана логика, что делать с полученными данными.
У колбэка также два параметра. Первый — ошибка, второй — массив имён найденных файлов:`,
    code1: `const fs = require('fs');
fs.readdir('.', (err, files) => {

  if (err) {
    console.log(err);
    return;
  }
  console.log('data: ', files);
});`,
    subtitle2: `Создавать папки`,
    text2: `Этой цели служит метод fs.mkdir. Он принимает два параметра: имя новой папки и колбэк с единственным аргументом — ошибкой. Первым параметром можно передать имя папки вместе с путём, где нужно создать папку.`,
    code2: `const fs = require('fs');
fs.mkdir('incomingData/data', (err) => {

  if (err) console.log(err);
});`,
    subtitle3: `Записывать данные в файл`,
    text3: `Для этого есть метод fs.writeFile. Принимает три параметра:
файл, куда нужно записать данные;
сами данные строкой;
колбэк для обработки ошибки.`,
    code3: `const fs = require('fs');
fs.writeFile('data.json', JSON.stringify([1, 2, 3]), (err) => {

  if (err) console.log(err);
});`,
  },
  {
    title: `Удалять файлы`,
    text1: `Это делает метод fs.unlink. У него 2 параметра: имя файла и колбэк для обработки ошибок:`,
    code1: `const fs = require('fs');
fs.unlink('data.json', (err) => {

  if (err) {
    console.log(err);
    return;
  }
  console.log('Файл удалён!');
});`,
    subtitle1: `Много чего ещё`,
    text2: `Остальные методы модуля fs работают по большей части аналогично. Поэтому, если захотите сделать с файлом что-то такое, чего мы не объясняли — просто почитайте документацию: вы без труда разберётесь.`,
    link: {
      uri: "https://nodejs.org/api/fs.html",
      text: "Ссылка на документацию модуля fs.",
    },
  },
  {
    title: `Промисы при работе с файлами`,
    text1: `В 10 версии Node.js в модуле fs появилась поддержка промисов. Если вы пользуетесь промисами, колбэки передавать не нужно. Промис разрешается с прочитанными данными или отклоняется в случае ошибки. Поэтому просто добавляйте асинхронные обработчики then:`,
    code1: `const fsPromises = require('fs').promises;
fsPromises.readFile('data.json', { encoding: 'utf8' })
  .then((data) => {
    console.log(data);
  })
  .catch(err => {
    console.log(err);
  });`,
    link1: {
      uri: "https://nodejs.org/api/fs.html#fs_fs_promises_api",
      text: "Ссылка на документацию к API для поддержки промисов.",
    },
    subtitle1: `Проблемы с путями`,
    text2: `При работе с файловой системой мы встречаемся с проблемой: как задавать пути к файлам? Относительно входного модуля или того, в котором мы пишем код? Чтобы разобраться в этом, разберём пример. У вас есть точка входа app.js с таким кодом:`,
    code2: `// app.js
const fs = require('fs');
const readFile = () => {
  const data = fs.readFile('file.txt', { encoding: 'utf8' }); // Здесь мы читаем файл file.txt по относительному пути
  console.log(data); // Выводим его содержимое в консоль
};
readFile();`,
    text3: `Позже мы решили убрать файл и всю логику работы с ним в отдельную папку — и получили такую файловую структуру:`,
    image: "image30.png",
    text4: `Поскольку логика работы с файлом теперь находится в отдельном модуле, его нужно подключить к точке входа — файлу app.js.
Импортируем функцию readFile:`,
    code3: `// app.js
const fs = require('fs');
const { readFile } = require('./files/read-file');
readFile();`,
    text5: `И экспортируем эту же функцию из read-file.js:`,
    code4: `// read-file.js
const fs = require('fs');
module.exports.readFile = () => {
  const data = fs.readFileSync('file.txt', { encoding: 'utf8' });
  console.log(data);
};`,
    text6: `Такой код приведёт к ошибке: файл file.txt не найден. Проблема в относительном пути: он отсчитывается от файла, где исполняется код, а не где он написан. Конечно, мы могли бы изменить путь к файлу в коде: вместо "file.txt" написать "/files/file.txt". Но такой подход не очень удобен. Если файлов в проекте много, менять файловую структуру становится очень сложно, потому что тяжело отследить, где в коде к каким файлам мы обращаемся. Выход из этой ситуации есть: сделать пути динамическими. То есть не прописывать путь явно, а получать его из информации о самом модуле. Для этого нам нужно: знать, где находится модуль, из которого мы обращаемся к файлу; дополнительный модуль «собирания» пути к файлу.
Обо всём по порядку.`,
    subtitle2: `Что хранится в модуле?`,
    text7: `Любой модуль Node.js содержит в себе информацию о самом себе и окружении. Например, мы всегда можем посмотреть, где лежит модуль, и является ли он входным для приложения.`,
    subtitle3: `Где находится модуль?`,
    text8: `Внутри любого модуля есть переменные __filename и __dirname. Они хранят имя файла модуля и путь к папке, где лежит модуль, соответственно.`,
    code5: {
      lang: "javascript",
      value: `// app.js
console.log(__filename); // /usr/local/project/app.js
console.log(__dirname); // /usr/local/project`,
    },
    text9: `Мы могли бы сделать путь динамическим шаблонной строкой или конкатенацией:`,
    code6: `const data = fs.readFileSync(\`\${__dirname}/file.txt\`, { encoding: 'utf8' });`,
    text10: `Но так делать не стоит. Дело в том, что на разных операционных системах бывают различные разделители. На MacOS это слеш, а на MS Windows — обратный слеш. Чтобы избежать проблем с разделителями, преобразовывать путь лучше специальным модулем — path.`,
    subtitle4: `Как преобразовать путь?`,
    text11: `Модуль path хранит множество полезных методов для работы с путём к файлу. Задачу по преобразованию пути выполняет метод join. Он учитывает контекст, а потому у нас не возникнет проблемы с разделителями, о которой мы говорили:`,
    code7: `// read-file.js
const fs = require('fs');
const path = require('path');
module.exports.readFile = () => {
  const filepath = path.join(__dirname, 'file.txt'); // собрали абсолютный путь к файлу
  const data = fs.readFileSync(filepath, { encoding: 'utf8' });
  console.log(data);
};`,
    text12: `Вот ещё несколько полезных методов модуля path:`,
    code8: `const fs = require('fs');
const path = require('path');
// path.normalize убирает из пути лишние
// разделители и разрешает символы .. и .
path.normalize('/foo/bar//baz/asdf/quux/..'); // /foo/bar/baz/asdf
// path.dirname извлекает путь к папке из переданного пути
path.dirname(process.mainModule.filename); // /usr/local/my-project
// path.extname извлекает расширение файла
path.extname('app.js'); // .js`,
    link2: {
      uri: "https://nodejs.org/api/path.html",
      text: `О других методах можете почитать в документации Node.js.`,
    },
    text13: `Для работы с файловой системой нужны два модуля: fs и path. Первый содержит методы для работы с файлами, второй — для преобразования путей. Два этих модуля позволяют нам выстроить работы с файловой системой, не навредив гибкости проекта. Мы можем менять структуру файлов, не затрагивая при этом функциональность.`,
  },
  {
    title: `Потоки для чтения и записи файлов`,
    text1: `Для чтения запроса можно использовать поток (stream) — вы уже делали это в четвёртом уроке темы. Это не единственное назначение потоков: они часто используются в Node.js, в том числе для работы с файлами. Поток — это последовательность данных, идущих от какого-то источника.
И файл вполне может быть таким источником.`,
    image1: "image31.png",
    subtitle1: `Какие бывают потоки и как ими пользоваться?`,
    text2: `Потоки бывают трёх видов:
для чтения (данных из тела запроса или из файла);
для записи (данных в файл);
дуплексные потоки (одновременно для чтения и записи).
Дуплексные потоки часто используются для трансформации поступающих в них данных. Их можно комбинировать с потоками чтения и записи.
К примеру, на сайте есть видео с разрешением 1920 на 1080 точек. Пользователь подключается к общественному вайфаю в аэропорту и пытается просмотреть видео. Скорость оставляет желать лучшего, и видео тормозит. Тут на помощь приходят потоки: сначала мы открываем поток чтения из видеофайла; данные из потока попадают в дуплексный поток: он одновременно считывает данные и преобразует их — сжимает; затем данные попадают в поток для записи — то есть к пользователю на устройство.
В результате видео хоть и потеряло в качестве, зато не тормозит.`,
    subtitle2: `Как работать с потоками?`,
    text3: `В модуле fs есть методы createReadStream и createWriteStream. Они создают потоки для чтения и записи соответственно. Первым аргументом методы принимают путь к файлу, а вторым — объект опций, где можно передать, например, кодировку:`,
    code1: {
      lang: "javascript",
      value: `const fs = require('fs');
// создаём поток для чтения из файла in.txt
const reader = fs.createReadStream('./in.txt', {encoding: 'utf8'});
// создаём поток для записи в файл out.txt
const writer = fs.createWriteStream('./out.txt', {encoding: 'utf8'});`,
    },
    text4: `Чтобы скомбинировать потоки чтения и записи, то есть превратить их в дуплексный поток, нужно при каждом событии data потока чтения записывать порцию данных в поток записи:`,
    code2: `const fs = require('fs');
const reader = fs.createReadStream('./in.txt', {encoding: 'utf8'});
const writer = fs.createWriteStream('./out.txt', {encoding: 'utf8'});
reader.on('data', (data) => { // отслеживаем событие data потока чтения
  writer.write(data); // записываем порцию данных в поток записи
});`,
    text5: `Когда данные прочитаны полностью, поток для чтения сгенерирует событие end. Это событие нужно обработать и сообщить потоку записи, что все данные пришли и ничего больше записывать не нужно. Для этого у потока для записи есть метод end:`,
    code3: `const fs = require('fs');
const reader = fs.createReadStream('./in.txt', {encoding: 'utf8'});
const writer = fs.createWriteStream('./out.txt', {encoding: 'utf8'});
reader.on('data', (data) => {
  writer.write(data);
});
// когда все данные прочитаны, даём Node сигнал,
// что поток для записи больше нам не нужен
reader.on('end', () => {
  writer.end();
});`,
    text6: `Последнее, что нужно сделать — это обработать ошибку. В случае ошибки поток для чтения сгенерирует событие error. Его нужно обработать:`,
    code4: `const fs = require('fs');
const reader = fs.createReadStream('./in.txt', {encoding: 'utf8'});
const writer = fs.createWriteStream('./out.txt', {encoding: 'utf8'});
reader.on('data', (data) => {
  writer.write(data);
});
reader.on('end', () => {
  writer.end();
});
// повесим обработчик события error
reader.on('error', (err) => {
  console.log(err);
});`,
    subtitle3: `Почему не воспользоваться методами чтения и записи файлов?`,
    text7: `Конечно, эту логику можно реализовать методами readFile и writeFile. Но при таком подходе программа работала бы медленнее. Дело в том, что серверу пришлось бы сначала полностью прочитать файл, записать его в оперативную память и только потом записывать на диск.
Получается, для обработки каждого файла вам нужно заметно больше памяти. Причём больше на размер файла.
Если вы загружаете видео, программа в целом будет работать ещё медленнее.
Использование потоков позволяет избежать таких проблем. Данные читаются небольшими порциями и тут же записываются на диск.
В оперативке при этом сохраняется только очередная порция данных, и алгоритм становится намного менее «прожорливым» в плане потребления памяти.`,
    subtitle4: `Метод pipe для работы с потоками`,
    text8: `Чтобы организовать простейшую работу с двумя потоками, мы добавили три обработчика событий. Но наш код можно сделать заметно короче, воспользовавшись специальным методом для комбинирования потоков — pipe. Нам даже не нужно закрывать потоки и обрабатывать ошибки — вся эта логика уже описана внутри метода pipe:`,
    code5: {
      lang: "javascript",
      value: `const fs = require('fs');
const reader = fs.createReadStream('./in.txt', {encoding: 'utf8'});
const writer = fs.createWriteStream('./out.txt', {encoding: 'utf8'});
reader.pipe(writer);`,
    },
    text9: `Метод pipe есть только у потоков для чтения — поток для записи передают как аргумент.
Разберём пример. Обращение пользователя к серверу — тоже поток для чтения. Так что мы можем обработать этот запрос методом pipe:`,
    code6: `const http = require('http');
const fs = require('fs');
const server = http.createServer(function (req, res) {
  req.pipe(fs.createWriteStream(\`./out-\${Math.random()}.txt\`));
});
server.listen(3000);`,
    text10: `Этим кодом мы записываем данные, отправленные пользователем в запросе, в текстовый файл со случайным именем.
Потоки — большая и сложная тема. Мы рассказали лишь об основах, которые необходимы на практике. Тем не менее, если вы хотите освоить «серьёзный» бэкенд, разобраться в потоках нужно. Поэтому после того, как пройдёте эту тему — почитайте статью о потоках в доп. материалах.`,
  },
  {
    title: `Отладка Node.js приложения`,
    text1: `Кто пишет код без ошибок? Только тот, кто не пишет код.
В курсе по фронтенду вы научились отлаживать код в браузере: для этого там есть инструменты разработчика. Нода существует вне браузера, но это не мешает использовать браузерные инструменты для отладки. Просто потребуется исполнить предварительный танец с бубном.`,
    subtitle1: `Отладка в браузере`,
    text1: `Чтобы отлаживать код Node.js в браузере, выполните два шага:
установите в Яндекс.Браузер или в Google Chrome расширение Node.js Inspector Manager;
запустите приложение с флагом --inspect:`,
    code1: `node --inspect index.js`,
    image1: "image32.png",
    text2: `После этой команды в браузере откроется вкладка с инструментами разработчика и вашим кодом:`,
    image2: "image33.png",
    text3: `Здесь можно отлаживать код так же, как вы делали это в браузере: например, устанавливать debugger в коде или создавать брейкпоинты.
Затем открывайте другую вкладку и переходите на http://localhost:3000.
Выполнение кода прервётся в точках останова, и вы сможете узнать значения переменных, наведя на них курсор.`,
    image1: "image34.png",
  },
  {
    title: `Тестирование сервера: Postman`,
    text1: `В прошлом уроке мы разобрались с отладкой кода. В этом поговорим о тестировании. Поскольку мы программируем сервер, тестирование будет заключаться в отправке запросов и проверке реакции сервера на них. В целом браузер подходит под эту задачу. Вы можете вписывать GET-запросы в адресную строку браузера, POST-запросы отправлять через форму, а методом fetch делать запросы любого типа.
Тем не менее это неудобно. Чтобы узнать информацию о запросе, например — заголовки, придётся лезть во вкладку Network в инструментах разработчика. Чтобы отправить PATCH-запрос, нужно и вовсе редактировать файл с кодом, сохранять и открывать в браузере.
В общем — нужен инструмент поудобнее браузера.`,
    subtitle1: `Инструмент для тестирования API`,
    text2: `Есть приложения для отправки на сервер запросов и получения ответов. Мы расскажем об одном из самых популярных — Postman.
Скачайте его и установите:`,
    link: { uri: "https://www.getpostman.com/downloads/.", text: "download" },
    text3: `После установки и входа перед вами будет такой экран, нажмите на плюс в левом верхнем углу:`,
    image1: "image35.png",
    text4: `Появится окно для создания запроса. В выпадающем списке слева от адресной строки можно указать тип запроса. Пока оставим GET:`,
    image2: "image36.png",
    text5: `В адресной строке нужно указать URL, куда хотим отправить запрос. Протестируем на https://api.kanye.rest. Вбейте адрес и нажмите Send:`,
    image3: "image36.png",
    text5: `Kanye REST вернёт ответ. В нижней панели отобразятся статус ответа, его тело и заголовки:`,
    image4: "image37.png",
  },
  {
    title: `Редактирование запроса`,
    text1: `Postman позволяет редактировать тело и заголовки запроса. Будем создавать такой запрос:`,
    code1: {
      lang: "javascript",
      value: `POST [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
Content-Type: application/json
{
  "title": "Привет, мир!",
  "userId": 42
}`,
    },
    text2: `Создайте POST-запрос с соответствующим URL и заголовками:`,
    image1: "image38.png",
    text3: `Настройте тело запроса. Для этого перейдите в Body, выберите кнопку raw и скопируйте в текстовую область ниже необходимый json-объект:`,
    image2: "image39.png",
    text4: `Вы можете сохранить этот запрос, нажав Save. Это полезно, если вы собираетесь неоднократно тестировать сервер этим запросом:`,
    image3: "image40.png",
    text5: `На этом всё. Postman — простой и удобный инструмент для тестирования. Он сэкономит много времени при разработке сервера или API.`,
  },
  {
    title: `Дополнительно: компьютерные сети`,
    text1: `Бэкенд-разработчик, помимо прочего, должен понимать основы устройства компьютерных сетей.
Наступит момент, когда вам потребуется защищать свой сервер от атак, настраивать шифрование, соединяться с серверами, используя различные протоколы — для этой работы необходимо понимать, какие агенты есть в интернете, как они взаимодействуют, по каким протоколам работают. В этом уроке мы расскажем об общей структуре и технических принципах работы глобальной сети: в этом нет никакой магии и шаманства, а есть чёткий набор правил и комбинаций систем.`,
    subtitle1: `Интернет с точки зрения компьютера`,
    text2: `Вы сидите дома за компьютером и ищете решение очередной кодерской задачи. На вашем столе лежит смартфон, его экран периодически вспыхивает, уведомляя о сообщениях в «воцапе» или «телеграме». Открыл сайт, прочёл сообщение — это ситуация с вашей точки зрения.
Но что происходит в это время с точки зрения устройств? Попробуем поставить себя на их место, чтобы понять, как работает интернет.`,
    image1: "image41.png",
    text3: `В вашей квартире есть ещё одно важное сетевое устройство — роутер. Он обеспечивает доступ в интернет телефону и компьютеру, передавая им данные по кабелю или по радиоволнам (если у вас Wi-Fi роутер). Роутер, в свою очередь, подключен к интернет-провайдеру, который предоставляет вам возможность подключиться к глобальной сети интернет. У вас дома есть своя маленькая «локальная» сеть из роутера, компьютера, телефона и каких-то еще устройств, которым вы дали доступ к сети (смарт-ТВ или смарт-утюг). Если не будет связи с провайдером — вы всё равно сможете работать внутри этой сети: например, при посредничестве роутера вы сможете передавать файлы с компьютера на телефон, смотреть по ТВ фильмы с компьютерного жесткого диска или гладить бельё через веб-интерфейс.
Ваша домашняя сеть связана с сетью побольше: с сетью провайдера. И если провайдер вдруг утратит связь с глобальной сетью — вы (если это позволит провайдер) всё равно сможете обмениваться данными с теми компьютерами и серверами, которые подключены к вашему провайдеру.
А пока у провайдера есть связь с внешним миром — провайдер может передавать ваши запросы в другие компьютерные сети к тем или иным серверам. Таким образом, интернет — это децентрализованная совокупность связанных между собой больших и малых сетей.`,
    subtitle2: `Как найти друг друга в сети? IP-адрес`,
    text4: `«На бытовом уровне» всё просто. Но что мы подразумеваем, говоря «быть подключённым к сети»?
Когда вы ищете что-то, ваше устройство, будь то телефон или компьютер, отправляет запросы к различным серверам и получает от них ответы.
Интернет — это огромная незримая «почтовая сеть», где посылки с данными ходят по проводам. Но чтобы доставить посылку, нам нужно знать «почтовый адрес» получателя — его IP-адрес, уникальный идентификатор устройства в сети. Чтобы обмениваться данными с сервером, вам нужно знать его IP-адрес, а ему нужно знать ваш.`,
    image2: "image42.png",
    subtitle3: `Неравенство адресов: публичные и приватные IP`,
    text5: `У каждого устройства в каждой сети есть свой IP-адрес. Но эти адреса используются и называются по-разному: это зависит от того, в сети какого уровня они используются. IP-адреса бывают публичными и приватными.
Публичные («белые») IP-адреса предназначены для адресации в глобальной сети, они уникальны.
Ваш роутер при подключении к интернету получает публичный IP-адрес от провайдера. Этот адрес уникален и не может совпадать с публичным IP-адресом другого устройства — так же, как не может быть двух домов с абсолютно одинаковыми адресами. Ведь как иначе понять, куда отправлять данные? Приватные («серые») IP-адреса уникальны только в пределах локальной сети (например, в пределах вашей квартиры). Телефон и компьютер, подключённые к вашему роутеру, не могут иметь одинаковые IP-адреса. Но у вашего соседа могут быть такие же точно адреса у устройств, подключённых к его роутеру: ведь они работают в другой локальной сети.
Все пакеты данных из интернета приходят на роутер, а тот уже разбирается, какому устройству эти пакеты отдавать — компьютеру или телефону: роутер запоминает, какое устройство из локальной сети отправило запрос в интернет и именно ему возвращает ответ на этот запрос.
Программная служба, которая занимается этим процессом, называется NAT (Network Address Translation) и запущена на вашем роутере.
В актуальном сегодня стандарте адресации IPv4 предусмотрена возможность существования довольно небольшого числа адресов: около четырёх миллиардов. И это адресное пространство сейчас почти исчерпано. Чтобы решить эту проблему, был придуман новый формат — IPv6.
Адресов этого формата больше: 340 ундециллионов (число с 36 нулями). Сам адрес имеет такой вид: 2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d.`,
    subtitle4: `Где взять IP-адрес? DHCP-службы`,
    text6: `При подключении устройства к сети каждое устройство получает IP-адрес. За процедуру выдачи IP-адреса отвечает служба DHCP
(Dynamic Host Configuration Protocol — «протокол динамической настройки узла»). В домашней сети эта служба запущена на роутере.
Если к вам в гости зайдёт знакомый и подключится к вашей сети Wi-Fi, DHCP выдаст его устройству приватный IP-адрес.
Публичные же адреса выдаёт специальный DHCP-сервер провайдера. Если вы перезагрузите свой домашний роутер, доступ в интернет появится не сразу. Это связано с обращением роутера к DHCP-серверу — приходится ждать, пока роутер получит публичный IP-адрес.
IP-адрес устройства в сети может меняться. Каждый раз, когда устройство подключается к сети, DHCP-служба роутера или провайдера выдаёт свободный адрес из числа зарезервированных для этой сети. За каждым провайдером в мире закреплён диапазон публичных IP-адресов, которые провайдер может выдавать своим клиентам при подключении.
Система выдачи свободных (случайных) IP-адресов могла бы привести к проблеме: вчера мы подключились к серверу yandex.ru и успешно искали ответы на вопросы Вселенной, но после перезагрузки сервера IP-адрес Яндекса поменялся и, выходит, мы не можем к нему подключиться? Что, если вчерашний IP Яндекса сегодня выдан какому-нибудь онлайн-казино или порносайту?
Эта проблема решена. IP-адреса могут быть как динамическими, так и статическими. Поведение динамических адресов мы уже описали: вчера у вашего роутера был один IP-адрес, а сегодня, после перезагрузки, уже другой.
А вот статические IP-адреса навсегда закреплены за сервером и не меняются: сервер может «застолбить» себе IP-адрес. Точно так же многие провайдеры предлагают и своим клиентам услугу «статический IP»: купив его, вы сможете обращаться по IP к своему домашнему компьютеру.
А для приватных сетей зарезервированы несколько блоков адресов, которые не используются в пространстве публичных IP и распределением которых занимается администратор или DHCP-служба локальной сети.`,
    subtitle5: `Поиск адреса по имени. DNS`,
    text7: `Для доступа на сайты мы не вводим IP-адресов в браузер: как их вообще можно запомнить? Чтобы сделать адреса сетевых серверов более удобными — была придумана система доменных имён, буквенных адресов, ими мы и пользуемся. Мы просто пишем имя сайта — и \ специальная система DNS преобразует доменное имя в IP-адрес, понятный компьютерным системам.
Запрошенный адрес сайта передаётся провайдеру на специальный сервер — DNS (domain name system, «система доменных имён»). Этот сервер хранит что-то вроде таблицы соответствия: какой IP-адрес за каким доменным именем закреплён.
Но провайдер не может собрать у себя полный список таких соответствий для всего интернета. Поэтому, если IP-адрес не удаётся найти на DNS-сервере провайдера, запрос передается «старшему товарищу», корневому DNS-серверу или его зеркалу.
Корневые DNS-сервера — это 13 «главных» DNS-серверов и их зеркала (копии), на которых хранится полный список соответствий «доменное имя — IP-адрес». Там нужное соответствие обязательно будет найдено, результат вернётся на DNS провайдера и сохранится там: в следующий раз уже придётся обращаться на корневой сервер с тем же запросом, ответ запомнили. А ваш запрос отправляется по полученному IP-адресу.`,
    subtitle6: `Новый адрес в интернете: пусть мир узнает обо мне`,
    text8: `Возможно, вам уже сейчас необходимо доменное имя, чтобы разместить на нём «тот самый сайт, которого не хватает в интернете».
Нужно обзавестись собственным доменом. С точки зрения пользователя вы, возможно, уже знакомы с этой процедурой.
Ищете регистратора доменных имен, регистрируетесь, выбираете подходящее свободное доменное имя (что-то простое и запоминающееся, например, poijafasdfhwed.io), заказываете, оплачиваете. Готово. Теперь вы владеете набором букв, которые никуда не ведут. Для того чтобы разместить сайт (файлы и базу данных) в интернете — вам нужен хостинг, место на сервере. Его вы покупаете и оплачиваете отдельно, не обязательно там же, где вы купили домен. Для примера возьмём хостинг-сервис hosting.fake. Регистрируетесь на сервисе, выбираете тариф, оплачиваете — готово. И после этого вы должны известить всемирную систему адресации (ту самую DNS, Domain Name System) о том, что ваш домен poijafasdfhwed.io размещён на серверах компании hosting.fake. Для этого на hosting.fake вы берёте NS-адреса** (name servers) вашего хостинга (обычно они указаны в разделе справки или настройки) и указываете эти адреса (например, ns1.hosting.fake) в настройках вашего домена в личном кабинете там, где вы покупали доменное имя. Таким образом вы связываете ваше доменное имя с хостингом.
Это называется «делегировать домен на name servers хостинга». Регистратор доменного имени передаёт эту информацию в систему DNS, и через некоторое время (обычно — от трёх часов до суток) данные, размещённые на хостинге, становятся доступны по вашему доменному имени. Задержка связана с тем, что для передачи новой информации в DNS и распространения её по «зеркалам» DNS требуется время.
Интересно наблюдать, как в один и тот же момент ваш домен будет открываться через одного провайдера (например, через вашего мобильного оператора), но не будет доступен через другого (например, домашнего провайдера). Информация распространяется не мгновенно и не равномерно, на всё требуется время, магии не бывает. Когда после успешного добавления этой информации в DNS пользователь набирает ваш адрес poijafasdfhwed.io в браузере — запрос идёт к DNS провайдера: — На каком IP этот домен? — Не знаю, спрошу у корневого, — отвечает DNS провайдера и отправляет запрос к географически ближнему корневому серверу или его «зеркалу». Тот отвечает: — Не знаю, но знаю того, кто знает, — и запрос отправляется дальше по цепочке. Путь приводит к нейм-серверу вашего хостинга, ns1.hosting.fake, а тот уже указывает на IP того сервера, где лежит ваш сайт. Готово, нашли.
А ответ сохраняется в DNS провайдера, и в следующий раз он уже не будет ни у кого спрашивать.`,
    subtitle7: `Поиск маршрута`,
    text9: `Если бы ваш компьютер и сервер были соединены проводом напрямую, мы могли бы отправлять данные по этому проводу. Но интернет — сложная сеть, где невозможно соединить каждый компьютер с каждым сервером. Данные приходится передавать через множество узлов этой сети, каждый раз определяя, какому следующему узлу передать пакет данных. Поэтому, чтобы доставить данные, IP-адреса недостаточно — ещё нужно определить маршрут. Поэтому запрос от вашего роутера поступает на роутер провайдера, тот по адресу назначения запроса определяет следующий оптимальный промежуточный узел, куда нужно передать запрос. Тот определяет следующий. И так — пока запрос не дойдёт до получателя: пакет данных может пройти через десятки серверов, прежде чем дойдёт до цели. Процесс определения оптимального пути называется маршрутизация. Решение «куда дальше отправить пакет» принимается на каждом промежуточном узле (включая ваш домашний роутер). Через какие узлы прошёл запрос всегда можно определить через терминал. Откройте его и введите команду:`,
    code1: `# Mac OS и Linux
traceroute yandex.ru
# Windows
tracert yandex.ru`,
    link: {
      uri: "http://yandex.ru/",
      text: `В командной строке вы увидите адреса серверов, через которые прошёл запрос, прежде чем достичь цели — сайта yandex.ru.`,
    },
    text10: `Мы выяснили, как запрос идёт от нашего устройства до сервера назначения. Теперь разберёмся, что представляет собой этот запрос.`,
  },
  {
    title: `Протокол передачи данных TCP`,
    text: `За передачу данных отвечает TCP (Transmission Control Protocol — «протокол управления передачей»).
Протокол TCP устанавливает связь с сервером по процедуре three way handshake (трёхэтапное согласование):
клиент посылает на сервер специальный запрос на синхронизацию;
получив запрос, сервер отвечает;
последним этапом клиент должен подтвердить, что получил ответ сервера, послав ещё один сигнал;
Связь считается установленной, если успешно прошли все три этапа. Если возникает ошибка, всё начинается заново, с отправки клиентом запроса на синхронизацию. После того как связь установлена, начинается передача данных. Сначала данные разбиваются на сегменты.
Эти сегменты нужно доставить в целости и в нужном порядке. Если какие-то пакеты потерялись по пути к серверу, они отправляются заново.
В случае, когда данные пришли не в том порядке, они упорядочиваются сервером. Если бы этого механизма не было, в сообщениях в воцапе или телеграме все буквы были бы перепутаны. Поэтому TCP называют надёжным протоколом: данные приходят в том виде, в каком были отправлены. За надёжность приходится платить скоростью передачи. Иногда это критично: например, при видеозвонках и трансляциях.
Важно, чтобы данные приходили в режиме реального времени. И ничего страшного, если часть данных пропадёт: мы просто не увидим один из кадров, и звук исказится на долю секунды. Для такой коммуникации обычно применяют другой протокол передачи данных — UDP. Он куда быстрее, но менее надёжен.`,
  },
  {
    title: `TCP/IP модель`,
    text1: `Мы выяснили, что представляют собой IP и TCP по отдельности. На базе этих протоколов была построена модель передачи данных через интернет — TCP/IP модель. Она включает в себя 4 уровня:
Каждый уровень — это набор протоколов. Разберём их все:`,
    subtitle1: `Канальный.`,
    text2: `Этот уровень ближе всего к железу. Он определяет, как разделить данные на пакеты и закодировать их для передачи по сети: как правильно упаковать информацию, чтобы промежуточные узлы понимали, куда следует отправить информацию, а принимающая сторона смогла правильно интерпретировать полученные данные. Протоколы этого уровня: WLAN (для подключения по Wi-Fi) и Ethernet (по проводу).`,
    subtitle2: `Сетевой.`,
    text3: `Данные закодированы, теперь необходимо выстроить логистику передачи пакетов, логику самой сети. Она строится на протоколе IP (Internet Protocol). Этот протокол определяет, каким образом компьютеры объединяются в сеть и как осуществляется маршрутизация пакетов в сети. IP-адрес — это часть протокола IP.`,
    subtitle3: `Транспортный.`,
    text4: `Когда сеть готова, по ней можно обмениваться информацией. За это и отвечает транспортный протокол. Он отвечает на вопрос:
«Как передавать сообщения?», и включает в себя протоколы: TCP (надежно, но неторопливо) и UDP (быстро, но с возможными потерями).`,
    subtitle4: `Прикладной.`,
    text5: `Это уровень, с которым взаимодействует пользователь. Он включает в себя протоколы: HTTP, FTP, SSH.
Данные, которые вы отправляете в запросе к поисковику или в сообщении в мессенджере, обрабатываются всеми уровнями: от канального до прикладного. Работа каждого уровня регулируется единым для всех набором правил.
Именно благодаря этим правилам мы можем пользоваться интернетом.`,
  },
];
