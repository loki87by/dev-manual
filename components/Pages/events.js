export const EVENTS = [
  {
    title: `Информация о событии. Объект event`,
    text: `Параметр event можно называть как угодно, но обычно используют evt или e. Мы будем применять evt`,
  },
  {
    title: `Цель события. Cвойство target`,
    text: `При клике на кнопку в свойство target попадает элемент кнопки`,
    code: `const button = document.querySelector('.button');
button.addEventListener('click', function (evt) {
  const eventTarget = evt.target; // в переменной eventTarget окажется элемент button, на который мы кликнули
  eventTarget.setAttribute('disabled', true);
});`,
  },
  {
    title: `Реакция на действия пользователя. События`,
    text1: `Происходящее на странице или в системе называют событием. Пользователи могут вызвать массу событий. Вот наиболее распространённые:
click' — клик по элементу;
mouseover' — пользователь навёл указатель мыши на элемент;
mouseout' — пользователь убрал указатель мыши с элемента;
scroll' — пользователь прокручивает элемент.
Универсальный способ отслеживания и реакции на событие — метод addEventListener
element.addEventListener(eventName, handler);
element — элемент, которому добавляем слушатель.
eventName — событие, на которое нужно отреагировать. Передаётся строкой: 'click', 'scroll', 'mouseover'.
handler — функция-обработчик события. Она будет вызвана, когда событие сработает (например, произойдёт клик).`,
    code1: `let element = document.querySelector('.my-element');
function showClick() {
  console.log('Мы кликнули по элементу');
}
element.addEventListener('click', showClick);`,
    text2: `Обратите внимание, что в такой записи вторым параметром обработчика указывают только имя функции без скобок. Скобки отсутствуют,
потому что мы не вызываем функцию, а просто передаём её как аргумент. Тем самым мы говорим браузеру: «вот функция showClick, вызови её,
когда сработает событие click. Функция showClick в данном случае называется функцией-колбэком. Функцию-колбэк передают другой функции
в качестве аргумента, чтобы быть вызванной позже.
Другой способ записи удобен, если вы не собираетесь вызывать функцию в других блоках кода:`,
    code2: `let element = document.querySelector('.my-element');
element.addEventListener('click', function () {
  console.log('Мы кликнули по элементу');
});`,
  },
  {
    title: `События клавиатуры`,
    text1: `Настройка обработчика события
Обработчик каждого события клавиатуры можно «повесить» на любой элемент DOM, но чаще всего его добавляют текстовым полям.
Чтобы обработать нажатие клавиши, добавьте текстовому полю обработчик события keydown`,
    code: `const input = document.querySelector('.text-field');
input.addEventListener('keydown', function () {
console.log('Я возникаю, когда печатают в текстовом поле.');
});`,
    text2: `Обработчик нажатия клавиши можно повесить и на весь документ
keydown — «клавиша нажата». Сработает на любой клавише в тот момент, когда на неё нажмут. (клавиша «в нижнем положении»);
keyup — «клавиша не нажата». Сработает на любой клавише, но только когда её отпустят.
keypress — «нажатие на клавишу». Тоже сработает при нажатии, но проигнорирует клавиши-модификаторы:
alt, ctrl, shft и win — на Windows, и control, option, shift и command — на macOS. `,
  },
  {
    title: `Объект event — клавиатура`,
    text1: `Определение клавиш
Для этого у event есть свойства key и keyCode. Первое хранит название нажатой клавиши, второе — её уникальный код.`,
    code: `const input = document.querySelector('#input');
const error = document.querySelector('#error'); // Блок с ошибкой изначально скрыт
input.addEventListener('keydown', function (evt) {

  if (Number.isNaN(Number(evt.key))) { // Проверяем, была ли введена цифра
    error.style.display = 'block'; // Если пользователь ввёл не цифру, показываем блок с ошибкой
  };
});`,
    text2: `Кроме названий у всех клавиш есть порядковые имена. Они хранятся в свойстве keyCode.
Так у цифры 0 — номер 48, у цифры 9 — номер 57. Остальные находятся в этом диапазоне.`,
  },
  {
    title: `Объект event — мышь`,
    text: `Вот список событий, которые используют чаще всего, и описание, когда они срабатывают.
События наведения курсора:
mouseover — мышь появляется над элементом, на который установлен слушатель;
mouseout — курсор мыши покидает элемент.
Дальше идут 4 события единичного щелчка мышью.
mousedown — при щелчке мышью, когда кнопка в нижнем положении;
mouseup — тоже при щелчке мышью, но когда кнопка отпущена. При этом важно только, где она была отпущена, а не где нажата.
Поэтому событие сработает, если щёлкнуть в произвольном месте, удерживать кнопку, навести на элемент и затем её отпустить.
Это сработает для клика правой кнопкой, только если отменить его стандартное событие — об этом мы расскажем позже.
События mouseup и mousedown срабатывают на все кнопки мыши: левую, правую и нажатие на колёсико.
click — при щелчке левой кнопкой, но только если она нажата и отпущена на элементе.
То есть click происходит, когда на элементе друг за другом сработали mousedown и mouseup, но обязательно левой кнопкой мыши;
contextmenu — при щелчке правой кнопкой, когда она в нижнем положении. Как mousedown, но для одной правой кнопки.
dblclick — при двойном щелчке левой кнопкой. Для этого два подряд события click сработают на одном элементе.`,
  },
  {
    title: `Снятие слушателя`,
    text: `Мы передаём как аргумент ссылку на функцию. Только тогда движок JS поймёт, что внутри addEventListener и removeEventListener идёт речь
об одной функции. Если назначить обработчик внутри вызова addEventListener, удалить его не получится — даже если вы пропишете в
removeEventListener функцию слово в слово. Эти функции только с виду одинаковы, а для JS между ними ничего общего.
Слушатели редко снимают, но иногда это нужно. Так происходит в браузерной игре: когда персонаж выпивает зелье здоровья, склянка с ним
должна исчезать. Для этого обработчик снимают: Как только зелье выпьют, обработчик снимут. Больше зелья нет.`,
  },
  {
    title: `Отмена стандартного поведения браузера`,
    text: `Обычно при правом клике появляется стандартное браузерное меню. Но на некоторых сайтах — особое, с функциями именно для этих сайтов.
Для этого достаточно сверстать меню, скрыть его, а затем отслеживать правый клик по документу. Если он проходит — показывать блок с меню.
Но есть проблема: вместе с новым контекстным меню всплывает и стандартное браузерное.
Чтобы этого избежать, нужно отменить реакцию браузера по умолчанию. Для этого есть метод evt.preventDefault
Перечислим основные стандартные реакции браузера:
клик правой кнопкой — браузер показывает контекстное меню,
клик на ссылку — браузер перезагружает страницу и открывает её в той же вкладке,
нажатие клавиши в текстовом поле — браузер добавляет в него символ нажатой клавиши,
отправка формы — браузер перезагружает страницу.
Любую из этих реакций можно отменить методом preventDefault`,
    code: `const link = document.querySelector('.link'); // выбираем элемент ссылки
link.addEventListener('click', function (evt) { // добавляем ссылке обработчик клика
evt.preventDefault(); // отменям стандартное поведение браузера
console.log('Ссылка перестала работать');
});`,
  },
  {
    title: `Всплытие и делегирование событий`,
    text1: `На веб-странице бывает много обработчиков событий. Так в плейлисте из тысячи песен может быть по одному обработчику лайка на каждую
У каждого элемента свой обработчик, хотя логика постановки одинакова. И каждый обработчик —  функция, которая занимает память браузера.
Но можно сделать процесс проще и эффективнее. Для этого используют два механизма браузера — всплытие и делегирование событий.`,
  },
  {
    title: `Всплытие событий`,
    text1: `Если событие происходит на элементе, оно срабатывает ещё и на каждом элементе-родителе. Такой механизм называется «всплытие»:`,
    code: `const parent = document.querySelector('#parent');
const firstChild = document.querySelector('#firstChild');
const secondChild = document.querySelector('#secondChild');
const thirdChild = document.querySelector('#thirdChild');
function callback(evt) {
  console.log('Событие обработано');
};
parent.addEventListener('click', callback);
firstChild.addEventListener('click', callback);
secondChild.addEventListener('click', callback);
thirdChild.addEventListener('click', callback);`,
    text2: `Если кликнуть на элемент thirdChild, текст «Событие обработано» появится в консоли 4 раза.
Так происходит, потому что вначале событие происходит на самом элементе, а потом на всех его родителях по очереди.
Поэтому обработчики клика элементов secondChild, firstChild и parent тоже сработают.
И это не всё. Кроме тех блоков, на которые мы повесили обработчики, событие сработает и на body, html, document и window`,
  },
  {
    title: `Делегирование событий`,
    text1: `Поскольку события всплывают, неважно, где вы добавите обработчик. Клик всё равно сработает на каждом элементе
— от самого глубокого, на который вы и нажали, до глобального объекта window.
Поэтому можно добавить обработчик не самой кнопке лайка, а всему плейлисту`,
    code1: `const playlist = document.querySelectorAll('.playlist');
playlist.addEventListener('click', function (evt) { // добавим обработчик лайка отдельной песни всему плейлисту
});`,
    text2: `Если пользователь ставит лайк, кнопка сердечка будет в evt.target, даже если обработчик находится на родителе
Но обработчик сработает, даже если вместо лайка кликнуть на название песни. Тогда в свойство evt.target попадёт уже не кнопка лайка, а
элемент с названием. В этом случае лайк ставить не нужно. Для этого в обработчик добавляют условную конструкцию:`,
    code2: `playlist.addEventListener('click', function (evt) {

  if (event.target.classList.contains('song__like')) { // если нажали на «Лайк», поставь лайк
    like(evt.target);
  } // иначе ничего делать не нужно
});`,
    text3: `Механизм делегирования обычно к этому и сводится. Обработчик обрабатывает каждое событие на элементе,
а условная конструкция проверяет, на каком из дочерних оно произошло.`,
  },
  {
    title: `отмена всплытия`,
    text1: `Иногда (очень редко) всплытие нужно отменить. Для этого есть два метода: stopPropagation и stopImmediatePropagation
Метод stopPropagation останавливает всплытие на элементе`,
    code: `const parent = document.querySelector('#parent');
const firstChild = document.querySelector('#firstChild');
const secondChild = document.querySelector('#secondChild');
const thirdChild = document.querySelector('#thirdChild');
function callback(evt) {
  evt.stopPropagation(); // cобытие сработало на элементе
  console.log(evt.currentTarget.getAttribute('id'));
}
parent.addEventListener('click', callback);
firstChild.addEventListener('click', callback);
secondChild.addEventListener('click', callback);
thirdChild.addEventListener('click', callback);`,
    text2: `В консоли появится только одно сообщение: "thirdChild". Дальше событие не всплыло
Метод stopImmediatePropagation ещё суровее: он отменяет не только всплытие событий,
но и срабатывание всех других обработчиков того же события на этом элементе.
Но есть тонкость. Обработчики событий срабатывают в том же порядке, в каком они описаны в коде.
Поэтому если на одном элементе висят два обработчика одного события, они сработают по очереди
Поэтому stopImmediatePropagation остановит только те обработчики, которые описаны после него.
Он попросту не знает о тех, которые стоят в коде раньше.`,
  },
];
