export const EXPRESS = [
  {
    title: `Введение`,
    text1: `В прошлой теме вы разобрались с Node.js: научились поднимать на ноде сервер, работать с файловой системой. Широкие возможности даёт  нода, а потому может показаться, что Node.js достаточно для решения любых задач. А значит, и другие инструменты не нужны.
Но это не так — другие инструменты нужны. Дело в том, что программирование сервера во многом сводится к решению типовых задач:
настроить авторизацию или реализовать логирование запросов (запись в базу данных). Поскольку разработка — дело творческое, решают типовые задачи программисты по-разному. Это приводит к проблеме с поддержкой: разработчик написал код для авторизации пользователей, а потом ушёл работать в другую компанию. Вы приходите на его место и вообще не можете понять, какая логика тут заложена. Вам придётся либо всё переделывать, либо очень долго вникать в чужой код. Для вас это головная боль, а для работодателя — уйма пущенных на ветер денег. Также от этого разрабатывать сервер приходится намного дольше. Каждый раз нужно прописывать все детали руками.
Некоторым программистам может и нравится этим заниматься. Зато компаниям отнюдь не нравится им за это платить.
Эти проблемы решаются фреймворками — наборами стандартных решений. Так вы можете из одного проекта перейти в другой и сразу «въехать» в логику, заложенную в программу. Кроме того, выстроить саму логику также становится проще и быстрее — она уже расписана и реализована. Вам нужно лишь правильно воспользоваться синтаксисом.
Хотим вас предостеречь: есть две крайности. Одна — писать весь код на чистой ноде. Другая — бездумно обращаться к методам фреймворка, не понимая, как они устроены. Такой подход ещё называют monkey coding (мартышкино программирование). Обе крайности плохи: разработчику следует уметь пользоваться современными инструментами, понимая, как они работают и какие задачи решают. В том и кроется настоящий профессионализм.
В этой теме мы научим вас пользоваться самым популярным фреймворком для разработки серверного кода — Express. Это поможет вам разворачивать сервер быстрее. А также понимать код других разработчиков: на «экспрессе» написаны тысячи серверов.`,
  },
  {
    title: `Приложение на экспресс`,
    text1: `Начнём с практики. В этом уроке мы развернём сервер, воспользовавшись экспрессом.`,
    subtitle1: `Установим`,
    text2: `Экспресс — пакет ноды. Поэтому установим его из NPM:`,
    code1: {
      lang: "bash",
      value: `# Инициализируйте package.json, чтобы нода могла устанавливать зависимости
npm init -y # флаг -y ответит «Да» на все вопросы по настройке package.json
# Установите экспресс
npm install express`},
    subtitle2: `Настроим hot reload`,
    text3: `Настроим автоматическое обновление страницы при изменении файлов. Вы делали это в теме по вебпаку. Тут нам вебпак не нужен, поэтому настраивать hot reaload мы будем специальным пакетом nodemon. Он также отслеживает изменение файлов и обновляет страницу.
Hot reaload нужен только для разработки, потому установите nodemon как dev-зависимость:`,
    code2: `# флаг -D установит nodemon как dev-зависимость
npm install nodemon -D`,
    text4: `Осталось запустить nodemon при запуске программы. Откройте package.json и отредактируйте раздел "scripts":`,
    code3: {
      lang: "javascript",
      value: `{
  ...
  "scripts": {
    "start": "nodemon index.js"
  },
  ...
}`},
    subtitle3: `Установим точку входа`,
    text5: `Создадим файл index.js и опишем в нём приложение. Для этого нужно подключить express, и затем создать приложение методом express:`,
    code4: `const express = require('express');
const app = express();`,
    text6: `Готово! Только что мы создали express-приложение.`,
    subtitle4: `Проверим, всё ли работает`,
    text7: `Настроим порт, который должно слушать приложение. Возьмём его из переменной окружения:`,
    code5: `const express = require('express');
// Слушаем 3000 порт
const { PORT = 3000 } = process.env;
const app = express();
app.listen(PORT, () => {
// Если всё работает, консоль скажет, какой порт приложение слушает
console.log(\`App listening on port \${PORT}\`)
})`,
    text8: `Запустим приложение:`,
    code6: `node index.js
# В терминале окажется сообщение "App listening on Port 3000"`,
    text9: `Перейдём в браузере по адресу http://localhost:3000. Мы видим сообщение Cannot GET /.
Стало быть, экспресс запущен и работает, уведомляя нас о том, что пока ему нечего нам отдать.`,
  },
  {
    title: `Как общаются клиент и сервер? Настройка роутинга`,
    text1: `Пока наш сервер ничего не делает: при запуске он показывает сообщение Cannot GET /.
Разберём настройки роутинга. Так наш сервер сможет отдавать веб-страницы и принимать данные от пользователя. Короче, мы будем делать то же, что в прошлой теме, но вместо чистой ноды воспользуемся экспрессом.
В этом уроке разберём обработку GET-запроса. Для обработки запросов других типов рассмотрим дальше в курсе.`,
    subtitle1: `Роутинг GET-запроса`,
    text2: `Для обработки GET-запроса в экспрессе есть метод get. Он принимает на вход 2 аргумента:
строку с запросом;
колбэк, предписывающий, что нужно делать, если на сервер пришёл такой запрос.`,
    code1: `app.get('/', (req, res) => {
// логика обработки запроса
});`,
    text3: `Параметры колбэка — объекты запроса и ответа.`,
    subtitle2: `Объект ответа`,
    text4: `У объекта ответа есть метод send — он отправляет ответ. Параметром ему передают информацию, которую нужно передать пользователю — веб-страницу, например.`,
    code2: {
      lang: "javascript",
      value: `app.get('/', (req, res) => {
  res.send(
    \`<html>
      <body>
        <p>Ответ на сигнал из далёкого космоса</p>
      </body>
    </html>\`
  );
});`},
    text5: `Мы выполнили роутинг GET-запроса.
Метод send в может принимать разные данные в качестве аргумента:`,
    code3: `res.send('немного текста');
res.send('<p>немного html</p>');
res.send({ some: 'json' });`,
    text6: `Кроме отправки ответа этот метод автоматически выставит заголовок Content-Type в соответствии с переданным аргументом:`,
    code4: `res.send('немного текста'); //  Content-Type: text/plain
res.send('<p>немного html</p>'); //  Content-Type: text/plain
res.send({ some: 'json' }); //  Content-Type: application/json`,
    text7: `По умолчанию метод send отправляет ответ со статусом 200. Статус можно изменить методом status:`,
    code5: `app.get('/', (req, res) => {
  res.status(404);
  res.send('<h1>Страница не найдена</h1>');
});`,
    text8: `Метод status устроен так, что его и метод send можно использовать по цепочке, обычно так и делают:`,
    code6: `app.get('/', (req, res) => {
  res.status(404).send('<h1>Страница не найдена</h1>');
});`,
    link: {
      uri: "http://expressjs.com/ru/api.html#res",
      text: "У объекта ответа есть и другие методы. Мы будем знакомиться с ними постепенно, но если не терпится их узнать, вот документация.",
    },
    subtitle3: `Объект запроса`,
    text9: `Запрос содержит информацию о том, что нужно пользователю. Она может быть организована по-разному в зависимости от запроса.
В GET-запросе данные пользователя «упакованы» в строку. Она хранится в свойстве query объекта запроса.`,
    code7: `app.get('/', (req, res) => {
  res.send(req.query);
});`,
    text10: `В примере мы можем передавать любые данные в формате query string, сервер обработает их и пришлёт нам JSON-файл в виде строки.`,
    image: "image43.png",
  },
  {
    title: `Все говорят о роутинге. Объясняем, что это`,
    text1: `В прошлом уроке вы настроили роутинг на экспрессе. Сейчас он работает так: для каждого запроса есть свой обработчик.
Когда клиент запрашивает какую-то страницу, соответствующий обработчик срабатывает. Такая логика подходит не всегда.
Невозможно написать по обработчику для каждой страницы пользователя в соцсети или к каждому плейлисту в музыкальном сервисе.
Такую функциональность реализуют динамическими роутами.`,
    subtitle1: `Что такое динамические роуты?`,
    text2: `Раньше вы писали статические роуты, они обрабатывали запросы на конкретные адреса: /, /animals, /search.
Динамический роут — это обработчики шаблона адреса. То есть сразу всех адресов, подходящих под какое-то правило.
Чтобы создать динамический роут, в URL укажите двоеточие и имя свойства, которое может меняться:`,
    code1: `app.get('/users/:id', (req, res) => {
// Этот код обработает все запросы, чей путь начинается с /users/111111
});`,
    text3: `Обратите внимание: значение переменной в адресе не может быть пустым. Вот такой запрос не будет обработан:`,
    code2: `http://localhost:3000/users`,
    subtitle2: `Параметры роута`,
    text4: `Обработать запрос мало — нужно как-то получить его параметры, чтобы отдавать пользователю нужные данные. В экспрессе это просто: все параметры запроса становятся свойствами JSON-объекта req.params:`,
    code2: {
      lang: "javascript",
      value: `app.get('/users/:id', (req, res) => {
  res.send(req.params);
  /* Если отправить запрос на адрес "http://localhost:3000/users/123",
  внутри объекта req.params окажется JSON-объект:
  { "id": "123" } */
});`},
    text5: `Формат JSON оказывается тут как никогда кстати. Особенно при обработке адресов со множественной вложенностью:`,
    code3: {
      lang: "javascript",
      value: `app.get('/users/:id/albums/:album/:photo', (req, res) => {
  const { id, album, photo } = req.params;
  /* При обращению к адресу "http://localhost:3000/users/123/albums/333/2"
  параметры запроса будут записаны в таком виде:
  {"id":"123","album":"333","photo":"2"}
  Мы записали их в переменные id, album и photo */
  res.send(\`Мы на странице пользователя с id \${id}, смотрим альбом №\${album} и фотографию №\${photo}\`);
});`},
    subtitle3: `Как организовать роутинг?`,
    text6: `Мы уже не раз говорили о преимуществах модульного кода. Так и логику роутинга следует разнести по разным файлам. Пусть один отвечает за основную часть сайта, другой — за админку, третий — за мобильное приложение. Разберёмся, как разбить этот код на модули:`,
    code4: `// Здесь функциональность точки входа
const express = require('express');
const { PORT = 3000 } = process.env;
const app = express();
// Здесь данные
const users = [
  { name: 'Мария', age: 22 },
  { name: 'Виктор', age: 30 },
  { name: 'Анастасия', age: 48 },
  { name: 'Алексей', age: 51 }
];
// Здесь роутинг
app.get('/users/:id', (req, res) => {

  if (!users[req.params.id]) {
    res.send(\`Такого пользователя не существует\`);
    // не забудем выйти из функции
    return;
  }
  const { name, age } = users[req.params.id];
  res.send(\`Пользователь \${name}, \${age} лет\`);
});
app.listen(PORT, () => {
  console.log(\`App listening on port \${PORT}\`);
});`,
    text7: `Вынести данные в отдельный файл. Первым делом перенесём данные в отдельный файл db.js:`,
    code5: {
      lang: "javascript",
      value: `// db.js
module.exports = {
  users: [
    { name: 'Мария', age: 22 },
    { name: 'Виктор', age: 30 },
    { name: 'Анастасия', age: 48 },
    { name: 'Алексей', age: 51 }
  ]
};`},
    text8: `Даже 4 лишние строчки кода засоряют его. А пользователей на сайте обычно больше четырёх. Так что данные всегда храните отдельно.
Настроить роутер. Код роутинга тоже перенесём в отдельный файл. Нам придётся дописать код.
Логика ответа на запросы описана в обработчиках get. Мы вызывали get как метод самого приложения — переменной app.
В отдельном модуле с роутингом этой переменной нет. И создать мы её не можем — у нас может быть только одно приложение.
Поэтому в экспрессе есть метод Router. Он создаёт объект, на который мы и повесим обработчики:`,
    code6: `// router.js
const router = require('express').Router(); // создали роутер
const { users } = require('./db.js'); // данные нужны для роутинга, поэтому импортируем их
router.get('/users/:id', (req, res) => {

  if (!users[req.params.id]) {
    res.send(\`Такого пользователя не существует\`);
    return;
  }
  const { name, age } = users[req.params.id];
  res.send(\`Пользователь \${name}, \${age} лет\`);
});
module.exports = router; // экспортировали роутер`,
    text9: `Настроить точку входа. Нужно импортировать роутер в index.js и запустить его. Запуск роутера выполняется методом use. Он принимает на вход два параметра: начало URL — роутер будет запускаться только для запросов, начинающихся с этой строки; сам роутер:`,
    code7: `// index.js
const express = require('express');
const router = require('./router.js'); // импортируем роутер
const { PORT = 3000 } = process.env;
const app = express();
app.use('/', router); // запускаем
app.listen(PORT, () => {
  console.log(\`App listening on port \${PORT}\`);
});`,
    text10: `Первый параметр метода use позволяет сделать наш код модульным. Вы можете написать разные роутеры для разной функциональности:`,
    code8: `const express = require('express');
const router = require('./router.js');
const api = require('./api.js');
const backoffice = require('./backoffice.js');
const { PORT = 3000 } = process.env;
const app = express();
// Для разных запросов разные роутеры.
// Выглядит просто отлично!
app.use('/', router);
app.use('/api', api);
app.use('/admin', backoffice);
app.listen(PORT, () => {
console.log(\`App listening on port \${PORT}\`);
});`,
    text11: `На этом всё — роутинг готов. Наше приложение можно гордо называть сервером, ведь оно выполняет главную его функцию: обработку запросов.`,
  },
  {
    title: `Промежуточная обработка. Как улучшить код посредством middlewares`,
    text1: `В заданиях прошлого урока вы описали логику роутинга:`,
    code1: {
      lang: "javascript",
      value: `router.get('/users/:id', (req, res) => {
  // логика обработки начиналась
  const { id } = req.params;

  if (!users[id]) {
    res.send({ error: 'Такого пользователя нет' });
    return;
  }
  // логика обработки заканчивалась, отправлялся ответ
  res.send(users[id]);
});`},
    text2: `Это отличный код для поставленной задачи. Но задачи обычно поставлены куда более глобальные. Часто нужно реализовать логирование или аутентификацию пользователя. Если всю эту логику прописывать внутри роутеров, кода станет так много, что в нём будет сложно разобраться.
Эту проблему решают мидлвэры (middleware) — функции промежуточной обработки. Они позволяют описать логику обработки запроса в отдельном модуле, то есть сократить код роутера. Также удобно выносить в мидлвэр типовые задачи. Например, для любого запроса сервер проверяет наличие записи в базе данных. Благодаря мидлвэру всю эту логику не нужно прописывать в каждом роутере.`,
    subtitle1: `Создаём мидлвэр`,
    text3: `Разобьём код роутера на отдельные функции: одна для проверки, есть ли пользователь в нашей базе, другая — для отправки ответа с нужным пользователем. Начнём с ответа:`,
    code2: `// Вынесём отправку ответа в отдельную функцию
const sendUser = (req, res) => {
  const { name, age } = users[req.params.id];
  res.send(\`Пользователь \${name}, \${age} лет\`);
};`,
    text4: `Переходим ко второй функции — мидлвэру. Она должна работать так:
проверять, существует ли пользователь;
если пользователь не существует, отправлять в ответе ошибку;
если пользователь найден, вызывать функцию отправки ответа с конкретным пользователем — уже написанную sendUser.
Переведём это на джаваскриптовый:`,
    code3: {
      lang: "javascript",
      value: `// Проверим, существует ли пользователь:
const doesUserExist = (req, res, next) => {

  if (!users[req.params.id]) {
    res.send('Такого пользователя не существует');
    return;
  }
  next(); // вызываем next
};
const sendUser = (req, res, next) => {
  res.send(users[req.params.id]);
};`},
    text5: `Если пользователь найден, мы вызовем функцию, переданную третьим аргументом. Осталось написать обработчик запроса:`,
    code4: {
      lang: "javascript",
      value: `router.get('/users/:id', doesUserExist);
router.get('/users/:id', sendUser);`},
    text6: `Тут происходит магия экспресса. Фреймворк написан так, что если для одного запроса есть несколько обработчиков, он будет считать функцией next следующий обработчик этого же запроса. Разберём код ещё раз. Вот функция doesUserExist:`,
    code5: {
      lang: "javascript",
      value: `const doesUserExist = (req, res, next) => {

  if (!users[req.params.id]) {
    res.send('Такого пользователя не существует');
    return; // если пользователя нет, мы выйдем из функции и больше ничего происходить не будет
  }
  next(); // если движок дошёл до функции next, он будет искать следующий обработчик того же запроса
};`},
    text7: `Допустим, нам нужен ещё один мидлвэр: для проверки уровня доступа пользователя. Мы также опишем его логику и запустим колбэк next.
Затем мы просто вставим новый обработчик запроса между уже существующими:`,
    code6: {
      lang: "javascript",
      value: `router.get('/users/:id', doesUserExist);
router.get('/users/:id', doesUserHasPermission); // Просто добавили обработчик, не трогая код других мидлвэров
router.get('/users/:id', sendUser);`},
    text8: `Внимание: колбэк мидлвэра принято всегда называть next. Старайтесь не отходить от этого правила, чтобы ваш код был понятен другим.`,
    subtitle2: `Подключаем мидлвэр`,
    text9: `В примере мы передавали мидлвэр
Для этого мы также будем пользоваться методом use. На этот раз с одним параметром — самим мидлвэром:`,
    code7: `app.use(middleware);
// index.js
const express = require('express');
const routes = require('./routes.js');
const { PORT = 3000 } = process.env;
const app = express();
const logger = (req, res, next) => {
  console.log('Запрос залогирован!');
  next();
};
app.use(logger);
app.use('/', router);
app.listen(PORT, () => {
  console.log(\`App listening on port \${PORT}\`);
});`,
  },
  {
    title: `Продвинутые мидлвэры: парсер данных`,
    text1: `В прошлом уроке вы написали мидлвэр для логирования данных. Часто этого делать не нужно — для типовых задач есть уже готовые инструменты. Это позволяет экономить время и не изобретать велосипед. О таких готовых решениях расскажем в уроке.`,
    subtitle1: `Сборка пакетов: body-parser`,
    text2: `Как мы говорили в прошлой теме, данные при передаче между клиентом и сервером бьются на блоки, а на принимающей стороне собираются обратно. Тогда мы писали код для сборки пакетов:`,
    code1: `const postForm = (req, res) => {
  let body = ''; // устанавливаем в переменную body пустую строку
  req.on('data', (chunk) => {
    body += chunk; // добавляем каждый приходящий пакет в body
  });
  req.on('end', () => { // когда всё пришло
    // можем работать с объектом из колбэк метода on
  });
};`,
    text3: `Тяжеловато. Особенно для настолько базовой задачи — приёма данных.
От столь неуместной сложности нас защищает мидлвэр body-parser.
Он самостоятельно объединяет все пакеты, так что мы можем об этом не задумываться:`,
    code2: `const postForm = (req, res) => {
  const { body } = req;
  // затем мы можем просто обращаться к body как к объекту
};`,
    subtitle2: `Подключим к проекту`,
    text4: `Body-parser устанавливают из NPM:`,
    code3: {
      lang: "bash",
      value: `npm i body-parser`},
    text5: `Затем его нужно импортировать:`,
    code4: `// app.js
const bodyParser = require('body-parser');`,
    text6: `Все методы для работы с пакетами находятся в объекте bodyParser. Нам лишь нужно задействовать те методы, которые нам нужны: это зависит от типа данных, которые нам приходят.`,
    code5: {
      lang: "javascript",
      value: `app.use(bodyParser.json()); // для собирания JSON-формата
app.use(bodyParser.urlencoded({ extended: true })); // для приёма веб-страниц внутри POST-запроса`},
    text7: `Аргументом методу bodyParser.urlencoded мы передаём объект опций. "extended: true" означает, что данные в полученном объекте body могут быть любых типов. При значении false, в свойства body могу попасть только строки и массивы. Это уже относится к более тонкой настройке, и мы не будем затрагивать подробно эту тему. Но оставим ссылку на статью в дополнительных материалах. Если вам могут прийти данные разных типов, просто задействуйте все нужные методы. — как в примере Body-parser сам разберётся, какие данные пришли и как их собирать.`,
  },
  {
    title: `Отдача html и статичных файлов в Express`,
    text1: `Мы разобрались с передачей данных в ответе на запрос. Но кроме данных, пользователю нужно отдавать статичные данные: файлы разметки, стилей, скрипты, изображения. Писать для всего этого обработчики неудобно и не нужно. Вы можете дать клиенту доступ к ним методом static.
По умолчанию пользователь не имеет доступа к файлам на вашем сервере. Но это можно изменить методом static.
Он принимает на вход адрес папки и делает её доступной «снаружи»:`,
    code1: {
      lang: "javascript",
      value: `app.use(express.static(__dirname)); // сделали доступным пользователю всё, что есть на сервере`},
    text2: `Такой код даст доступ к корню сервера. Не стоит так делать — на сервере могут храниться данные, доступ к которым извне не только не нужен, но и опасен. Например: ключи доступа к другим ресурсам или базы данных.
Поэтому файлы, которые нужно отдавать пользователям складывают в отдельную папку — её принято называть public.`,
    code2: {
      lang: "javascript",
      value: `app.use(express.static(path.join(__dirname, 'public'))); // теперь клиент имеет доступ только к публичным файлам`},
    text3: `Метод static также задаёт определённую логику отправки файлов. Если обратиться к корню сервера, мы автоматически попадём в папку public и получим файл index.html. То есть даже не нужно добавлять в запрос имя файла, достаточно просто обратиться в корень, то есть по адресу "/".
Публичная папка становится отправной точкой в проекте. Потому пути ко всем файлам указывайте относительные:`,
backState: 'first-wrong_second-true',
table: { title: ["НЕТ", "ДА"], td1: ["/public/style.css", "/style.css"] },
  },
  {
    title: `Заключение`,
    text1: `Суммируем всё, что вы изучили в этой теме.`,
    subtitle1: `Роутеры`,
    text2: `В экспрессе есть встроенный роутер:`,
    code1: {
      lang: "javascript",
      value: `const router = require('express').Router();
router.get('/users/:id', doesUserExist);`},
    text3: `Роутеры помогают организовать код. Мы можем разбить роутеры на отдельные файлы и затем передавать как колбэки методам обработки запросов. Если все роуты содержатся во входном файле, роутер можно не создавать, а добавлять передавать методу use самого приложения:`,
    code2: {
      lang: "javascript",
      value: `app.use('/users/:id', doesUserExist);`},
    subtitle2: `Мидлвэры`,
    text4: `Основной шаблон экспресса — middleware. Это функции промежуточной обработки, которые выполняются в порядке их добавления.
Мидлвэры можно добавлять всему приложению или отдельному роуту:`,
    code3: {
      lang: "javascript",
      value: `// мидлвэра всего приложения
app.use(bodyParser.urlencoded({ extended: true }));
// мидлвэры роута
app.use('/users/:id', checkRequest);
router.get('/users/:id', doesUserExist);`},
    text5: `Мидлвэры роутов работают только для запросов удовлетворяющих шаблон роута, который передаётся первым аргументом, например: /users/:id.
Мидлвэры позволяют организовать код, чтобы его было проще поддерживать.
Например, такой код проверяет, есть ли пользователь, и возвращает его, если он есть:`,
    code4: {
      lang: "javascript",
      value: `router.get('/users/:id', doesUserExist);
router.get('/users/:id', sendUser);`},
    text6: `Впоследствии, если мы решим добавить функциональность, мы не станем трогать существующий код, а просто добавим ещё один мидлвэр:`,
    code5: {
      lang: "javascript",
      value: `router.get('/users/:id', doesUserExist);
// добавили промежуточную проверку
router.get('/users/:id', doesUserHasPermission);
router.get('/users/:id', sendUser);`},
    subtitle3: `Готовые пакеты`,
    text7: `Если вам в голову приходит какая-то функциональность, скорее всего под это уже есть готовый пакет для экспресса в npm.
Такие пакеты подключают к приложению как мидлвэры. Так мы подключали body-parser:`,
    code6: {
      lang: "javascript",
      value: `// подключаем body-parser как мидлвэру всего приложения
app.use(bodyParser.urlencoded({ extended: true }));`},
    text8: `Надеемся, вам понравилось работать с экспрессом: код с ним писать проще и быстрее. Эта тема — лишь его основы.
Мы будем работать с этим фреймворком до конца курса и знакомиться с ним ближе.`,
  },
  {
    title: `Дополнительные материалы спринта`,
    subtitle1: `Поддержка нового JavaScript`,
    text1: `Как и в браузерах, новые возможности JavaScript появляются в Node,js не сразу.`,
    link1: {
      uri: "https://kangax.github.io/compat-table/es6/",
      text: "Эта таблица покажет работает ли нововведение в Node.",
    },
    subtitle2: `Асинхронность и производительность в Node.js`,
    text2: `Асинхронная модель ноды очень похожа на ту, что была в браузере. Но в Node.js есть свои нюансы.`,
    link2: {
      uri: "https://medium.com/webbdev/js-db3d35ffed7e",
      text: "Эта подробная статья рассказывает о них.",
    },
    subtitle2: `Потоки`,
    text3: `Во фронтенд-разработке мы не сталкиваемся с потоками. Поэтому их сущность может быть непонятной. В Node.js разработке потоки могут и вовсе не понадобиться. Но если придётся работать с большими файлами, они незаменимы.`,
    link3: {
      uri: "https://jscomplete.com/learn/node-beyond-basics/node-streams",
      text: "Статья о них.",
    },
    subtitle3: `Компьютерные сети`,
    text4: `Если решите углубляться в бэкенд-разработку, вам рано или поздно придётся погрузиться в то, как работает интернет.
Две статьи, объясняющие это:`,
    link4: {
      uri: "https://medium.com/free-code-camp/an-introduction-to-http-understanding-the-open-systems-interconnection-model-9dd06233d30e",
      text: "Ссылка 1.",
    },
    link5: {
      uri: "https://medium.com/free-code-camp/computer-networks-and-how-to-actually-understand-them-c1401908172d",
      text: "Ссылка 2",
    },
    subtitle4: `Роутинг приложения`,
    link6: {
      uri: "https://scotch.io/tutorials/keeping-api-routing-clean-using-express-routers",
      text: `Статья о том, как разделить роутинг на модули.`,
    },
  },
  {
    title: `API сайтов раньше и сейчас`,
    text: `Раньше сайты работали так: сервер отдавал клиенту готовые HTML-страницы. У такого подхода есть два важных недостатка:
HTML-страница нужна только браузеру. Но если у сервиса есть мобильное приложение, оно будет общаться с тем же сервером.
Мобильному приложению не нужен HTML-код — данные внутри него организованы иначе.
Поэтому нам придётся делать для мобильного приложения отдельный API.
Поскольку HTML-код генерируется на сервере, при переходе от страницы к странице браузер перезагрузит сайт целиком.
Это неэффективно, поскольку приходится перерисовывать одинаковые элементы: шапку, меню, подвал.
Разумнее получить данные об изменяющихся частях сайта и отрисовывать только их.
Из-за этих недостатков был придуман другой подход. С сервера возвращают только данные, а клиент уже сам разбирается, как эти данные отрисовать. Мобильное приложение будет использовать свои методы отрисовки, браузер — свои.
Так мы ограничиваемся одним API для разных платформ.
Кроме того, этот подход позволяет разрабатывать SPA (англ. single page application — «одностраничные приложения»).
SPA — это такие сайты, которые загружают единственный HTML-файл. Все последующие переходы выполняются из JS: он запрашивает на сервере нужные данные и точечно перерисовывает часть страницы. Знакомый вам «Реакт» позволяет собирать именно такие приложения.
В общем, многие современные API возвращают только данные, а за представление данных отвечает клиент.
Один из популярных методов для создания таких API — REST.`,
  },
  {
    title: `Что такое REST?`,
    text: `REST, или Representational State Transfer (англ. «передача состояния представления») — набор принципов, которых рекомендовано придерживаться при создании API. Если API сделан по этим принципам, его называют REST API.
Раньше клиент и сервер были тесно связаны. Например, сервер собирал веб-страницу и отдавал клиенту. Таким образом, серверу нужно было знать, какие технологии работают на стороне клиента, чтобы тот смог открыть вернувшуюся веб-страницу.
Принципы REST позволили отделить клиента от сервера. Благодаря этому:
стало проще переносить веб-приложение на другие платформы;
появилась возможность делать открытые API;
разрабатывать и тестировать серверное ПО стало проще и быстрее.
Поэтому принципы REST важно понимать для программирования сервера.`,
  },
  {
    title: `Принципы REST`,
    subtitle1: `1. Клиент-сервер`,
    text1: `Сервер и клиент отвечают за разные вещи. Ответственность клиента — пользовательский интерфейс, а ответственность сервера — данные.
Если API возвращает HTML-страницу, его нельзя назвать REST API: ведь при этом сервер берёт на себя ответственность за интерфейс.
В REST API сервер возвращает данные в каком-то формате — обычно в JSON. Именно этот принцип делает возможным точечную отрисовку страницы и существование единого API для браузера и мобильного приложения.`,
    subtitle2: `2. Отсутствие состояния (англ. "Stateless")`,
    text2: `Запрос клиента к серверу должен содержать всю информацию, необходимую для обработки этого запроса. В проекте Mesto вы отправляли на сервер токен, чтобы получить карточки. Этот токен сообщал системе, что вы — это вы: запрос содержит информацию о том, ктó запрашивает данные и какие. Раньше серверы программировали иначе. При аутентификации сервер создавал сессию, то есть запоминал, что пользователь совершил вход. Сейчас такой подход применяется редко. При отправке токена создавать сессию не нужно. Так что сервер не хранит информацию о состоянии пользователя. Поэтому принцип и называется «отсутствие состояния».`,
    subtitle3: `3. Единый интерфейс (англ. "Uniform Interface")`,
    text3: `Интерфейс обращения к серверу не зависит от клиента. Он одинаковый для всех.`,
    code1: `GET https://nomoreparties.co/cards/5d1f0611d321eb4bdcd707dd`,
    text4: `Таким образом запрос к карточке может быть сформирован из браузера, мобильного приложения и с умного чайника — для всех интерфейс един.`,
    subtitle4: `4. Многоуровневость`,
    text5: `Первый принцип гласит, что в коммуникации участвуют двое: клиент и сервер. Но мы всё равно можем строить более сложные системы, не нарушая этого принципа. Благодаря многоуровневости. API сервиса Яндекс.Такси может использовать API Яндекс.Навигатора.
Вы как клиент взаимодействуете только с API Яндекс.Такси, а он, в свою очередь, является клиентом навигатора.`,
    subtitle5: `5. Кешируемость`,
    text6: `Данные ответа могут быть закешированы. Т.е. мы можем сохранить данные на клиенте и при идентичном запросе взять их из кеша клиента.`,
    subtitle6: `6. Код по запросу (англ. "Code on demand")`,
    text7: `Этот принцип необязательный. Он гласит, что функциональность клиента может быть расширена кодом, приходящим с сервера.
Сейчас такое можно встретить повсеместно: мы получаем с сервера JS-файлы и исполняем их в браузере.
Но принципы формулировались в 2000 году — тогда с сервера код возвращали редко. Потому и выделили это в отдельный пункт.`,
  },
  {
    title: `HTTP-методы`,
    text1: `Любой API предназначен для получения доступа к ресурсам сервера. Ресурс — единица информации, с которой работает API.
В проекте Mesto такой единицей была карточка с фотографией. Карточку мы получить можем, а её часть — фотографию или число лайков — нет.
К ресурсу всегда можно обратиться по URL:`,
    code1: `GET https://nomoreparties.co/cards/5d1f0611d321eb4bdcd707dd`,
    text2: `Чтó делать с ресурсом, определяет HTTP-метод запроса. В REST применяются 5 основных методов:
GET получает ресурсы;
POST создаёт ресурс;
PUT заменяет существующий ресурс целиком;
PATCH частично изменяет существующий ресурс;
DELETE удаляет ресурс.
Реже применяют ещё 2 метода:
HEAD позволяет получить только заголовки ответа. HEAD похож на GET, но у его ответа нет тела;
OPTIONS — узнать, какие HTTP-методы поддерживает сервер.
Сам по себе метод не определяет логику работы сервера. Можно закодить API так, чтобы POST удалял ресурс, а DELETE — добавлял.
Но такой подход противоречил бы заложенной в REST идее, что методы должны применяться по назначению.`,
    subtitle1: `Обработка методов в express`,
    text3: `В экспрессе есть методы для обработки любого запроса.
Они называются так же, как соответствующие HTTP-методы, и могут быть вызваны на приложении или роутере:`,
    code2: {
      lang: "javascript",
      value: `app.get('/books', getBooks);
app.post('/books', createBook);
app.put('/books/:id', replaceBook);
app.patch('/books/:id', updateBookInfo);
app.delete('/books/:id', deleteBook);
// или
router.get('/books', getBooks);
router.post('/books', createBook);
router.put('/books/:id', replaceBook);
router.patch('/books/:id', updateBookInfo); // Функция 'updateBookInfo' будет вызвана только при PATCH-запросе на соответствующий URL
router.delete('/books/:id', deleteBook);`},
  },
  {
    title: `Правила именования ресурсов`,
    text1: `Концепцию REST API в 2000 году предложил Рой Фидлинг. В его диссертации понятие ресурса определяется так:
Ключевая абстракция информации в REST — ресурс. Ресурсом может быть документ, изображение, пост в блоге, пользователь социальной сети — всё, к чему можно обратиться при HTTP-запросе. Ресурс — это концептуальное отображение какого-то объекта или набора объектов, а не сами эти объекты. Для взаимодействия с ресурсами их необходимо как-то именовать. Чем понятнее имена, тем проще разобраться в API.
Здорово, когда по названию ресурса можно понять, чтó он содержит.`,
    subtitle1: `Ресурсы — существительные`,
    text2: `Почти всегда ресурсы именуют существительными во множественном числе:`,
    code1: `https://nomoreparties.co/users
https://nomoreparties.co/cards`,
    text3: `Реже применяют единственное число:`,
    code2: `https://nomoreparties.co/users/{user-id}/profile`,
    text4: `Иногда можно выбрать глагол в качестве имени. Но такое имя бывает удачным крайне редко:`,
    code3: `https://nomoreparties.co/users/{user-id}/cart/checkout`,
    subtitle2: `Слеш для иерархии`,
    text5: `Слеш в URL используется для указания иерархии:`,
    code4: `GET /users/{user-id}/posts`,
    subtitle3: `«Висящий» слеш — зло`,
    text6: `Висящий слеш в конце URL не добавляет информации. Так делать плохо:`,
    code5: `GET /users/{user-id}/posts/
// Не надо так`,
    subtitle4: `Дефисы вместо пробелов`,
    text7: `Поскольку пробелов в URL быть не может, их заменяют либо дефисами, либо нижними подчёркиваниями. Дефисы лучше, потому что:
на некоторых устройствах нижнее подчёркивание может выйти за базовую линию строки, и его вовсе будет не видно;
несколько нижних подчёркиваний сливаются в одно.`,
    code6: `// делайте так:
GET /users/{user-id}/user-devices
// а не так:
GET /users/{user-id}/user_devices`,
    subtitle5: `Только строчные`,
    text8: `URL чувствительны к регистру. Чтобы не думать потом, в каком регистре вы назвали ресурс, всегда пользуйтесь строчными символами:`,
    code7: `// это разные URL:
/users/{user-id}/posts
/users/{user-id}/Posts`,
    subtitle6: `Не дублировать в именовании HTTP-метод`,
    text9: `Для указания совершаемого над ресурсом действия используйте HTTP-методы:`,
    code8: `// получить пользователей
GET /users
// создать пользователя
POST /users`,
    text10: `А так не делайте: не используйте в именовании методы и действия`,
    code9: {
      lang: "bash",
      value: `GET /get-users
POST /create-user`},
  },
  {
    title: `Статус ответа сервера`,
    text1: `Ответ от сервера всегда содержит статус. Правильно выставленный статус делает API более понятным. Разберём основные статусы ответов сервера.
Статусы делят на 5 категорий. Запросы каждой из категорий начинаются с разных цифр:
1xx: Informational. Информационный ответ. Такие ответы приходят только техническим системам, вам их отправлять не придётся.
2xx: Success. Запрос прошёл успешно.
3xx Redirection. Запрос не завершён, и клиенту нужно предпринять какие-то действия, чтобы запрос успешно прошёл.
4xx: Client Error. Ошибка на стороне клиента: запрос сформирован неверно или у клиента нет нужных прав доступа.
5xx: Server Error. Ошибка на стороне сервера: что-то сломалось или сервер перегружен.`,
    subtitle1: `Самые частые статусы`,
    text2: `200 OK. Запрос прошёл успешно. Ответ с таким статусом должен содержать тело. Чаще всего этот статус используют при ответе на GET-запрос ресурса.
201 Created. Ресурс был создан на сервере. Подходящий ответ при создании нового поста в блоге, например.
202 Accepted. Сервер начал работу по удовлетворению запроса, но ещё не закончил. Этот статус применяют для ответа на запросы, обработка которых занимает много времени, например, при обработке большого объёма данных.
301 Moved Permanently. API переделали, а ресурс переместили в другое место. Новый URL указывают в заголовке Location ответа сервера.
302 Found. Запрос должен быть перенаправлен на другой URL. В заголовке Location сервер должен отправить новый URL. При получении запроса браузер автоматически отправит запрос на новый URL.
400 Bad Request. Ошибка на стороне клиента. Например, запрос был неправильно сформирован. Это общий статус: его отправляют в том случае, когда ни один другой 4xx статус не подходит.
401 Unauthorized. Запрос требует авторизации, но соответствующие авторизационные заголовки отсутствуют или сформированы неправильно.
403 Forbidden. Запрос сформирован правильно, но у клиента недостаточно прав, чтобы запрос прошёл успешно. Например, клиент пытается удалить чужой пост.
404 Not Found. Ресурс не найден. Например, пользователя с запрошенным id не существует.
405 Method Not Allowed. Ресурс запроса не поддерживает **HTTP-метод, которым сделан запрос.
500 Internal Server Error. Общий статус для ошибок на стороне сервера. Это не ошибка клиента.
501 Not Implemented. Ресурс есть на сервере, но способ обращения к нему пока не реализован.`,
    link: {
      uri: "https://restfulapi.net/http-status-codes/",
      text: `С этими статусами вам предстоит работать чаще, чем с другими. О других статусах можно почитать дополнительно.`,
    },
    subtitle2: `Статус ответа в express`,
    text3: `В express статус ответа выставляют методом объекта ответа status:`,
    code1: `// можно так
res.status(404);
res.send({ message: 'Пользователь не найден' });
// но лучше так
res.status(404).send({ message: 'Пользователь не найден' });`,
    text4: `Комбинация URL и метода запроса, который возвращает ресурсы, — это эндпоинт. Важно, что не каждый запрос с адресом является эндпоинтом.
Если запрос просто возвращает статичный файл, его эндпоинтом не назовут.`,
    code2: `GET https://nomoreparties.co/cards/5d1f0611d321eb4bdcd707dd # это эндпоинт
GET https://nomoreparties.co/cards # это тоже эндпоинт, потому что возвращает все карточки
GET https://someserver/index.html # это не эндпооинт`,
  },
  {
    title: `Кеширование ответа сервера`,
    text: `Один из принципов REST — данные могут быть закешированы, то есть сохранены на клиенте, чтобы не отвечать несколько раз на один и тот же запрос. Это ускоряет взаимодействие сервера с клиентом.
GET-запросы кешируются браузерами по умолчанию. POST-запросы, наоборот, по умолчанию не кешируются, а PUT, PATCH и DELETE не кешируются вообще.
За логику кеширования отвечают специальные заголовки GET и POST запросов. Об этих заголовках и расскажем.`,
  },
  {
    title: `Кеширующие заголовки`,
    subtitle1: `Expires`,
    text1: `Данные могут устаревать. Заголовок Expires позволяет настроить, как долго закешированные данные актуальны. После истечения этого периода данные будут запрошены с сервера, а не взяты из кеша. Сам кеш при этом обновится:`,
    code1: {
      lang: "json",
      value: `Expires: Fri, 20 May 2016 19:20:49 IST`},
    subtitle2: `Cache-Control`,
    text2: `В этом заголовке указывают одну из директив для настройки обращения с закешированными данными. Вот наиболее используемые:`,
    code2: {
      lang: "json",
      value: `// управление кешированием
Cache-Control: only-if-cached // если ответ в кеше, взять его оттуда, не отправляя запрос
Cache-Control: no-cache // кеш сразу становится просроченным, а затем данные ответа в кеше проверяются
// управление временем жизни
Cache-Control: max-age=30000 // максимальное время в секундах, в течение которого ресурс считается актуальным
// управление обновлением кеша
Cache-Control: must-revalidate // если кеш просроченый, будет отправлен запрос на проверку данных в кеше
// другое
Cache-Control: no-store // кеш отключён`},
    text3: `Данные от клиента к серверу идут не напрямую, а через другие машины — прокси-серверы. На этих промежуточных машинах данные тоже могут быть закешированы. Этим также можно управлять, установив заголовок Cache-Control:`,
    code3: {
      lang: "json",
      value: `Cache-Control: private // данные могут быть закешированы только на клиенте
Cache-Control: public // данные могут быть закешированы на промежуточных серверах
Cache-Control: proxy-revalidate // перед использованием данных из кеша прокси-сервера, их актуальность должна быть проверена
Cache-Control: no-transform // прокси не могут применять к ресурсу преобразования.
// Другие настройки — private, public и proxy-revalidate — таких ограничений не накладывают`},
    text4: `В Cache-Control можно указать сразу несколько директив через запятую:`,
    code4: {
      lang: "json",
      value: `Cache-Control: max-age=30000, must-revalidate`},
    text5: `Кроме Expires и Cache-Control, есть два заголовка, которые отвечают за валидацию кеша — ETag и Last-Modified.`,
    subtitle3: `ETag`,
    text6: `Чтобы при каждой валидации не отправлять кеш сервер целиком, был придуман механизм хэширования. Он заключается в следующем: определённый алгоритм анализирует кеш и на основе этого создаёт строку — хэш (о нём говорили в теме о технологии Git). Такая строка уникальна для любого набора данных. Можно хранить в кеше только эту строку и передавать её для валидации — это куда эффективнее.
В заголовок Etag можно записать хэш. Если тело ответа меняется, изменится и хэш:`,
    code5: {
      lang: "json",
      value: `ETag: "abcd1234567n34jv"`},
    subtitle4: `Last-Modified`,
    text7: `Заголовок Last-Modified хранит дату последнего изменения данных на сервере, что позволяет валидировать данные в кеше:`,
    code6: {
      lang: "json",
      value: `Last-Modified: Fri, 10 May 2016 09:17:49 IST`},
    subtitle5: `Кеширующие заголовки в express`,
    text8: `Express по умолчанию работает так:
Создаёт заголовок ответа Etag, который посылает в каждом ответе сервера. Таким образом кешируется каждый ответ.
Значение заголовка запоминает браузер и при следующем GET-запросе отправляет Etag внутри другого заголовка — If-None-Match.
Если значение заголовка If-None-Match совпадает с каким-то кешем на сервере, ответ придёт в статусе 304 Not Modified.
И браузер возьмёт значение ответа из своего кеша. POST-запросы по умолчанию не кешируются.
Да и на практике к кешированию POST-запросов прибегают редко. Но оно возможно: достаточно вручную выставить кеширующие заголовки.`,
  },
  {
    title: `CORS`,
    subtitle1: `Защита от злоумышленников: CORS`,
    text1: `В современных браузерах есть ограничение: по умолчанию вы не можете отправить запрос из фронтенда одного сайта к другому.
Если вы находитесь на сайте https://one-site.com, не получится запросить что-то методом fetch у сайта https://another-site.com. Браузер выдаст:`,
    image: "image44.png",
    text2: `Это браузерное ограничение было введено из соображений безопасности. Вместе с запросом браузер отправляет серверу дополнительные данные — «куки» (англ. cookie). Куки — строка, которая может быть использована сервером для авторизации на сайте.
Если бы ограничения на отправку запросов между сайтами не было, злоумышленники смогли бы использовать ваши куки в своих целях.
Они бы создали сайт со специальным скриптом, и как только вы бы зашли на него, вашему интернет-банку ушёл бы запрос на перевод денег мошенникам. В интернете царили бы анархия и хаос.
Поэтому по умолчанию кросс-доменные запросы запрещены. Но поведение по умолчанию можно изменить.
Это необходимо при создании открытых API — таких как Kanye API, которым вы уже пользовались. К открытому API должна быть возможность обратиться с любого домена, и браузер не должен это блокировать.`,
    subtitle2: `Разрешение кросс-доменных запросов`,
    text3: `Браузер не может решить самостоятельно, можно ли отправлять кросс-доменные запросы. Для этого ему нужно разрешение от сервера.
Для получения этого разрешения есть специальный механизм предзапросов (англ. "preflight request"). Сначала браузер посылает предварительный запрос к серверу и, если получает разрешение, отправляет основной запрос на нужный домен.
Если кросс-доменные запросы нужно разрешить, мы должны запрограммировать сервер так, чтобы он давал браузерам разрешение такие запросы отправлять. Это делают установкой специальных заголовков ответа.`,
    subtitle3: `Откуда принимать запросы?`,
    text4: `В заголовке Access-Control-Allow-Origin указывают URL, запросы с которого можно обрабатывать.
Так мы позволим сайту https://my-site.com отправлять запросы на наш сервер:`,
    code1: `Access-Control-Allow-Origin: https://my-site.com`,
    text5: `Чтобы разрешить запросы с любых URL, в этот заголовок записывают звёздочку:`,
    code2: {
      lang: "bash",
      value: `Access-Control-Allow-Origin: *`},
    subtitle4: `Какие запросы обрабатывать? Методы и заголовки`,
    text6: `В заголовке Access-Control-Allow-Methods указывают допустимые методы. В Access-Control-Allow-Headers — какие заголовки могут в нём быть.`,
    code3: {
      lang: "json",
      value: `**Access-Control-Allow-Methods**: GET,HEAD,PUT,PATCH,POST,DELETE
**Access-Control-Allow-Headers**: Origin, X-Requested-With, Content-Type, Accept`},
    text7: `Полный список заголовков, которые можно разрешить, довольно длинный. Статью об этом мы приводим в дополнительных материалах.`,
    subtitle5: `Выставляем заголовки в express`,
    text8: `Чтобы разрешить кросс-доменные запросы, приложению добавляют мидлвэр:`,
    code4: {
      lang: "javascript",
      value: `app.use(function(req, res, next) {
  res.header('Access-Control-Allow-Origin', 'https://praktikum.tk');
  next();
});`},
    text9: `В этом же мидлвэре настраивают разрешённые заголовки и методы:`,
    code5: {
      lang: "javascript",
      value: `app.use(function(req, res, next) {
  res.header('Access-Control-Allow-Origin', 'https://praktikum.tk');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  res.header('Access-Control-Allow-Methods', 'GET,HEAD,PUT,PATCH,POST,DELETE');
  next();
});`},
    subtitle6: `Как разрешить запросы с нескольких ресурсов`,
    text10: `В заголовок Access-Control-Allow-Origin можно записать либо один URL, либо сразу все. Иногда нужно разрешить кросс-доменные запросы с нескольких ресурсов, но не всех. Например, с локального сервера и продакшн-сайта.
У любого запроса есть заголовок Origin. Он содержит адрес, с которого этот запрос идёт. Мы можем создать массив разрешённых доменов, а затем проверять, есть ли среди них тот, что указан в заголовке Origin.
Если домен найден среди разрешённых, просто переписываем значение Origin в заголовок ответа Access-Control-Allow-Origin:`,
    code6: {
      lang: "javascript",
      value: `// Массив разешённых доменов
const allowedCors = [
  'https://praktikum.tk',
  'http://praktikum.tk',
  'localhost:3000'
];
app.use(function(req, res, next) {
  const { origin } = req.headers; // Записываем в переменную origin соответствующий заголовок

  if (allowedCors.includes(origin)) { // Проверяем, что значение origin есть среди разрешённых доменов
    res.header('Access-Control-Allow-Origin', origin);
  }
  next();
});`},
  },
  {
    title: `Установка CORS`,
    code1: `$ npm install cors`,
    subtitle1: `Однократное использование (включить CORS для всех запросов)`,
    code2: `const express = require('express')
const cors = require('cors')
const app = express()
app.use(cors())
app.get('/products/:id', function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for all origins!'})
})
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})`,
    subtitle2: `Использование CORS для определенных роутов`,
    code3: `const express = require('express')
const cors = require('cors')
const app = express()
app.get('/products/:id', cors(), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for a Single Route'})
})
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})`,
    subtitle3: `Настройка CORS`,
    code4: `const express = require('express')
const cors = require('cors')
const app = express()
const corsOptions = {
  origin: 'http://example.com',
  optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204
}
app.get('/products/:id', cors(corsOptions), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for only example.com.'})
})
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})`,
    subtitle4: `Configuring CORS w/ Dynamic Origin`,
    code5: `const express = require('express')
const cors = require('cors')
const app = express()
const whitelist = ['http://example1.com', 'http://example2.com']
const corsOptions = {
  origin: function (origin, callback) {

    if (whitelist.indexOf(origin) !== -1) {
      callback(null, true)
    } else {
      callback(new Error('Not allowed by CORS'))
    }
  }
}
app.get('/products/:id', cors(corsOptions), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for a whitelisted domain.'})
})
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})`,
  },
  {
    title: `Заключение`,
    text: `REST — один из подходов к созданию API. Он сильно повлиял на взаимодействие серверной и клиентской частей приложения: стало проще переносить функциональность на новые платформы и расширять серверные мощности, не затрагивая клиента.
Также благодаря REST веб-приложения стали лучше кооперироваться. За последние 10 лет число открытых API сильно увеличилось.
Когда веб-приложению нужна какая-то функциональность, можно найти подходящее API. Чтобы отправлять смс пользователям, мы просто подключим проект к сервису Twilio, не разбираясь в протоколах, на которых смс работают.
Скорость разработки продуктов сильно возросла. Эта простота и «общительность» серверов стала повсеместной во многом благодаря REST.
Понимание принципов создания API важно при проектировании бэкенда. Ведь API — это первое взаимодействие с сервером.
Но запрос к API обычно идёт дальше самогó сервера и, почти наверняка, требует работы с данными.`,
  },
  {
    title: `Дополнительные материалы`,
    subtitle1: `Открытые API`,
    text1: `Актуальный и постоянно пополняющийся список публичных API. Загляните в него, когда захочется отточить навык взаимодействия с API или сделать нечто странное. Например, API из списка позволяют реализовать систему рекомендаций аниме на основе погоды за окном.`,
    link: {
      uri: "https://github.com/public-apis/public-apis",
      text: `https://github.com/public-apis/public-apis`,
    },
    subtitle1: `CORS`,
    text2: `Статья о CORS. Также в ней описаны заголовки, которые можно разрешить во входящих кросс-доменных запросах.`,
    link: {
      uri: "https://developer.mozilla.org/ru/docs/Web/HTTP/CORS",
      text: `https://developer.mozilla.org/ru/docs/Web/HTTP/CORS`,
    },
  },
];
