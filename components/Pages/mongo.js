export const MONGO = [
  {
    title: `Введение. Зачем нужны базы данных?`,
    text: `Всё это время мы программировали сервер: создавали приложение, писали роутеры, мидлвэры, разбирались с обработкой запросов.
Всё сводилось к одному: клиент присылает запрос и получает ответ. Ответ — это что-то ценное для пользователя. И это представляет ценность, потому что содержит в себе информацию. Иными словами мы описывали алгоритмы для работы с данными.
Чтобы сервер мог отдавать клиенту данные, их нужно где-то хранить. Пока мы пользовались одним из двух вариантов:
Записывали данные в переменную. Пока сервер работает, всё хорошо, но стоит перезагрузить его, данные окажутся стёрты. Это не годится.
Хранили данные в файле. Но этот способ тоже так себе. Создал разработчик файл users.json и записал в него данные всех пользователей.
Клиент хочет получить доступ к своей учётной записи. Для этого нужно:
      прочитать файл;
      пройтись по массиву объектов;
      при каждой итерации сравнивать свойство _id с запрошенным.
Чем больше пользователей, тем больше нагрузка на серверный процессор. Поэтому всё будет работать медленно.
Для более сложных запросов описывать логику обращения к данным сложно и неудобно. И мы хотим выбрать пользователя по идентификатору.
Для этого нам нужно прочитать файл, пройтись по массиву объектов и, сравнивая _id с искомым, найти пользователя. Базы данных решают все эти проблемы. Это удобные структуры организации информации, которые позволяют быстро и безопасно работать с данными.`,
  },
  {
    title: `Какие бывают базы. SQL и NoSQL`,
    text1: `При работе с данными важна скорость и надёжность. Без баз данных этого не достичь. Но прежде, чем изучать прикладные инструменты, нужно понять общую логику организации данных. Сейчас есть два подхода: реляционные базы данных и нереляционные.`,
    subtitle1: `Реляционные БД`,
    text2: `Такие базы данных состоят из таблиц и связей между ними.
К Стасу Басову приходит бизнесмен Виталий Сергеевич и просит сделать интернет-магазин. Фронтенд Стас напишет быстро, но нужно  разобраться с организацией данных. Виталий Сергеевич просит: «Нужна возможность регистрации пользователей. Чтобы они потом историю  заказов могли посмотреть». Уже в этом требовании есть 3 сущности: товары, пользователи и заказы. Поможем Стасу их организовать в реляционную БД. При реляционном подходе данные собирают в таблице. Каждая сущность — строка в таблице. Поэтому нужно заранее определиться со структурой данных. Ведь столбцы для каждой сущности будут общими. Сложим в таблицу товары:`,
    image1: "image45.png",
    text3: `И пользователей:`,
    image2: "image46.png",
    text4: `Отлично. Теперь Стасу нужна ещё одна таблица — таблица заказов. Каждый заказ относится к какому-то пользователю и содержит один или несколько товаров. Нам не нужно хранить здесь информацию о каждом товаре и пользователе.
Достаточно указать идентификатор пользователя и идентификатор товара:`,
    image3: "image47.png",
    text4: `Чтобы составить список товаров и отрисовать его на стороне клиента, нужно сделать запрос к базе данных, который возьмёт имя каждого товара из таблицы «Товары» и сгруппирует данные по таблице «Заказы», взяв оттуда только товары нужного пользователя.
В этом и состоит суть реляционных баз данных. Информация организована в таблицы с предопределённой структурой. Мы можем добавить столбец, но тогда каждый элемент таблицы получит ещё один параметр. Мы можем получить информацию, которая нигде не содержится — список товаров с названиями. Для этого мы воспользуемся связями между таблицами.
Стас сдал проект, и Виталий Сергеевич доволен. Каждый пользователь, заходя на страницу «История заказов», делает запрос к базе.
Этот запрос собирает данные на ходу из разных таблиц и предоставляет их пользователю. У такого подхода есть свои плюсы и минусы. Данные разделены по разным таблицам. Каждая таблица содержит информацию только о тех сущностях, за которые отвечает. В таблице «Товары» есть всё о товарах и никакой информации о заказах или пользователях. Аналогично с таблицей «Пользователи».
Тем не менее таблиц может быть десятки и сотни. Чем больше таблиц нужно обойти запросу, тем больше производительности нужно серверу.
Мы можем поставить более мощный процессор и добавить оперативной памяти, но делать это бесконечно не выйдет. В какой-то момент мы упрёмся в потолок производительности. Эту проблему решают нереляционные базы данных.`,
    subtitle2: `Нереляционные БД`,
    text5: `Здесь вместо таблиц используют коллекции. Это нежёсткие структуры данных, которые состоят из документов. Обо всём по порядку.
К Стасу снова приходит Виталий Сергеевич и просит добавить функциональность скидок. Если пользователь совершил покупку, ему дают скидку на следующий товар. При реляционном подходе это было бы сделано так: при оформлении заказа к базе отправлялся бы запрос:
«Проверь, есть ли в таблице „Заказы“ вот такой идентификатор». Исходя из этого высчитывалась бы скидка.
В нереляционной БД подход другой. Ведь достаточно при заказе давать пользователю параметр, говорящий, что заказ уже был сделан.
Тогда дополнительного поиска по базе заказов проводить не нужно:`,
    code1: `{
  "id": "1234252",
  "name": "Внук Виталия Сергеевича",
  "madeOrder": true
},
{
  "id": "1208772",
  "name": "Стас Басов",
}`,
    text6: `Это документ, который хранит пользователей. Мы не привязаны к жёсткой структуре: у одного есть свойство "madeOrder", а другого — нет.
Тут Стас подумал и решил: «а переделаю всё в нереляционную БД!» Сначала он переписал таблицу с товарами в документ:`,
    code2: `// Документ с товарами
{
  "id": "19960"
  "name": "Волшебная палочка Гарри Поттера",
  "price": 10,
  "amount": 15
},
{
  "id": "79789",
  "name": "Автомобиль Delorean DMC-12",
  "price": 500,
  "amount": 7
},
{
  "id": "51339",
  "name": "Световой меч Люка Скайуокера",
  "price": 15,
  "amount": 3
},
{
  "id": "16307",
  "name": "Посох Гэндальфа",
  "price": 20,
  "amount": 2
}`,
    text7: `Затем то же сделал с таблицей пользователей:`,
    code3: `// Документ с пользователями
{
  "id": "85334",
  "name": "Вито Корлеоне",
  "age": 63
},
{
  "id": "48222",
  "name": "Николас Кейдж в роли Джона Траволты",
  "age": 55
},
{
  "id": "87130",
  "name": "Джон Траволта в роли Николаса Кейджа",
  "age": 65
},
{
  "id": "17185",
  "name": "Лягушонок Пепе",
  "age": 14
}`,
    text8: `Стасу осталось оформить таблицу с заказами. Тут и выявляется основное отличие реляционных баз данных от нереляционных.
В последних мы не будем делать запрос, который пойдёт в связанные таблицы, а просто соберём все нужные данные в одном месте:`,
    code4: `// Документ с заказами
{
  "id": "39439",
  "user": {
    "id": "48222",
    "name": "Николас Кейдж в роли Джона Траволты",
    "age": 55
  },
  "items": [
    {
      "id": "19960",
      "name": "Волшебная палочка Гарри Поттера",
      "price": 10,
      "amountOrdered": 2
    },
    {
      "id": "79789",
      "name": "Автомобиль Delorean DMC-12",
      "price": 500,
      "amountOrdered": 1
    },
    {
      "id": "51339",
      "name": "Световой меч Люка Скайуокера",
      "price": 15,
      "amountOrdered": 1
    }
  ]
},
{
  "id": "48241",
  "user": {
    "id": "17185",
    "name": "Лягушонок Пепе",
    "age": 14
  },
  "items": [
    {
      "id": "16307",
      "name": "Посох Гэндальфа",
      "price": 20,
      "amountOrdered": 1
    },
    {
      "id": "51339",
      "name": "Световой меч Люка Скайуокера",
      "price": 15,
      "amountOrdered": 1
    }
  ]
}`,
    text9: `Теперь не нужно собирать данные о заказах — нужно просто взять их из документа с товарами.
Плюс такого метода в скорости и простоте обработки запроса. Минус — в необходимости дублировать одни и те же данные.
Если пользователь изменит имя, придётся менять его и в документе с заказами.`,
    subtitle3: `Какую выбрать базу?`,
    text10: `Общего ответа на этот вопрос нет. Всё зависит от задачи, которую вы решаете. Реляционные БД сильно нагружают процессор и оперативную память сервера. Поэтому такие базы масштабируются вертикально, то есть заменой менее мощного сервера более мощным.
Нереляционные же можно масштабировать горизонтально, то есть добавлять новые серверы. На одном сервере можно разместить пользователей, на другом — заказы, на третьем — товары. Это делает базу данных практически неограниченно масштабируемой.`,
  },
  {
    title: `MongoDB`,
    text1: `В прошлом уроке мы говорили, что выбор подхода к организации данных зависит от задачи. Мы хорошенько подумали и выбрали NoSQL.`,
    subtitle1: `Почему NoSQL?`,
    text2: `Раньше аббревиатура NoSQL означала Not SQL (англ. «не SQL»). Позже подход вбирал некоторые свойство реляционного подхода, и теперь NoSQL расшифровывается как Not Only SQL (англ. «не только SQL»). Современные NoSQL базы данных комбинируют все плюсы
нереляционных и некоторые сильные стороны реляционных баз данных. Для проекта Mesto важны особенности нереляционного подхода.
Если Mesto станет конкурировать по популярности с Instagram, нам будет проще масшабировать свой продукт и выдерживать конкуренцию.
Кроме того, NoSQL базы хранят данные в структурах, близких JSON. Их просто обрабатывать из JavaScript, а значит, нужно меньше заморачиваться с преобразованием данных.`,
    subtitle2: `Почему MongoDB?`,
    text3: `Когда подход выбран, нужно определиться с базой данных. Вариантов много: RavenDB Cassandra, MongoDB, Redis, BigTable и другие.
Мы остановили свой выбор на MongoDB. Это самая распространённая NoSQL база данных среди прочих, да ещё и самая популярная среди БД, используемых с Node.js. Если в вакансии нужна Node.js, скорее всего нужна и MongoDB.`,
  },
  {
    title: `Установка Mongo`,
    text1: `Установите Mongo по инструкции для вашей ОС:`,
    subtitle1: `Windows`,
    text2: `Скачайте установщик`,
    image: "image48.png",
    link: {
      uri: "https://www.mongodb.com/download-center/community?jmp=docs",
      text: "Перейдите по ссылке",
    },
    textt3: `в выпадающем списке Version выберите 4.2.0 (current release);
      в выпадающем списке OS выберите Windows x64 X64;
      в выпадающем списке Package выберите MSI;
      нажмите Download.
Запустите установщик`,
    subtitle2: `Создайте директорию для базы данных`,
    text3: `Отройте Git Bash и перейдите в корень диска C:\ `,
    code1: `cd /C `,
    text4: `Создайте директорию для базы данных`,
    code2: `mkdir -p data/db`,
    text5: `На этом установка завершена.
Добавьте путь к папке bin в переменную окружения
Найдите путь к папке bin — в ней хранятся исполняемые файлы MongoDB. Обычно он выглядит как-то так:`,
    code3: {
      lang: "bash",
      value: `C:\\Program Files\\MongoDB\\Server\\4.2\\bin`,
    },
    text6: `В результатах поиска выберите «Изменение переменных среды текущего пользователя» или «Edit the System Environment Variables».
Откройте настройки переменных окружения. Нажмите клавишу win и начните вводить «перемен» ("env" для интерфейса на английском).
В верхнем окне выберите переменную Path и нажмите «Изменить...». В открывшемся окне нажмите «Создать», скопируйте путь к папке bin, сохраните результат и нажмите «Ок» во всех открытых окнах. Переменная окружения добавлена.`,
    link: {
      uri: "https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/#install-mdb-edition",
      text: "Или воспользуйтесь официальной инструкцией",
    },
    subtitle3: `macOS`,
    text7: `Mongo на macOS устанавливается из Homebrew — популярного пакетного менеджера macOS. Его нужно установить перед установкой Mongo.
Для этого запустите терминал и запускайте там все команды из инструкции. Если вы уже устанавливали Homebrew, сразу переходите к пункту 4.`,
    subtitle4: `Пошаговая инструкция`,
    text8: `1. Установите утилиты разработчика от Apple. Для этого в терминале запустите:`,
    code4: {
      lang: "bash",
      value: `xcode-select --install`,
    },
    text9: `2. Чтобы установить утилиты разработчика, терминал скачает большой файл. Поэтому установка займёт какое-то время — можете налить чаю.
Хорошая новость в том, что это придётся сделать один раз. Во время установки у вас попросят подтвердить лицензию на установку.
После того как команда выполнится, возможно, понадобится ещё раз подтвердить ещё одну лицензию на использование компонентов среды разработки XCode. Для этого запустите команду:`,
    code5: `sudo xcodebuild -license`,
    text10: `Теперь ваш компьютер готов к установке менеджера пакетов brew. Скопируйте эту команду в терминал и запустите:`,
    code6: `/usr/bin/ruby -e "$(curl -fsSL
https://raw.githubusercontent.com/Homebrew/install/master/install)"`,
    text11: `Пришло время установить Mongo. По очереди запустите эти команды:`,
    code7: `brew tap mongodb/brew
brew install mongodb-community@4.2`,
    link1: {
      uri: "https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/",
      text: "Или воспользуйтесь официальной инструкцией",
    },
    subtitle5: `Linux`,
    link2: {
      uri: "https://docs.mongodb.com/manual/administration/install-on-linux/",
      text: "Процесс установки описан в официальной инструкции.",
    },
  },
  {
    subtitle1: `Взаимодействие с Mongo`,
    text1: `Прежде чем приступить к уроку, запустите сервер MongoDB: откройте терминал (macOS и Linux) или Git Bash (Windows) и введите команду:`,
    code1: `mongod`,
    text2: `Если вы устанавливали Mongo на macOS через brew и команда mongod не запускает сервер, воспользуйтесь альтернативой.
Но обратите внимание на номер версии mongodb, она должна совпадать с установленной:`,
    code2: {
      lang: "bash",
      value: `brew services start mongodb-community@4.2`,
    },
    text3: `Сервер запущен. Можно налить чаю и приступать к чтению.`,
    title: `Как взаимодействовать с MongoDB`,
    text4: `Есть несколько способов. Мы расскажем о двух: графическом интерфейсе и через сервер на ноде.`,
    subtitle2: `Графический интерфейс`,
    text5: `Этот способ очень наглядный. Тут можно посматривать и редактировать базы данных и записи в них. От слов — к делу.
Если работаете на macOs или Linux, скачайте и установите Compass — графический интерфейс для MongoDB.
На Windows он уже установлен вместе с самой Mongo.`,
    link: {
      uri: "https://www.mongodb.com/download-center/compass",
      text: "Ссылка на установщик Compass",
    },
    text6: `Откройте Compass. Перед вами окажется такой экран:`,
    image1: "image49.png",
    text7: `Оставьте всё как есть и нажмите Connect: Compass подключится к MongoDB серверу.
Если этого не произошло, и появилась красное сообщение ошибки, проверьте, запущен ли MongoDB сервер.
Compass покажет созданные базы данных. Создадим ещё одну. Нажмите Create Database:`,
    image1: "image49.png",
    text8: `Введите имя новой БД (mydb) и первой коллекции в ней (users). Затем жмите Create Database:`,
    image2: "image50.png",
    text9: `Имя базы нечувствительно к регистру: userdb и UserDB — одна и та же база.
Чтобы не создавать конфликтующих имён, пользуйтесь только строчными буквами.
База данных состоит из коллекций, например: users, posts, comments. Ограничимся пока что одной — users.
Создайте в ней документ, нажав Insert Document:`,
    image3: "image51.png",
    text10: `Откроется окно создания нового документа. У него уже есть одно поле — _id:`,
    image4: "image52.png",
    text11: `Это уникальный идентификатор документа, MongoDB создаёт его сам. Добавьте ещё два поля: name и age.
В правом столбце можно выбрать тип данных, записанных в поле. Для age выберите числовой тип — Int32:`,
    image5: "image53.png",
    text12: `Затем нажмите Insert — и документ будет создан. Создайте ещё несколько:`,
    image6: "image54.png",
    text13: `Документы в коллекции можно фильтровать. Это помогает искать документы в базе.
Для этого просто напишите запрос в текстовом поле Filter. Запрос должен представлять собой объект:`,
    image7: "image55.png",
    text14: `Вот ещё несколько примеров запросов:`,
    code3: {
      lang: "javascript",
      value: `{} // найдёт все документы коллекции
{ name: 'Стас' } // найдёт документы, где поле name равно "Стас"
{ name: 'Стас', age: 34 } // найдёт документы, где поле name равно "Стас" и поле age равно 34`,
    },
    text15: `Искать документы через графический интерфейс очень удобно.
Но добавлять их таким способом приходится нечасто — обычно этим занимается сервер.
Для этого базу данных нужно связать с приложением на JavaScript.`,
    subtitle3: `Дополнительные Ссылки`,
    link1: {
      uri: "https://www.mongodb.com/download-center/compass",
      text: "Установщик Compass",
    },
    link2: {
      uri: "https://docs.mongodb.com/manual/tutorial/query-documents/",
      text: "Compass. Как писать запросы",
    },
    link3: {
      uri: "https://docs.mongodb.com/manual/mongo/#working-with-the-mongo-shell",
      text: "Mongo Shell. Документация",
    },
  },
  {
    title: `Подключение к mongo из JavaScript. Mongoose`,
    text1: `Мы рассказывали, как взаимодействовать с базой данных из графического интерфейса. Но документы в БД создаёт сервер, а не человек.
Нужно как-то «подружить» сервер и базу данных. Наш сервер запрограммирован на JavaScript, который не умеет работать с документами.
Зато в JS есть другие структуры данных — объекты. Наша задача: научить JavaScript работать с документами как с объектами.
Для этого существуют специальные инструменты — ODM или Object Document Mapper (англ. «сопоставитель объектов и документов»).
У каждой БД есть свой сопоставитель. У MongoDB он называется Mongoose и представляет собой мост между двумя мирами:
миром документов в базе данных и миром объектов JavaScript.`,
    subtitle1: `Устанавливаем Mongoose`,
    text2: `Это делается через npm. Откройте в терминале папку с проектом и запустите команду:`,
    code1: {
      lang: "bash",
      value: `npm i mongoose`,
    },
    text3: `Теперь его можно импортировать как модуль и пользоваться.`,
    subtitle2: `Подключаемся к серверу mongo`,
    text4: `Эту задачу выполняет метод mongoose.connect:`,
    code2: `// app.js — входной файл
const express = require('express');
const mongoose = require('mongoose');
const app = express();
// подключаемся к серверу mongo
mongoose.connect('mongodb://localhost:27017/mydb', {
  useNewUrlParser: true,
  useCreateIndex: true,
  useFindAndModify: false
});
// подключаем мидлвары, роуты и всё остальное...
app.listen(3000);`,
    text5: `Этот метод принимает на вход 2 параметра: адрес сервера базы данных и объект опций.
Адрес состоит из двух частей. Первая — mongodb://localhost:27017 — адрес сервера mongo по умолчанию.
Он запускается на localhost на 27017 порту. Вторая часть — mydb — имя базы данных.
У объекта опций может быть много свойств. Нам важны три:
    useNewUrlParser: true,
    useCreateIndex: true,
    useFindAndModify: false.
Мы не будет вдаваться в долгие объяснения, зачем нужны эти опции. Но если их не указать, у Mongoose в будущем возникнут проблемы совместимости с MongoDB. Дело в том, что логику взаимодействия MongoDB с Mongoose сейчас переписывают, и мы указываем эти опции, чтобы приложение вскоре не сломалось. Поэтому пропишите опции как у нас.`,
    subtitle3: `Запускаем сервер MongoDB`,
    text6: `Сервер mongo запускают командой mongod:`,
    code3: `mongod`,
    subtitle4: `Это нужно делать до запуска Node.js приложения. Иначе оно не сможет подключиться к базе данных и взаимодействовать с ней!`,
  },
  {
    title: `Схемы и модели`,
    text1: `Одна из особенностей нереляционных баз данных — отсутсвие схемы. Схема — набор требований к данным: сколько полей у записи, какой длины может быть значение каждого поля, какие в нём допустимы символы. Схема накладывает ограничения на данные, записанные в базу. Иногда это удобно, иногда нет. Современные NoSQL базы позволяют использовать схемы выборочно.
В MongoDB нет поддержки схем по умолчанию, но мы можем добавить их через Mongoose. Это нужно, чтобы проверять, соответствует ли документ схеме, прежде чем записывать его в БД. Фактически, мы сможем валидировать данные перед записью.`,
    subtitle1: `Создадим схему`,
    text2: `В REST API есть ресурсы — в проекте Mesto это пользователи и карточки. Каждый из ресурсов должен соответствовать задуманной структуре:
например, у пользователя должно быть имя и информация о себе. Зададим схему для пользователя через Mongoose:`,
    code1: `// models/user.js
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
name: { // у пользователя есть имя — опишем требования к имени в схеме:
  type: String, // имя — это строка
  required: true, // оно должно быть у каждого пользователя, так что имя — обязательное поле
  minlength: 2, // минимальная длина имени — 2 символа
  maxlength: 30, // а максимальная — 30 символов
},
gender: {
  type: String, // гендер — это строка
  enum: ['м', 'ж', 'другой'] // gender может принимать одно из трёх значений
},
about: String, // тип — String
});`,
    text3: `Такая схема говорит, что каждый пользователь в системе должен:
      обладать именем длиной от 2 до 30 символов;
      иметь гендер, который может принимать одно из трёх значений;
      иметь свойство about, причём строковое.
Иногда стандартных свойств схемы недостаточно. В Mongoose вы можете писать и более тонкие способы проверки данных.
Для этого существует свойство validate. Это объект, свойствами которого являются:
validator — функция валидации. Она должна возвращать булевое значение.
message — сообщение об ошибке. Срабатывает в том случае, если функция валидации возвращает false.
Посмотрим на примере. В схему пользователя добавим свойство age, значение которого не должно быть меньше 18:`,
    code2: `// models/user.js
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
  name: { // у пользователя есть имя — опишем требования к имени в схеме:
    type: String, // имя — это строка
    required: true, // оно должно быть у каждого пользователя, так что имя — обязательное поле
    minlength: 2, // минимальная длина имени — 2 символа
    maxlength: 30, // а максимальная — 30 символов
  },
  gender: {
    type: String, // гендер — это строка
    enum: ['м', 'ж', 'другой'] // gender может принимать одно из трёх значений
  },
  age: { // у пользователя есть возраст
    type: Number, // возраст - число
    validate: { // опишем свойство validate
    validator(v) { // validator - функция проверки данных. v - значение свойства age
    return v >= 18; // если возраст меньше 18, вернётся false
  },
  message: 'Вам должно быть больше 18 лет!', // когда validator вернёт false, будет использовано это сообщение
  }
},
about: String, // тип — String
});`,
    text4: `Это простая проверка. Более сложную проверку введённых данных можно сделать с помощью регулярных выражений.
Вернёмся к типам данных. При создании схем мы будем применять 5 основных типов данных:`,
    code2: `String // строка
Number // число
Date // дата
Boolean // логическое: true или false
Array // массив`,
    text6: `Если свойство документа должно быть объектом, придётся воспользоваться методом Schema дважды:
первый вызов нужен для создания схемы объекта: в нём мы описываем, какую структуру должно иметь свойство;
второй — для передачи описанной схемы в свойство, которое эту структуру должно иметь:`,
    code3: `// models/user.js
const mongoose = require('mongoose');
// создадим схему документа «Домашнее животное»
const petSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 30,
  },
  age: Number
});
// Когда схема готова, передадим её в свойство, которое должно соответствовать описанному шаблону:
const userSchema = new mongoose.Schema({
  ...
  pet: petSchema // опишем свойство pet этой схемой
});`,
    subtitle3: `Свойства-массивы`,
    text7: `Массивы нужны для хранения однотипных данных. Поэтому описание схемы массива сводится к описанию шаблона элемента:`,
    code4: `// models/user.js
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
  ...
  hobbies: [{ //описываем схему для одного элемента и заключаем её в квадратные скобки
    type: String,
    minlength: 2,
    maxlength: 30,
  }]
});`,
    text8: `Эта схема определяет свойство hobbies: оно должно содержать массив строк. Каждая — длиной от 2 до 30 символов.`,
    subtitle4: `Создание модели на основе схемы`,
    text9: `Схемой мы определили, каким должен быть документ в базе. Перейдём к следующему этапу — созданию самих документов.
Для этого на основе схемы строится модель. Модель — это «обёртка» из методов вокруг схемы. Благодаря ей мы можем читать, добавлять, удалять и обновлять документы. В Mongoose модель создают методом mongoose.model.`,
    code5: `// models/user.js
const mongoose = require('mongoose');
// Опишем схему:
const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 30,
  },
  about: String,
});
// создаём модель и экспортируем её
module.exports = mongoose.model('user', userSchema);`,
    text10: `Мы передали методу mongoose.model два аргумента: имя модели и схему, которая описывает будущие документы.
Аккуратно — тут можно запутаться. Первый аргумент — имя модели — должно быть существительным в единственном числе.
Но Compass отображает его во множественном. Дело в том, что Mongoose автоматически добавляет букву "s" в конце имени коллекции:`,
    image: "image57.png",
    subtitle5: `Создание моделей: резюме`,
    text11: `Определите ресурсы API.
      Опишите схемы этих ресурсов.
      Создайте модели на основе схем.
Когда модели готовы, можно их использовать для взаимодействия с базой: создавать, изменять и удалять документы в ней.`,
    subtitle6: `Дополнительные ссылки`,
    link: {
      uri: "https://mongoosejs.com/docs/schematypes.html",
      text: "Типы данных в схемах Mongoose",
    },
    link: {
      uri: "https://mongoosejs.com/docs/guide.html",
      text: "Больше про схемы",
    },
  },
  {
    title: `Создание, чтение, обновление и удаление документов`,
    text1: `Мы создали модель. Она нужна, чтобы взаимодействовать с соответствующей коллекцией документов.
Модель пользователя позволяет управлять коллекцией пользователей, модель карточек — коллекцией карточек.
С документом можно совершить одно из 4-х действий:
      создать (create),
      прочитать (read),
      обновить (update),
      удалить (delete).
Эти четыре действия обозначают аббревиатурой CRUD — по первым буквам английских названий.
Разберём наиболее распространённые методы для каждого из этих действий.`,
    subtitle1: `Создание документов — C`,
    text2: `За это отвечает метод модели create. Он принимает на вход объект с данными, которые нужно записать в базу:`,
    code1: `// routes/users.js
/*
всякий код для создания роутеров и т.п.
*/
// импортируем модель
const User = require('../models/user');
router.post('/', (req, res) => {
  const { name, about } = req.body; // получим из объекта запроса имя и описание пользователя
  User.create({ name, about }); // создадим документ на основе пришедших данных
});`,
    text3: `Метод create похож на промис — ему можно добавить обработчики then и catch. Так обычно и делают, чтобы вернуть клиенту данные или ошибку:`,
    code2: `// routes/users.js
/*
всякий код для создания роутеров и т.п.
*/
const User = require('../models/user');
router.post('/', (req, res) => {
  const { name, about } = req.body;
  User.create({ name, about });
// вернём записанные в базу данные
.then(user => res.send({ data: user }))
// данные не записались, вернём ошибку
.catch(err => res.status(500).send({ message: 'Произошла ошибка' }));
});`,
    subtitle2: `Чтение документов — R`,
    text4: `Прочитать документ — значит найти его и получить данные. Искать можно разными способами. Три самых популярных: findById, findOne и find.
Поиск конкретного документа. Метод findById ищет запись по идентификатору, то есть свойству _id, которое есть у каждого документа в MongoDB.
Поэтому чтобы найти конкретный документ, передайте методу findById идентификатор в строковом виде:`,
    code3: `// routes/users.js
/*
всякий код для создания роутеров и т.п.
*/
const User = require('../models/user');
router.get('/:id', (req, res) => {
  User.findById(req.params.id)
    .then(user => res.send({ data: user }))
    .catch(err => res.status(500).send({ message: 'Произошла ошибка' }));
});`,
    text5: `Поиск одного документа по параметрам. Метод findOne возвращает первый документ, соответствующий запросу:`,
    code4: {
      lang: "javascript",
      value: `// найти первое совпадение с полем name равным "Стас Басов"
User.findOne({ name: 'Стас Басов' });`,
    },
    text6: `Поиск всех документов по параметрам. Метод find работает так же, как findOne, но возвращает все документы по запросу:`,
    code5: {
      lang: "javascript",
      value: `// найти всех тридцатилетних
User.find({ age: 30 });
// найти вообще всех
User.find({});`,
    },
    subtitle3: `Обновление документов — U`,
    text7: `Тут всё очень похоже на чтение. При обновлении мы находим запись и меняем её свойства.
Обновление конкретной записи. Для этого есть метод findByIdAndUpdate, который принимает на вход идентификатор в строковом виде.
Вторым параметром ему передают объект со свойствами, которые нужно обновить:`,
    code6: `// routes/users.js
// ...
const User = require('../models/user');
router.patch('/:id', (req, res) => {
  // обновим имя найденного по _id пользователя
  User.findByIdAndUpdate(req.params.id, { name: 'Виктор Гусев' })
    .then(user => res.send({ data: user }))
    .catch(err => res.status(500).send({ message: 'Произошла ошибка' }));
});`,
    text8: `Можно найти первое совпадение с запросом и обновить его. Для этого есть метод findOneAndUpdate, который принимает на вход два объекта:
первый с параметрами поиска, второй — с данными, которые нужно обновить:`,
    code7: {
      lang: "javascript",
      value: `// найти первое совпадение с полем name равным "Стас Басов" и заменить имя на "Виктор Гусев"
User.findOneAndUpdate({ name: 'Стас Басов' }, { name: 'Виктор Гусев' }));`,
    },
    text9: `И аналогично можно превратить всех Стасов Басовых в Викторов Гусевых методом update:`,
    code8: {
      lang: "javascript",
      value: `// найти первое совпадение с полем name равным "Стас Басов" и заменить имя на "Виктор Гусев"
User.update({ name: 'Стас Басов' }, { name: 'Виктор Гусев' }));`,
    },
    text10: `Есть тонкость в работе методов обновления: по умолчанию параметр, который получает на вход обработчик then — это документ до обновления:`,
    code9: {
      lang: "javascript",
      value: `User.findByIdAndUpdate(req.params.id, { name: 'Виктор Гусев' })
  // user здесь — это документ до обновления
  .then(user => res.send({ data: user }))`,
    },
    text11: `Это можно исправить. Поэтому третьим аргументом методы обновления документов принимают объект опций. Нас интересуют три из них:`,
    backState: 'body-wrong_title-true',
    table: {
      title: ["ОПЦИЯ", "ЧТО ЗНАЧИТ", "ЗНАЧЕНИЕ ПО УМОЛЧАНИЮ"],
      td1: [`new`, "передать обновлённый объект на вход обработчику then", `ЛОЖЬ`],
      td2: [
        `runValidators`,
        "валидировать новые данные перед записью в базу",
        `ЛОЖЬ`,
      ],
      td3: [`upsert`, "если документ не найден, создать его", `ЛОЖЬ`],
    },
    text12: `Благодаря объекту опций мы можем передать в then уже обновлённую запись, и настроить валидацию и создать документ, если он не был найден:`,
    code10: {
      lang: "javascript",
      value: `User.findByIdAndUpdate(
  req.params.id,
  { name: 'Виктор Гусев' },
  // Передадим объект опций:
  {
    new: true, // обработчик then получит на вход обновлённую запись
    runValidators: true, // данные будут валидированы перед изменением
    upsert: true // если пользователь не найден, он будет создан
  }
)
  .then(user => res.send({ data: user }))
  .catch(user => res.send({"Данные не прошли валидацию. Либо произошло что-то совсем немыслимое"}));`,
    },
    subtitle4: `Удаление документов — D`,
    text13: `Удаление конкретной записи. Для этого есть метод findByIdAndRemove:`,
    code11: `// routes/users.js
// ...
const User = require('../models/user');
router.delete('/', (req, res) => {
  User.findByIdAndRemove(req.params.id)
    .then(user => res.send({ data: user }))
    .catch(err => res.status(500).send({ message: 'Произошла ошибка' }));
});`,
    text14: `Удаление первого совпадения. Этой цели служит findOneAndRemove:`,
    code12: {
      lang: "javascript",
      value: `// удалим пользователя на основе имени
User.findOneAndRemove({ name: 'Стас Басов' });`,
    },
    text15: `Удаление всех совпадений. Для этого вызывайте deleteMany:`,
    code13: {
      lang: "javascript",
      value: `// удалим всех тридцатилетних
User.deleteMany({ age: 30 });`,
    },
    subtitle5: `Ссылки`,
    text15: `Мы перечислили лишь основные методы, но у mongoose моделей методов очень много.`,
    link: {
      uri: "https://mongoosejs.com/docs/api/model.html",
      text: "Все их можно найти в официальной документации",
    },
  },
  {
    title: `Как структурировать код. Контроллеры`,
    text1: `Мы связали роуты с базой данных. Когда на роут приходит запрос, мы обращаемся к базе и возвращаем клиенту ответ:`,
    code1: `// routes/users.js
const User = require('../models/user');
router.post('/', (req, res) => {
  const { name, about } = req.body;
  // записываем данные в базу
  User.create({ name, about })
    // возвращаем записанные в базу данные пользователю
    .then(user => res.send({ data: user }))
    // если данные не записались, вернём ошибку
    .catch(err => res.status(500).send({ message: 'Произошла ошибка' }));
});`,
    text2: `Если роутов много, они теряются в коде. Для удобства работы разделим код на два файла: файл контроллеров и файл маршрутов.
Вынесем обработчики в отдельную папку controllers.`,
    code2: `// controllers/users.js
// это файл контроллеров
const User = require('../models/user');
module.exports.createUser = (req, res) => {
  const { name, about } = req.body;
  User.create({ name, about })
    .then(user => res.send({ data: user }))
    .catch(err => res.status(500).send({ message: 'Произошла ошибка' }));
});
// routes/users.js
// это файл маршрутов
const { createUser } = require('../controllers/users');
router.post('/', createUser);`,
    text3: `Контроллер — функция, ответственная за взаимодействие с моделью.
То есть это функция, которая выполняет создание, чтение, обновление или удаление документа.
Контроллер в express также называют «последней мидлвэрой». Потому что внутри неё мы не вызываем next, а возвращаем ответ пользователю.
Файл контроллеров описывает логику обработки запросов. А файл маршрутов определяет, при каком запросе эту логику применять.`,
  },
  {
    title: `Настраиваем связи`,
    text1: `Раньше NoSQL означала полностью нереляционный подход к созданию баз данных. Со временем нереляционные базы данных стали вбирать в себя некоторые сильные стороны реляционных. И одна из них — связи. Разберёмся как настроить связи между моделями в MongoDB.`,
    subtitle1: `1. Настраиваем связь двух схем`,
    text2: `Построение связи начинается со схемы. Представим приложение, в котором есть две сущности: юзеры и объявления. Вот схема юзера:`,
    code1: {
      lang: "javascript",
      value: `const userSchema = new mongoose.Schema({
  name: { // у пользователя есть только имя
    type: String,
    minlength: 2,
    maxlength: 20,
    required: true,
  },
});
module.exports = mongoose.model('user', userSchema);`,
    },
    text3: `Пользователи могут создавать объявления, которые описываются двумя полями: title и text — название объявления и его текст:`,
    code2: {
      lang: "javascript",
      value: `const adSchema = new mongoose.Schema({
  title: {
    type: String,
    minlength: 2,
    maxlength: 20,
    required: true,
  },
  text: {
    type: String,
    minlength: 2,
    required: true,
  },
});
module.exports = mongoose.model('ad', adSchema);`,
    },
    text4: `Но нужно как-то определять, кто автор каждого объявления. Поэтому объявлению необходимо ещё одно поле — создатель, назовём его creator.
В этом поле будем хранить ссылку на автора объявления. Лучшая ссылка из одного документа на другой — идентификатор.
Mongo автоматически создаёт поле _id — уникальный идентификатор для каждого документа. Этот идентификатор позволяет связать один документ с другим. Чтобы сделать это на уровне схемы, полю следует установить специальный тип — mongoose.Schema.Types.ObjectId и свойство ref. В это свойство записывают имя модели, на которую мы ссылаемся:`,
    code3: {
      lang: "javascript",
      value: `const adSchema = new mongoose.Schema({
  title: {
    type: String,
    minlength: 2,
    maxlength: 20,
    required: true,
  },
  text: {
    type: String,
    minlength: 2,
    required: true,
  },
  // создаём поле creator
  creator: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'user',
    required: true
  },
});`,
    },
    subtitle2: `2. При создании документа записываем _id`,
    text5: `В первом пункте мы создали модель, указав, что в поле creator должен быть идентификатор документа пользователя.
Теперь этот идентификатор нужно записывать в поле creator при создании нового объявления:`,
    code4: `// controllers/ads.js
const Ad = require('../models/ad');
module.exports.createAd = (req, res) => {
  const { title, text, creatorId } = req.body;
  Ad.create({ title, text, creator: creatorId })
    .populate('creator')
    .then(ad => res.send({ data: ad }));
};`,
    subtitle3: `3. Получаем всю информацию — метод populate`,
    text6: `Мы связали две модели. Тем не менее схема объявления хранит только идентификатор пользователя.
Чтобы получить всю информацию об авторе объявления, нужно вызвать метод populate, передав ему имя поля:`,
    code5: `// controllers/ads.js
const Ad = require('../models/ad');
module.exports.getAds = (req, res) => {
  Ad.find({})
    .populate('creator')
    .then(ad => res.send({ data: ad }));
};`,
    text7: `Чтобы отправить в ответе несколько полей, полученных из связей, методу populate следует передавать массив:`,
    code6: `// controllers/ads.js
const Ad = require('../models/ad');
module.exports.getAds = (req, res) => {
  Ad.find({})
    .populate(['creator', 'followers'])
    .then(ad => res.send({ data: ad }));
};`,
    subtitle4: `Ссылки`,
    link: {
      uri: "https://mongoosejs.com/docs/populate.html",
      text: "Более подробно про связи можно узнать в документации mongoose",
    },
  },
];
