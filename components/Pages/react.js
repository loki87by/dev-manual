export const REACT = [
  {
    subtitle: `Зачем нужны фреймворки`,
    text: `HTML, CSS и JavaScript — отличные инструменты для разработки простых веб-страниц. Однако, с увеличением сложности проекта обычно требуются более комплексные решения: библиотеки и фреймворки. Фреймворк — это каркас приложения, предоставляющий разработчику универсальную структуру будущего проекта, а также набор готовых решений для типовых задач. Первая основная задача — разбиение интерфейса на отдельные функциональные блоки (так называемые «компоненты»), которые можно переиспользовать. В качестве примера можно привести аватар с именем пользователя или кнопку лайка, которые могут встречаться в приложении много раз и в разных местах. Часто такие компоненты используют все три технологии: HTML, CSS и JavaScript. В этом случае удобно хранить их код рядом и отделить его от кода других компонентов. Многие фреймворки, включая «Реакт», предоставляют такую возможность. Другая важнейшая задача — динамическое обновление интерфейса. Классический (императивный) подход заключается для разработчика в описании последовательности изменений на HTML-странице  при наступлении каких-либо событий (например: «при клике на кнопку сделать её цвет синим»). «Реакт» позволяет использовать декларативный подход, при котором разработчику достаточно описать все возможные состояния интерфейса в любой момент времени (например: «если кнопка нажата, она должна быть синей»). Такой подход показал себя более гибким и надёжным в больших проектах.«Реакт» предлагает универсальные решения для обеих задач, описанных выше. При этом сама библиотека «Реакт» не является фреймворком в классическом понимании, так как не предоставляет  разработчику заранее заданную структуру проекта. Однако, на сегодняшний день вокруг «Реакта» сформировалась целая экосистема, включающая в себя дополнительные библиотеки и плагины, и даже методология, определяющая общепринятые подходы к разработке (паттерны), — в том числе относительно структуры приложений.`,
  },
  {
    title: `Компоненты`,
    text1: `Компоненты — это функциональные блоки, из которых состоит интерфейс. Они могут существовать в приложении как в единственном экземпляре, так и повторяться: например, с разным содержимым. Крупные компоненты могут состоять из других, более мелких компонентов, которые в конечном счёте состоят из простых HTML-элементов.`,
    image: "image6.png",
    text2: `На скриншоте выше выделены переиспользуемые компоненты. Блоки одного цвета имеют общую структуру, но разное содержимое. Мы можем описать общий для них HTML, CSS и JavaScript в одном  компоненте, присвоить ему имя и впоследствии просто «призывать» его в нужном месте, меняя лишь его содержимое. Разработчики «Реакта» пошли дальше: а что если сделать компонентами не только повторяющиеся, а вообще любые блоки в интерфейсе, отдельные страницы приложения и даже само приложение целиком? Такой процесс называется декомпозицией и позволяет более абстрактно и на разных уровнях управлять составными частями приложения. Разделение ответственности — одна из самых важных задач в программировании, и от её успешного решения зависит надёжность и масштабируемость системы. Почти как у Макиавелли: «Разделяй и властвуй». Сегодня большинство приложений на «Реакте» начинаются с главного компонента под названием App, который в свою очередь включает в себя все остальные компоненты. В итоге получается целая древовидная структура из вложенных друг в друга компонентов. Но как понять, должен ли тот или иной элемент интерфейса стать компонентом? Когда стоит разбивать один компонент на несколько более мелких? Однозначного ответа на эти вопросы нет, и обычно решение  остаётся на усмотрение разработчика. В целом здесь применимы общие правила: когда код компонента начинает разрастаться на несколько экранов в редакторе — время задуматься о декомпозиции.`,
  },
  {
    title: `Декларативный подход`,
    text1: `При императивном подходе разработчик описывает последовательность изменений, которые должны произойти с каждым элементом
интерфейса при наступлении определённых событий. Этот подход мы использовали раньше: брали HTML-элемент, подписывались на
какое-нибудь событие (например, click), задавали обработчик-колбэк, внутри которого уже производили манипуляции с этим или другими
элементами. Например, задавали содержимое через innerHTML, добавляли CSS-класс через classList, меняли стили через объект style и т.п.:`,
    code1: `const element = document.querySelector('#myElement');
element.addEventListener('click', () => {
  const element2 = document.querySelector('#myAnotherElement');
  element2.classList.add('active');
  const element3 = document.querySelector('#myText');
  element3.innerHTML = 'It was clicked!';
});`,
    code2: {
      lang: "html",
      value: `<div id="myElement">Click me!</div>
<div id="myAnotherElement">
  <div id="myText">
    Waiting for click...
  </div>
</div>`},
    text2: `Декларативный подход позволяет взглянуть на эту задачу под другим углом. Что, если при наступлении события мы будем просто менять
значение какой-то переменной, а для остальных элементов опишем различные состояния при всех возможных значениях этой переменной?`,
    code3: `const element = document.querySelector('#myElement');
let isClicked = false;
element.addEventListener('click', () => {
  isClicked = true;
});`,
    text3: `При этом предположим, что наш HTML мог бы зависеть от переменных в JavaScript:`,
    code4: {
      lang: "html",
      value: `<div id="myElement">Click me!</div>
<div id="myAnotherElement" className={isClicked ? 'active' : ''}>
  <div id="myText">
    {isClicked ? 'It was clicked!' : 'Waiting for click...'}
  </div>
</div>`},
    text4: `Такой подход позволяет сократить JavaScript-обработчик до одной строки. Но ещё более важно то, что с его помощью удаётся переместить все варианты текстового содержимого и CSS-классов туда, где описаны сами элементы: прямо в HTML-код. Таким образом мы разумно распределяем ответственность: JavaScript отвечает лишь за изменение текущего состояния приложения (той самой переменной), а HTML-элементы «сами» определяют (декларируют) то, как они будут выглядеть при разных его состояниях. Однако, в обычном HTML-коде подобные приёмы невозможны. Браузер не смог бы считать JavaScript-переменные, а фигурные скобки {} в нашем HTML он бы просто проигнорировал. Поэтому выше приведён пример не простого HTML, а так называемого JSX — специального языка шаблонов, проводящего «мост» между HTML и JavaScript. Декларативный подход оказывается невероятно полезным для поддержания порядка в крупных веб-проектах, а JSX стал одной из главных технологий, используемых в экосистеме «Реакта», и несомненным её преимуществом. В следующем уроке мы наконец подключим «Реакт» и остановимся на нём подробнее.`,
  },
  {
    title: `«Реакт» и JSX`,
    subtitle1: `Подключение «Реакта»`,
    text1: `Пришло время подключить «Реакт» и написать первый код с его использованием.
    Вот упрощённая версия примера с сайта «Реакта»:`,
    code1: `<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/jsx">
      ReactDOM.render((
        <h1>Hello, world!</h1>
      ), document.querySelector('#root'));
    </script>
  </body>
</html>`,
    subtitle2: `Разберём подробно, что здесь происходит.`,
    text2: `Работая с браузерными приложениями, мы всегда будем подключать сразу две библиотеки: основную и ту, что отвечает за работу с DOM.
На этапе разработки используются сборки с расширением .development.js: они содержат дополнительные инструменты для отладки кода на «Реакте». В первую очередь подключаем два скрипта: react и react-dom. Такое разделение существует, потому что основная библиотека react универсальна и предназначена не только для веб-проектов. JSX — «синтаксический сахар», поэтому следующим шагом мы подключаем «Бабель». Он занимается тем, что переводит JSX в стандартный синтаксис JavaScript, который может выполняться в любом браузере.
В одном из следующих уроков мы разберём, что на самом деле находится «под капотом» JSX, а пока просто укажем «Бабелю», какой код нужно транспилировать, добавив атрибут type="text/jsx" у тега script. Одна из основных функций в «Реакте» — ReactDOM.render. С неё начинается любой проект. Эта функция обрабатывает JSX и отрисовывает результат в DOM. Первым аргументом она принимает сам JSX-код, а вторым — указатель на DOM-элемент, в который необходимо вставить полученный результат.`,
    subtitle3: `Динамический интерфейс`,
    code2: `// Переменная, отвечающая за состояние приложения
let isClicked = false;
// Функция, отвечающая за отрисовку интерфейса
// с учётом текущего состояния isClicked
function renderAll() {
  ReactDOM.render((
    <div>
      <div id="myElement">Click me!</div>
      <div id="myAnotherElement" className={isClicked ? 'active' : ''}>
        <div id="myText">
          {isClicked ? 'It was clicked!' : 'Waiting for click...'}
        </div>
      </div>
    </div>
    ), document.querySelector('#root'));
}
// Вызов первичной отрисовки при открытии страницы
renderAll();
// При наступлении события мы изменяем переменную состояния
// и заново вызываем отрисовку
const element = document.querySelector('#myElement');
element.addEventListener('click', () => {
  isClicked = true;
renderAll();
});`,
    text3: `В этом примере мы добавили функцию renderAll, чтобы вызывать отрисовку «Реакта» не только при первом открытии страницы, но и повторно при любом изменении состояния приложения: например, после клика. Эта функция содержит в себе вызов функции ReactDOM.render, в которую передаётся JSX, зависящий от состояния переменной isClicked (а также, как и ранее, указатель на корневой HTML-элемент).`,
    subtitle4: `JSX`,
    text4: `Напомним, что JSX представляет из себя «симбиоз» HTML и JavaScript. Чтобы подставить значение из JavaScript в HTML используются фигурные скобки {}. Внутри них можно писать любые выражения на JavaScript, возвращающие строки и числа, которые будут подставлены в HTML.
Тернарный оператор ?: используется наиболее часто: он позволяет описать условную логику с двумя и более вариантами.`,
  },
  {
    title: `Синтаксис JSX: основы`,
    text1: `Синтаксис JSX — декларативный, а значит, он позволяет писать гибкие шаблоны и описывать все возможные состояния интерфейса.
Рассмотрим основные конструкции, которые используются в JSX.`,
    subtitle1: `Скобки`,
    text2: `HTML-подобный код перемешивается с «настоящим» JavaScript. Это затрудняет чтение:`,
    code1: `ReactDOM.render(
  <h2>
    Что я здесь делаю?
  </h2>,
  document.querySelector('#root')
  );`,
    text3: `Чтобы разделить код и вёрстку, рекомендуется обрамлять JSX в круглые скобки:`,
    code2: `ReactDOM.render((
  <h2>
    Можно я тут останусь?
  </h2>
), document.querySelector('#root'));`,
    subtitle2: `Условная логика`,
    text4: `Одна из самых частых задач в построении динамического интерфейса (да и вообще в программировании) — реализация условной логики.
В прошлом уроке мы уже приводили пример, когда структура интерфейса меняется в зависимости от значения JavaScript-переменной. В JSX внутри фигурных скобок можно писать любые JavaScript-выражения, поэтому мы можем использовать операторы ?: и &&.
Тернарный оператор ?: — сокращённый аналог if/else:`,
    code3: `ReactDOM.render((
  <div>
    {isDaylight ? (
      <h2>Добрый день!</h2>
    ) : (
      <h2>Спокойной ночи!</h2>
    )}
  </div>
), document.querySelector('#root'));`,
    text5: `Оператор && — аналог if, но без else — используется, если нужно отобразить часть JSX разметки только при определённом условии, а в противном случае не отображать ничего вообще:`,
    code4: `ReactDOM.render((
  <div>
    {isLunchTime && <h2>Время обеда!</h2>}
  </div>
), document.querySelector('#root'));`,
    text6: `Оба оператора могут содержать составные условия:`,
    code5: `ReactDOM.render((
  <div>
    {isThursday && wasRaining && <h2>Пора вернуть долг!</h2>}
  </div>
), document.querySelector('#root'));

ReactDOM.render((
  <div>
    {(isFrost && isSun) ? (
      <h2>День чудесный</h2>
    ) : (
      <h2>День обычный</h2>
    )}
  </div>
), document.querySelector('#root'));`,
    subtitle3: `Классовая борьба`,
    text7: `JSX очень похож на HTML, но в нём есть некоторые отличия, которые придётся запомнить. Начнём с того, что для задания CSS-класса используется атрибут className вместо class:`,
    code6: `ReactDOM.render((
  <div>
    <div className="proletariat">
      Шаг держи революционный!
      Близок враг неугомонный!
      Вперёд, вперёд, вперёд,
      Рабочий народ!
    </div>
    <div className="bourgeoisie">
      Ешь ананасы, рябчиков жуй,
      день твой последний приходит, буржуй.
    </div>
  </div>
), document.querySelector('#root'));`,
    subtitle4: `Стили`,
    text8: `Одна из «фич» JSX — возможность задавать значения style в виде JavaScript-объектов. При этом в названиях CSS-свойств вместо kebab-case используется camelCase:`,
    code7: `const cssRules = {
  width: 6792,
  height: 6752,
  borderRadius: '50%',
  background: '#934838',
  color: 'black',
};
ReactDOM.render((
  <div style={cssRules}>Какая я планета?</div>
), document.querySelector('#root'));`,
    text9: `Значение можно задать сразу (без промежуточной переменной). Для этого используются двойные фигурные скобки {{..}} — внешние означают подстановку значения, а внутренние объект, описывающему набор стилей:`,
    code8: {
      lang: "javascript",
      value: `ReactDOM.render((
  <div style={{
    width: 3475,
    height: 3472,
    borderRadius: '50%',
    background: '#d0d5d2',
    color: '#444444',
  }}>
    Я тоже хочу быть планетой!
  </div>
), document.querySelector('#root'));`},
    text10: `Ещё один плюс: можно не указывать размерность для значений в пикселях — «Реакт» сделает это сам.`,
    subtitle5: `Фрагменты`,
    text11: `Иногда в JSX используется «безымянный» тег <>...</>:`,
    code9: `ReactDOM.render((
  <>
    <div id="myElement">Click me!</div>
    <div id="myAnotherElement">It was clicked!</div>
  </>
), document.querySelector('#root'));`,
    text12: `Это так называемый «фрагмент» в «Реакте».
Дело в том, что блок JSX-кода по правилам должен содержать только один элемент верхнего уровня. В примере выше используются сразу два элемента, находящиеся рядом: #myElement и #myAnotherElement. Чтобы JSX-код правильно работал, мы «оборачиваем» их во фрагмент.
Фрагменты не обладают дополнительной функциональностью и могут восприниматься как своеобразные «обрамляющие скобки» в JSX-коде.
Вместо них можно было бы использовать обычный <div>, но это создаст лишние элементы в DOM — напрасная трата ресурсов и может вызывать дополнительные сложности с вёрсткой.`,
    subtitle6: `Самозакрывающиеся теги`,
    text12: `Любой открывающий тег должен иметь свою пару — закрывающий тег. Если у элемента нет внутреннего содержимого, то тег должен быть самозакрывающимся. Для этого ставят слеш / перед его закрывающей скобкой:`,
    code10: `<img src="logo/png" />`,
  },
  {
    title: `Синтаксис JSX: списки и события`,
    subtitle1: `Списки`,
    text1: `Существует ещё одна частая задача — описание разметки для элементов списка. Под списком в данном случае подразумеваются любые однотипные данные, повторяющиеся более одного раза: меню сайта, список пользователей, галерея изображений и т.п.
Например, в ленте сообщений чата, написанного на «Реакте», нужен только массив с данными и код JSX, который описывает разметку одного сообщения, а затем использует цикл, чтобы вывести полный результат.
Предположим, что с сервера мы получаем такой массив с данными о комментариях:`,
    code1: {
      lang: "javascript",
      value: `const comments = [{
  id: 1,
  author: 'Лиза',
  text: 'Все уже сдали деньги на субботник?',
  }, {
  id: 2,
  author: 'Джеймс',
  text: 'Никто не видел мой сэндвич?',
  }, {
  id: 3,
  author: 'Грег',
  text: 'Продам мопед',
}];`},
    text2: `Опишем разметку стандартного сообщения:`,
    code2: {
      lang: "xml",
      value: `<div>
  <h3>{message.author}</h3>
  <div>{message.text}</div>
</div>`},
    text3: `Но как передать нужные значения определённого объекта массива comments в разметку? Для этого и нужен цикл.
Циклы в JSX реализуются методом map массива. При этом каждому внешнему JSX-элементу, создаваемому в цикле, необходимо задать уникальный ключ, для этого используют атрибут key.`,
    code3: `ReactDOM.render((
  <div>
    <h2>Сообщения</h2>
    {comments.map((message, i) => (
      // Важный атрибут: key
      <div key={message.id}>
        <h3>{message.author}</h3>
        <div>{message.text}</div>
      </div>
    ))}
  </div>
), document.querySelector('#root'));`,
    text4: `Правила «Реакта» всегда требуют задавать ключи при работе со списками. Если этого не сделать, в консоли появится соответствующая ошибка.
Он нужен для корректной работы движка. Здесь мы используем уже имеющийся у нас уникальный идентификатор — message.id.
Использовать идентификаторы в качестве ключа очень удобно, так как обычно они есть у всех данных, которые возвращает API. Если такого идентификатора в данных нет, можно использовать индексы элементов (второй аргумент метода map), но только если есть абсолютная уверенность в том, что порядок элементов никогда не меняется:`,
    code4: `ReactDOM.render((
  <div>
    <h2>Сообщения</h2>
    {comments.map((message, i) => (
      // Важный атрибут: key
      <div key={i}>
        <h3>{message.author}</h3>
        <div>{message.text}</div>
      </div>
    ))}
  </div>
), document.querySelector('#root'));`,
    text5: `Подробнее изучим списки уже в следующем спринте, но если вы хотите скорее ознакомиться с принципами их работы, вот статья из документации.`,
    subtitle2: `Обработчики событий`,
    text6: `Вы уже умеете добавлять обработчики событий с помощью addEventListener. Кроме того, в обычном HTML есть специальные атрибуты событий onclick, onmouseenter и другие. В JSX тоже есть такие атрибуты, только выглядят они немного по-другому:`,
    code5: `function handleClick() {
  console.log('Не дави на меня!');
}
function handleMouseEnter() {
  console.log('Ты мне солнце заслонил!');
}
function handleMouseLeave() {
  console.log('Ну ты чего, нормально же общались!');
}
ReactDOM.render((
  <button
    onClick={handleClick}
    onMouseEnter={handleMouseEnter}
    onMouseLeave={handleMouseLeave}
  >
    Поиграй со мной!
  </button>
), document.querySelector('#root'));`,
    text7: `В примере выше значения атрибутов onClick, onMouseEnter и onMouseLeave указывают на JavaScript-функции, которые должны находиться в области видимости. Полный список поддерживаемых событий можно посмотреть в документации «Реакта».`,
  },
  {
    title: `Функциональные компоненты`,
    subtitle1: `Компоненты в JSX`,
    text1: `Разделение кода на компоненты — одна из главных возможностей, которую предоставляет «Реакт».
Ранее мы приводили пример компонента: аватар с именем пользователя. Такой блок может встречаться в приложении много раз и отображать информацию о разных пользователях. У каждого компонента должно быть своё имя, и в React принято называть компоненты с заглавной буквы.
Предположим, что мы дали нашему первому компоненту имя User. Вот как будет выглядеть JSX-код, использующий этот компонент:`,
    code1: `ReactDOM.render((
  <>
    <h2>Мои воображаемые друзья:</h2>
    <User id="1" name="Gregory" />
    <User id="2" name="James" />
    <User id="3" name="Allison" />
  </>
), document.querySelector('#root'));`,
    text2: `Компоненты, как и обычные HTML-элементы, могут иметь атрибуты. Атрибуты компонентов в React называются «пропсы» (англ. props, сокращение от properties, «свойства»).`,
    subtitle2: `Создание функционального компонента`,
    text3: `Как же создать компонент в «Реакте»? Для этого существует несколько способов, и один из них… обыкновенная функция. Действительно, компоненты в «Реакте» можно создавать в виде обычной JavaScript-функции. Такая функция-компонент принимает единственный аргумент — объект props — и возвращает структуру компонента в JSX:`,
    code2: `// Компонент User
function User(props) {
  return (
    <p>
      <img src={\`https://code.s3.yandex.net/web-code/react/\${props.id}.png\`} width="75" />
      <br /><b>{props.name}</b>
    </p>
  );
}
// Основной код приложения
ReactDOM.render((
  <>
    <h2>Мои воображаемые друзья:</h2>
    <User id="1" name="Gregory" />
    <User id="2" name="James" />
    <User id="3" name="Allison" />
  </>
), document.querySelector('#root'));`,
    text4: `Этот пример уже работает — его можно запустить в браузере.
При отрисовке страницы компонент User будет вызван трижды — с разными пропсами, заданными в основном коде приложения. Каждый раз, когда отрисовка вызывается повторно (в примере из предыдущего урока это происходило после клика), каждая функция-компонент будет вызвана снова. В примере выше это не принципиально, т.к. функция User всегда возвращает одно и то же (в зависимости от пропсов), однако более сложные компоненты могут менять своё содержимое между отрисовками, а также могут меняться передаваемые им «сверху» пропсы.`,
  },
  {
    title: `Классовые компоненты`,
    text1: `В прошлом уроке мы научились создавать функциональные компоненты. Есть в «Реакте» и альтернативный способ создания компонентов: с помощью ООП-классов. Исторически он появился раньше, и большинство существующих проектов используют именно его.`,
    subtitle1: `Создание классового компонента`,
    text2: `Для этого используется синтаксис class MyComponent extends React.Component, где MyComponent — имя создаваемого компонента.
Это наследование от встроенного в «Реакт» класса Component, который предоставляет дополнительную функциональность для компонентов.
Перепишем компонент User с использованием класса:`,
    code1: `// Функциональный компонент User
function User(props) {
  return (
    <p>
      <img src={\`https://code.s3.yandex.net/web-code/react/\${props.id}.png\`} width="75" />
      <br /><b>{props.name}</b>
    </p>
  );
}
// Классовый компонент User
class User extends React.Component {
  render() {
    return (
      <p>
        <img src={\`https://code.s3.yandex.net/web-code/react/\${this.props.id}.png\`} width="75" />
        <br /><b>{this.props.name}</b>
      </p>
    );
  }
}`,
    text3: `Как видно, изменилось не так много:
Появился класс User, который наследуется от встроенного в «Реакт» класса React.Component.
Содержимое компонента-функции (function User) переместилось внутрь метода render, принадлежащего этому новому классу.
props — это теперь не аргумент функции, а поле экземпляра класса, доступ к которому осуществляется с помощью ключевого слова this.
Что же даёт подобное изменение? Дело в том, что у встроенного класса React.Component есть свои свойства и методы для решения специфичных задач — подобно встроенным методам в обычном JavaScript.
С помощью наследования разработчик получает к ним доступ.`,
    subtitle2: `Внутреннее состояние компонента`,
    text4: `Часто внутри компонента необходимо хранить данные, которые меняются в течение «жизни» этого компонента. Эти данные не приходят извне в виде пропсов, а создаются и меняются прямо внутри самого компонента. Пример таких данных для нашего компонента — счётчик рейтинга.
Допустим, мы хотим, чтобы у наших пользователей была возможность голосовать за репутацию, ставя лайки или дизлайки друг другу.
Для этого будем использовать поле state и метод setState экземпляра классового компонента.`,
    code2: `// Классовый компонент User
class User extends React.Component {
  constructor(props) {
    super(props);
    // Начальные значения внутреннего состояния
    this.state = {
      rating: 0,
    };
  }
  /*
  * Обработчики событий: изменяют внутреннее состояние
  */
  handleLike = () => {
    this.setState({ rating: 1 });
  };
  handleDislike = () => {
    this.setState({ rating: -1 });
  };
  // JSX-структура компонента
  render() {
    return (
      <p>
      <img src={\`https://code.s3.yandex.net/web-code/react/\${this.props.id}.png\`} width="75" />
      <br /><b>{this.props.name}</b>
      <div className="rating">
        <button onClick={this.handleLike}>👍</button>
          {this.state.rating}
        <button onClick={this.handleDislike}>👎</button>
      </div>
      </p>
    );
  }
}
// Основной код приложения
ReactDOM.render((
  <>
    <h2>Мои воображаемые друзья:</h2>
    <User id="1" name="Gregory" />
    <User id="2" name="James" />
    <User id="3" name="Allison" />
  </>
), document.querySelector('#root'));`,
    text5: `Попробуйте запустить этот код в браузере, и разберём по порядку, что здесь происходит. Во-первых, мы добавили метод constructor.
Именно этот метод вызывается при самой первой отрисовке, когда «Реакт» создаёт экземпляр нашего компонента:`,
    code3: `constructor(props) {
  super(props);
  // Начальные значения внутреннего состояния
  this.state = {
    rating: 0,
  };
}`,
    text6: `В этот метод попадают первые значения пропсов, а наша задача прокинуть их выше — в конструктор родительского класса — с помощью ключевого слова super. Именно там из них будет создан объект this.props. Далее мы объявляем объект внутреннего состояния this.state, а также задаём для него начальные значения. Единственное поле, которое мы в него добавили — rating — отвечает за текущий рейтинг пользователя.
Его начальное значение (при открытии страницы) равно 0. Во-вторых, мы объявили два метода-обработчика событий кликов для кнопок 👍 и 👎.
Внутри себя они вызывают метод this.setState из родительского класса, которой выполняет две функции: изменяет значение состояния this.state и оповещает движок «Реакта» о том, что внутреннее состояние компонента изменилось, а следовательно его необходимо перерисовать:`,
    code4: `/*
* Обработчики событий: изменяют внутреннее состояние
*/
handleLike = () => {
  this.setState({ rating: 1 });
};
handleDislike = () => {
  this.setState({ rating: -1 });
};`,
    text7: `В результате при клике на одну из этих кнопок «Реакт» повторно вызовет метод render (уже с обновлённым значением this.state) и, определив изменения в JSX, внесёт необходимые обновления в DOM. Помните, раньше мы вручную вызывали renderAll при клике, чтобы вызвать перерисовку «Реактом»? Метод setState делает это за нас. Следует обратить внимание на то, что методы-обработчики handleLike и handleDislike объявлены не в виде обычных методов класса (как, например, метод constructor), а в виде полей, которым присваиваются стрелочные функции.
Это позволяет им не потерять контекст this при использовании в качестве обработчиков событий.
В-третьих, мы добавили новый элемент .rating в JSX, содержащий текущее значение счётчика и две кнопки для его изменения:`,
    code5: `<div className="rating">
  <button onClick={this.handleLike}>👍</button>
    {this.state.rating}
  <button onClick={this.handleDislike}>👎</button>
</div>`,
    text8: `В качестве бонуса можно воспользоваться изящностью JSX и слегка улучшить наш компонент: запретить нажимать на одну и ту же кнопку несколько раз подряд. В нашем приложении это ни к чему не приводит, поэтому с точки зрения интерфейса лучше, если после клика кнопка будет становиться неактивной. Это довольно легко сделать с помощью динамического значения для атрибута disabled:`,
    code6: {
      lang: "xml",
      value: `<div className="rating">
  <button onClick={this.handleLike} disabled={this.state.rating > 0}>👍</button>
    {this.state.rating}
  <button onClick={this.handleDislike} disabled={this.state.rating < 0}>👎</button>
</div>`},
  },
  {
    title: `Жизненный цикл классовых компонентов`,
    text1: `Продолжим изучать встроенные методы класса React.Component. В этом уроке расскажем о методах, которые позволяют управлять «жизненным циклом» (англ. lifecycle) классовых компонентов и тем самым лучше контролировать их поведение. Например, выполнить определённый код в заранее заданный момент. Каждый компонент в течение своего жизненного цикла может быть монтирован (англ. mount), обновлён (англ. update) и размонтирован (англ. unmount). Монтирование происходит, когда HTML-дерево компонента вставляется движком «Реакта» в DOM.
Обновление происходит в одном из трёх случаев:
    если произошёл рендер родительского компонента,
    если изменилось внутреннее состояние в результате вызова this.setState,
    если обновление было инициировано вызовом встроенного метода this.forceUpdate.
Размонтирование происходит, когда HTML-дерево компонента удаляется из DOM.
Каждому из этих событий соответствует один из трёх методов жизненного цикла: componentDidMount, componentDidUpdate и componentWillUnmount.
Как и метод render, это методы обратного вызова: в отличие от setState вы никогда не будете вызывать их вручную, однако вы будете описывать их внутри своих компонентов, чтобы в нужный момент они были вызваны изнутри самого движка «Реакта» — как колбэки.
Наглядная диаграмма жизненного цикла (интерактивный вариант тут):`,
    image1: "image7.png",
    text2: `Чаще всего методы жизненного цикла используются для описания так называемых «побочных эффектов» (англ. side effects). В процессе «жизнедеятельности» компонент помимо непосредственно отрисовки может взаимодействовать с различными API, подписываться на глобальные события, обращаться к серверу за данными и т.д. Именно это принято называть его побочными эффектами или просто эффектами. Предположим, что мы хотим сделать приложение, в котором будет доступен режим кастомизированного курсора: с помощью чекбокса на страницу будет добавляться компонент с картинкой, следующей за движениями мыши. Нам понадобятся два компонента: корневой компонент App с чекбоксом и находящийся внутри него компонент NeonCursor, который будет монтироваться, только когда чекбокс отмечен.
Сперва опишем компонент App.`,
    code1: `// Корневой компонент приложения
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isCustomCursor: false };
  }
  handleChange = () => {
    this.setState({
      isCustomCursor: !this.state.isCustomCursor,
    });
  };
  render() {
    return (
      <>
        <label>
          <input type="checkbox" onChange={this.handleChange} />
          — Включить неоновый курсор
        </label>
        {this.state.isCustomCursor && <NeonCursor />}
      </>
    );
  }
}`,
    text3: `Самое интересное происходит в этой строчке:`,
    code2: `{this.state.isCustomCursor && <NeonCursor />}`,
    text4: `Здесь мы используем оператор && для создания условной логики: компонент NeonCursor будет включён в структуру JSX только тогда, когда условие перед оператором (this.state.isCustomCursor) истинно. Изначально значение этого поля равно false, но когда пользователь установит галочку чекбокса, будет вызван метод this.setState, который его изменит. Это приведёт к монтированию компонента NeonCursor.
Если пользователь снимет галочку, условие снова изменится и компонент будет удалён из дерева JSX и, соответственно, из DOM.
Теперь опишем сам компонент NeonCursor.`,
code3: `// Компонент, отвечающий за кастомизированный курсор
class NeonCursor extends React.Component {
  constructor(props) {
    super(props);
    this.state = { top: 0, left: 0 };
  }
  // Метод будет вызван сразу после монтирования: создаём эффекты
  componentDidMount() {
    document.addEventListener('mousemove', this.handleMouseMove);
    document.documentElement.classList.add('no-cursor');
  }
  // Метод будет вызван непосредственно перед размонтированием: удаляем эффекты
  componentWillUnmount() {
    document.documentElement.classList.remove('no-cursor');
    document.removeEventListener('mousemove', this.handleMouseMove);
  }
  handleMouseMove = (event) => {
    this.setState({
      top: event.pageY,
      left: event.pageX,
    });
  };
  render() {
    return (
      <img
        src="./cursor.png"
        width="30"
        style={{
          position: 'absolute',
          top: this.state.top,
          left: this.state.left,
          pointerEvents: 'none',
        }}
      />
    );
  }
}`,
    text5: `В этом компоненте описаны два метода его жизненного цикла. Метод componentDidMount будет вызван как только компонент монтируется в DOM: в нём мы подписываемся на событие mousemove документа, а также добавляем документу CSS-класс, отключающий стандартный курсор на всех элементах страницы. Кстати, этот класс выглядит так:`,
    code4: `/* Элемент с классом no-cursor и все вложенные в него элементы */
.no-cursor, .no-cursor * { cursor: none; }`,
    text6: `Когда пользователь снимет галочку чекбокса, наш компонент размонтируется, и нам очень важно «подчистить» (англ. cleanup) произведённые им эффекты: удалить слушатель mousemove и снять с документа CSS-класс, чтобы снова включился стандартный курсор. Эти действия мы производим в методе componentWillUnmount. В этом методе команды вызываются в обратном порядке по отношению к методу componentDidMount — это стандартная практика, именуемая принципом «шнурков и ботинок». Мы всегда сперва надеваем ботинки, а затем завязываем шнурки; когда же мы собираемся их снять, всё должно происходить наоборот.
Благодаря подписке на событие mousemove каждое движение курсора вызывает метод handleMouseMove, который обновляет внутреннее состояние компонента с помощью this.setState, что влечёт за собой  вызов render с новыми значениями и приводит к обновлению DOM: элемент <img> получает новые координаты и перемещается по экрану. Вся логика готова. Добавим компонент приложения на страницу:`,
    code5: `ReactDOM.render(<App />, document.querySelector('#root'));`,
  },
  {
    title: `Virtual DOM`,
    text1: `В предыдущих примерах мы всё время приводили JSX в качестве основного «строительного материала» для «Реакта». На самом деле JSX — лишь «синтаксический сахар», за которым скрываются вызовы одной единственной, но очень важной функции в «Реакте». Это функция React.createElement, и с помощью неё в «Реакте» создаются виртуальные узлы (англ. virtual nodes). В самом начале мы подключали «Бабель» — как раз, чтобы трансформировать JSX во множество вызовов React.createElement. Кстати, в онлайн-версии «Бабеля» можно наглядно увидеть, как происходят такие трансформации — просто введите исходный код, и результат сразу появится в правом окне.`,
    code1: {
      lang: "xml",
      value: `// JSX-код
<div
  className="pink jumbo"
  onClick={() => console.log('click!')}
>
  розовый <b>слон</b>
</div>`},
code2: `// Код после транспиляции
React.createElement(
  // Имя тега или компонента
  'div',
  // Атрибуты или пропсы
  {
    className: 'pink jumbo',
    onClick: () => console.log('click!')
  },
  // Первый дочерний узел (строка)
  'розовый ',
  // Второй дочерний узел (ещё один элемент)
  React.createElement(
    'b',
    null,
    'слон'
  )
);`,
    text2: `Каждый элемент в JSX трансформируется в один вызов React.createElement. Эта функция принимает два основных аргумента: имя тега или указатель на компонент, а также объект, содержащий все атрибуты и пропсы. Последующие аргументы (их число неограниченно) перечисляют все непосредственные дочерние узлы. Чаще всего среди дочерних узлов находятся:
    другие вызовы React.createElement;
    строки текста;
JavaScript-выражения, возвращающие что-то из вышеперечисленного или «пустой» узел (это может быть null, undefined или false).
В результате вызова функции React.createElement внутри движка «Реакта» создаётся «Реакт»-элемент — главная молекула «организма „Реакта“»:
JavaScript-объект, содержащий данные, которые были переданы в функцию. В упрощённом виде структура этого элемента выглядит так:`,
    code3: {
      lang: "javascript",
      value: `{
  type: 'div',
  props: {
    className: 'pink jumbo',
    onClick: () => console.log('click!'),
    children: [
      'Розовый',
      {
        type: 'b',
        children: ['слон']
      }
    ],
  },
}`},
    text3: `Обратите внимание, что объект children является частью объекта props. В дальнейшем нам это пригодится, когда мы будем работать с компонентами, в которых часть содержимого не только описывается В конечном итоге формируется древовидная структура объектов, где один корневой объект ссылается на несколько дочерних через своё поле children и так далее. Именно эта структура затем передаётся в функцию ReactDOM.render, где происходит самое интересное. «Реакт» использует эту структуру данных для двух целей.
Во-первых, на её основе строятся и вставляются на страницу реальные DOM-элементы (с помощью document.createElement и appendChild), а также вызывается рендер компонентов. В результате рендера компонентов эта структура, а с ней и реальный DOM, «обрастают» дополнительными ветвями, структура которых была описана в компонентах.
Во-вторых, «Реакт» использует эти данные для хранения виртуального DOM (англ. Virtual DOM) — виртуальной копии текущей структуры DOM.
При последующих рендерах обновлённая структура поэлементно сравнивается с последней сохранённой копией, что позволяет «Реакту» определить минимальное необходимое количество изменений и применить эти изменения в реальном DOM. Это необходимо, потому что почти любые операции с DOM — узкое место в JavaScript. Алгоритм «Реакта», который называется “reconciliation” (англ. «согласование»), сводит количество этих операций к минимуму.  Сравнение двух даже сложных JavaScript-объектов во много раз быстрее, чем аналогичные операции над DOM-деревом. Это позволяет «Реакту» сохранить высокую скорость работы в приложениях с большим количеством меняющихся данных.`,
  },
  {
    title: `Знакомство с Create React App`,
    text1: `Немного пофантазируем. Представьте, что вы задумались о новом увлечении и решили построить миниатюрный городок с железной дорогой.
Начинание серьёзное: вы тщательно выбираете подходящие краски и материалы, аккуратно раскрашиваете детали и бережно склеиваете их вместе. Когда отдельные конструкции готовы, можно приступать к прокладке рельсов и сборке. Уже не терпится запустить готовый поезд и показать городок друзьям. Новое занятие приносит массу веселья, и однажды вы задумываетесь: это может понравиться людям. Из этого можно сделать бизнес! Клиент бы описывал город своей мечты, показывал эскизы или фотореференсы, а вы бы воплощали всё это в реальность.
Но вот незадача: первый проект потребовал целых две недели. Собирать всё вручную с нуля просто нерентабельно. Чтобы сэкономить время, вы решаете использовать заранее собранные компоненты: дома, деревья, лавочки и так далее. Вам останется лишь покрасить их и разместить в соответствии с требованиями заказчика. Вы отказались от более тонкого уровня контроля в пользу эффективности.`,
    subtitle1: `Зачем использовать Create React App`,
    text2: `Использование заранее собранных моделей сэкономило бы много времени бизнесу по производству миниатюрных городов. Так и в программировании, утилита Create React App (CRA) помогает разработчикам писать код быстрее и эффективнее.
Как и «Реакт», она разработана командой Facebook. CRA позволяет быстро собрать и запустить проект, создав его на основе стандартного шаблона, не беспокоясь о детальной настройке.`,
    subtitle2: `Основные причины применять CRA:`,
    text3: `Одной командой можно развернуть полноценный рабочий проект.
Проект уже содержит удобную файловую структуру, стандартную для большинства проектов на «Реакте».
В проект легко подключить статические ресурсы: изображения, шрифты и так далее.
Есть готовый механизм для тестирования компонентов.
Проект будет автоматически обновляться в браузере при внесении изменений.
Настроена оптимизация продакшн-сборки.
Можно использовать NPM и легко устанавливать пакеты.
Есть и особое преимущество, о котором поговорим отдельно. Вспомним пример из предыдущей темы. Весь наш новый код на «Реакте» был написан внутри одного тега script:`,
    code1: `<script type="text/jsx">
  class Switch extends React.Component {
    // Конструктор компонента Switch, обработчик и функция render
  }
  ReactDOM.render((
    <>
      <Switch title="Счастье" color="blue" isActive={true} />
      <Switch title="Любовь" color="orange" isActive={false} />
      <Switch title="Шаурма" color="green" isActive={false} />
    </>
  ), document.querySelector('#root'));
</script>`,
    text3: `Если продолжать писать код подобным образом, файлы станут большими, а их содержимое — трудным для восприятия. Но есть современное решение этой проблемы, с которым вы уже знакомы. Можно разделить код на модули и использовать конструкции export и import.
Модули — новый синтаксис ES6, они требуют дополнительной подготовки для правильной работы кода. Create React App уже включает в себя «Вебпак» и «Бабель» со всеми необходимыми настройками, что сэкономит уйму времени на их конфигурации.
Благодаря CRA мы можем переписать наш код с использованием import:`,
    code2: `import React from 'react' // импорт библиотеки
import ReactDOM from 'react-dom'
class Switch extends React.Component {
  // Конструктор компонента Switch, обработчик и функция render
}
ReactDOM.render((
  <>
    <Switch title="Счастье" color="blue" isActive={true} />
    <Switch title="Любовь" color="orange" isActive={false} />
    <Switch title="Шаурма" color="green" isActive={false} />
  </>
), document.querySelector('#root'));`,
    text4: `Таким же образом можно разделять, организовывать, импортировать и экспортировать компоненты внутри проекта.
В теории настроить всё это можно было и вручную, но CRA позволяет существенно ускорить этот процесс и, что немаловажно, учитывать при этом общепринятые подходы.`,
    subtitle3: `Установка Create React App`,
    text5: `Это несложно и похоже на то, как вы уже устанавливали зависимости пакетов NPM.
Чтобы установить CRA, откройте командную строку и введите: npm install -g create-react-app. Флаг -g указывает на то, что пакет CRA будет установлен глобально: для текущего пользователя операционной системы, а не для какого-то отдельного проекта.`,
  },
  {
    title: `Новый проект`,
    text1: `В этом уроке начнём разработку приложения Calorie-Zen. Оно призвано помочь пользователям соблюдать рацион и дневную норму калорий без лишнего стресса. Для начала создадим прототип. Чтобы быстро запустить проект, воспользуемся утилитой, которую установили в предыдущем уроке. Откроем командную строку и перейдём в директорию, в которой хотим создать проект. Для создания нового CRA-проекта используют команду npm init react-app название_проекта. Название проектов обычно пишут латиницей. Наш проект называется calorie-zen, поэтому введём команду npm init react-app calorie-zen.
После этого начинается магия CRA. Этот процесс может занять несколько минут — отличный повод сделать перерыв.
После успешного выполнения скрипта появится такое сообщение:`,
    image1: "image8.png",
    text2: `Теперь в вашем распоряжении проект, полностью готовый к работе. Запустим его.`,
    subtitle1: `Запуск проекта`,
    text3: `Перейдите в директорию проекта командой cd calorie-zen. Находясь в ней, введите ещё одну команду — npm start.
После этого проект автоматически откроется в браузере. Если этого не произошло, откройте проект в браузере, введя адрес http://localhost:3000/.
Сейчас проект выглядит так:`,
    image2: "image9.png",
    text4: `Это шаблон проекта, который создаёт Create React App по умолчанию: простой компонент, состоящий из вращающегося логотипа и текста.
Настоящему приложению потребуется совсем другое наполнение.
В следующем уроке разберём файловую структуру CRA-проекта.
Прослышав об успехе приложений для каршеринга, к вам обратился клиент и заказал приложение. Просил сделать в кратчайшие сроки, поэтому самое время обратиться к Create React App, чтобы быстро собрать и запустить проект!`,
  },
  {
    title: `Распаковка проекта`,
    text1: `Поговорим об основных файлах и директориях, с которыми предстоит работать при разработке проекта.
Для начала посмотрим на стандартную файловую структуру проекта calorie-zen:`,
    code1: {
      lang: "xml",
      value: `└── calorie-zen/
├── node_modules/
├── public/
├── src/
├── .gitignore
├── package.json
├── README.md
└── yarn.lock`},
    text2: `Разберём файлы и директории, из которых она состоит. Обратите внимание на знакомые наименования: node_modules/ и package.json.
Значит, мы можем легко подключить новые пакеты к проекту с применением NPM. Так же, как мы делали это в предыдущих спринтах.
Посмотрим, что находится в директории src/. Именно в ней вы будете совершать бóльшую часть работы над проектами:
Директория src/`,
    code2: `└── calorie-zen/
├── node_modules/
├── public/
├── src/ <!-- откроем эту директорию! -->
  ├── App.css
  ├── App.js
  ├── App.test.js
  ├── index.css
  ├── index.js
  ├── logo.svg
  ├── serviceWorker.js
  └── setupTests.js
├── .gitignore
├── package.json
├── README.md
└── yarn.lock`,
    text3: `Рассмотрим три важных файла:
Файл index.js — точка входа JavaScript. Внутри этого файла подключают корневой компонент App.
Файл App.js — корневой компонент приложения. О нём поговорим чуть позже.
CSS-файл App.css содержит стили корневого компонента App.js. В проекте на «Реакте» может быть много разных CSS-файлов: например, по файлу для каждого компонента. Мы подключим все стили к компонентам, используя возможности Create React App и ключевое слово import.
Теперь изучим директорию public/:
Директория public/`,
    code3: `└── calorie-zen/
├── node_modules/
├── public/ <!-- а теперь откроем эту директорию -->
  ├── favicon.ico
  ├── index.html
  ├── logo192.png
  ├── logo512.png
  ├── manifest.json
  └── robots.txt
├── src/
├── package.json
├── README.md
└── yarn.lock`,
    text4: `Разработка проекта ведётся в директории src/, после чего выполняется сборка проекта в результирующий код, который используют внутри HTML-документа. Обратите внимание на файл index.html в директории public/. Вам не придётся вносить много изменений в этот файл, однако иногда это будет нужно. Например, когда потребуется изменить заголовок приложения или метатег.
Директория public/ также содержит файл favicon.ico — иконку сайта, которая отображается во вкладке либо в закладках браузера.
Изображения лучше импортировать через JavaScript. Так мы с помощью хэширования избежим проблем с отображением изображений, когда придётся загрузить новые файлы с теми же названиями. Подробнее вы разбирали это в теме про сборку проекта. Это ещё одно преимущество Create React App: вся конфигурация настроена за нас.
App.js выполняет функции корневого компонента в нашем проекте. Каждый раз, когда мы создаём проект с помощью Create React App, автоматически появляется вот такой файл App.js:`,
    code4: `import React from 'react';
import logo from './logo.svg';
import './App.css';
function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
          {/* Отредактируйте App.js и сохраните файл, чтобы
          страница перезагрузилась. */}
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
          {/* Узнать больше о «Реакте» */}
        </a>
      </header>
    </div>
  );
}
export default App;`,
    text5: `Благодаря новым знаниям о JSX и компонентах, и о том, как использовать ключевые слова import и export, такой код вам теперь не страшен.
И чтобы точно ни в чём не запутаться, стоить упомянуть, что мы импортируем библиотеку «Реакта» в начале файла инструкцией import React from 'react'. Вы сможете найти «Реакт» в разделе dependencies файла package.json. Если бы мы создавали проект с нуля без CRA, нам бы пришлось отдельно вводить в командую строку npm install react --save для установки React. Вы уже знаете, как импортировать модули и устанавливать пакеты из курса по JavaScript; здесь же всё это уже настроено и доступно в готовом шаблоне проекта CRA.
Код в файле App.js отвечает за основную часть финального отображения проекта, который мы видим при запуске скрипта npm start.`,
  },
  {
    title: `Структура проекта`,
    text1: `В предыдущем уроке мы разобрали базовую структуру проекта, созданного с помощью Create React App.
Проекты со временем растут, поэтому важно подумать, как лучше их структурировать.`,
    code1: `└── easy-project/
├── index.html
├── scripts.js
└── styles.css`,
    text2: `В этом случае всё понятно: HTML, JavaScript и CSS находятся в отдельных файлах. Если с проектом будут работать другие разработчики, они легко сориентируются в чётко выстроенной структуре и поймут, за что отвечает каждый файл.
Но если взглянуть на проект calorie-zen, даже в состоянии по умолчанию он намного больше проекта easy-project из примера. Вот в чём дело: наш проект будет разрастаться, а его файловая структура станет больше и сложнее. Если сейчас не позаботиться об организации работы, очень скоро ситуация выйдет из-под контроля. Хорошо структурированный проект облегчит работу не только вам, но и другим разработчикам, которые в будущем будут работать с вашим кодом. Структура нашего проекта во многом базируется на продолжении тех практик, что мы уже используем. Мы внимательно подбираем названия функциям и переменным, оставляем комментарии в коде, чтобы сделать код понятным и упростить работу с проектом. В этом уроке разберёмся, что ещё нужно сделать, чтобы организовывать хорошую структуру в проекте.`,
    subtitle1: `Экскурсия по проекту`,
    text3: `Откроем директорию src/:`,
    code2: {
      lang: "xml",
      value: `└── src/
├── App.css
├── App.js
├── App.test.js
├── index.css
├── index.js
├── logo.svg
├── serviceWorker.js
└── setupTests.js`},
    text4: `Рассмотрим файлы компонента приложения: App.js, App.css и App.test.js. Первые два мы уже затрагивали в прошлом уроке, но не изучали их подробно. Мы называем файлы по правилу: они должны иметь то же имя, что и компонент. Название должно начинаться с заглавной буквы.
Файл App.test.js предназначен для автоматического тестирования компонента App.
По мере разработки приложения, вероятно, понадобится добавить в него новые компоненты. В нашем случае понадобятся такие:
ZenForm.js — простой компонент для формы, который позволит пользователям вносить информацию о приёмах пищи.
ZenImage.js — компонент для логотипа.
ZenTotal.js — компонент, который посчитает итоговую сумму калорий за день.
Корневым компонентом по-прежнему будет App.js. Для каждого нового компонента нужно создать соответствующие файлы со стилями, а также файлы для тестирования:`,
    code3: {
      lang: "xml",
      value: `└── src/
├── App.js
├── App.css
├── App.test.js
├── ZenForm.js
├── ZenForm.css
├── ZenForm.test.js
├── ZenImage.js
├── ZenImage.css
├── ZenImage.test.js
├── ZenTotal.js
├── ZenTotal.css
├── ZenTotal.test.js
├── index.css
├── index.js
├── logo.svg
├── serviceWorker.js
└── setupTests.js`},
    text5: `Структура выглядит не слишком сложной — в ней точно не запутаешься, даже со всеми новыми файлами.
Обычно готовые приложения состоят из гораздо большего количества компонентов.`,
    subtitle2: `Как организовать проект?`,
    text6: `Существует много разных способов организации файлов. Например, мы можем поместить все файлы со стилями в одну директорию,
файлы для тестирования в другую, а обычные скрипты — в третью:`,
    code4: {
      lang: "xml",
      value: `└── src/
├── scripts/
  ├── App.js
  ├── ZenForm.js
  ├── ZenImage.js
  ├── ZenTotal.js
  └── index.js
├── styles/
  ├── App.css
  ├── ZenForm.css
  ├── ZenImage.css
  ├── ZenTotal.css
  └── index.css
├── test-files/
  ├── App.test.js
  ├── ZenForm.test.js
  ├── ZenImage.test.js
  └── ZenTotal.test.js
├── logo.svg
├── serviceWorker.js
└── setupTests.js`},
    text7: `Такую структуру уже можно считать организованной. Но в ней станет сложно ориентироваться, когда код приложения вырастет.
Лучше всего организовывать файлы, основываясь на функциях, которые они выполняют:`,
    code5: {
      lang: "xml",
      value: `└── src/
├── components/
  ├── App.js
  ├── App.css
  ├── App.test.js
  ├── zen_form/
    ├── ZenForm.js
    ├── ZenForm.css
    └── ZenForm.test.js
  ├── zen_image/
    ├── ZenImage.js
    ├── ZenImage.css
    └── ZenImage.test.js
  └── zen_total/
    ├── ZenTotal.js
    ├── ZenTotal.css
    └── ZenImage.test.js
├── index.js
├── logo.svg
├── serviceWorker.js
└── setupTests.js`},
    text8: `Мы добавили ещё одну директорию — components/. Директория components/ содержит в себе все компоненты. И в этой же директории мы создали для каждого компонента новые файлы. Когда приложение будет расти, мы будем уверены, что структура не сломается, ведь мы создали легко масштабируемый шаблон. Такую структуру будем использовать в дальнейшей работе над проектом.
Такая файловая структура не подойдёт идеально для всех проектов. В некоторых случаях придётся выбрать другой способ организации структуры проекта. Самое главное — всё, что вы выбираете, должно согласовываться между собой. Если ваш проект организован определённым образом, обязательно придерживайтесь выбранного стандарта, поскольку это облегчит работу не только вам, но и вашим товарищам по команде.`,
  },
  {
    title: `Импорт модулей`,
    text1: `Раньше вы уже создавали проекты, а теперь узнали, почему их так важно структурировать. В этом уроке вы узнаете о способах импортирования модулей в проект. Немного отвлечёмся от подсчёта калорий и рассмотрим новый проект под названием «Империя матрасов». Нужно создать лендинг для клиента. Вы уже знаете, как быстро справиться с этой задачей: нужно запустить npm init react-app emperor-mattress и немного структурировать проект. Теперь посмотрим, как формируется директория src/:`,
    code1: `└── src/
├── components/
  ├── App.js
  ├── App.css
  ├── App.test.js
  └── landing/
    ├── Bed.js
    ├── Bed.css
    ├── Header.js
    ├── Header.css
    └── <!-- остальные компоненты, файлы для тестирования -->
├── images/
  └── bed.png
└── <!-- дополнительные файлы src/ -->`,
    text2: `На этот раз мы разместили компоненты в директории landing/. Мы также создали директорию images/ внутри директории src/.
Наша основная цель — создать лаконичную стартовую страницу с продающим заголовком и яркой картинкой. Для этого были созданы два новых компонента: Header и Bed. Поскольку это презентационные компоненты, далее следует использовать обычные функциональные компоненты. Мы по-прежнему будем применять App.js в качестве корневого компонента, так что первым делом нужно импортировать новые компоненты в App.js. Сделаем это, применив ключевое слово import.`,
    subtitle1: `Импорт компонентов`,
    text3: `Подумайте, как лучше импортировать новые компоненты, и посмотрите на код:`,
    code2: `import React from 'react';
import Header from './landing/Header'; // прошу любить и жаловать компонент header
import Bed from './landing/Bed' // и окажите компоненту bed тёплый приём
import './App.css';
function App() {
  return (
    <div className="App">
      <Header />
      <Bed />
    </div>
  );
}
export default App;`,
    text4: `Чтобы импортировать Header и Bed в App.js, пропишем перед ними ключевое слово import, затем сошлёмся на них, используя относительные пути к файлам в проекте. Обратите внимание, в каждом из импортируемых компонентов также присутствует инструкция export default:`,
    code3: `// Header.js
import React from 'react';
function Header() {
  return (
    <h1>Империя матрасов</h1>
  );
}
export default Header;
// Bed.js
import React from 'react';
function Bed() {
  return (
    <img alt='A comfortable bed'/>
  );
}
export default Bed;`,
    text5: `Начало положено. Если ввести npm start в командную строку, браузер покажет результат автоматически. Если по какой-то причине этого не произошло, введите вручную адрес localhost:3000 в браузере.`,
  },
  {
    title: `Импорт изображений`,
    text1: `В предыдущем уроке мы создали новые компоненты, затем импортировали их в корневой компонент, применив ключевое слово import.
Сейчас начальная страница приложения — это заголовок на белом фоне. В этом уроке добавим на неё изображение.`,
    subtitle1: `Добавление изображений`,
    text2: `Как и в случае с другими модулями, воспользуемся инструкцией import для импорта изображений. Посмотрим на содержимое директории src/:`,
    code1: `└── src/
├── components/
  ├── App.js
  ├── App.css
  ├── App.test.js
  └── landing/
    ├── Bed.js
    ├── Bed.css
    ├── Header.js
    ├── Header.css
    └── <!-- остальные компоненты, файлы для тестирования -->
├── images/
  └── bed.png
└── <!-- дополнительные файлы src/ -->`,
    text3: `Изображение bed.png нужно импортировать в Bed.js. Сделаем это внутри компонента:`,
    code2: `import React from 'react';
import bedPath from '../../images/bed.png'; // Путь к изображению внутри сборки
function Bed() {
  return (
    <img alt='A comfortable bed' src={bedPath}/>
  );
}
export default Bed;`,
    text4: `Мы импортировали файл изображения bed.png в компонент строчкой кода: import bedPath from '../../images/bed.png'. Как и в предыдущем уроке, использовали относительные пути к файлам. Внутри JSX задали значение {bedPath} атрибуту src тега <img>.
Если кто-то из команды дизайнеров решит изменить дизайн этой иллюстрации, они смогут сохранить другое изображение внутри images/ под именем bed.png, и «Вебпак» будет динамично обновлять сборку по мере необходимости.
Откроем результат в браузере:`,
    image: "image10.png",
    text5: `А вот и кроватка! Теперь вы умеете добавлять картинки в компоненты. Если планируете расширять базу мультимедийных файлов приложения, заранее подумайте, как организовать эти файлы.`,
  },
  {
    title: `Работа с CSS`,
    text1: `Лендинг всё ещё выглядит невзрачно, поэтому нужно подумать, как его стилизовать. По умолчанию утилита Create React App предоставляет
CSS-файл App.css. Снова посмотрим на структуру директории src/:`,
    code1: `└── src/
├── components/
  ├── App.js
  ├── App.css
  ├── App.test.js
  └── landing/
    ├── Bed.js
    ├── Bed.css
    ├── Header.js
    ├── Header.css
    └── <!-- остальные компоненты, файлы для тестирования -->
├── images/
  └── bed.png
└── <!-- остальные файлы в src/ -->`,
    text2: `Сейчас в проекте есть и другие CSS-файлы — мы создали для каждого компонента свой. Займёмся ими чуть позже, а пока рассмотрим App.css.
По умолчанию он содержит много стилей, которые CRA применяет для стилизации шаблонного проекта. Удалим их и оставим только один селектор:`,
    code2: `.App {
  text-align: center;
}`,
    subtitle1: `Использование CSS в Create React App`,
    text3: `Зададим цвет фона начальной страницы и флекс-свойством выровняем её содержимое по центру в файле index.css. Для этого изменим селектор body и добавим свойства:`,
    code3: `body {
  /* остальные стандартные свойства Create React App */
  background-color: #00ad82;
  min-height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}`,
    text4: `Этот стиль применяется ко всему body
Пока все элементы внутри корневого <div> в файле App.js выровнены по центру страницы. А если позже мы захотим изменить выравнивание отдельных элементов? Чтобы это было возможно, будем использовать отдельные CSS-файлы для стилизации компонентов.`,
    subtitle2: `Импорт CSS`,
    text5: `Удалим свойство text-align: center; из файла App.css. После этого заголовок и изображение кровати выровняются по левой стороне экрана.
Это выглядит не очень красиво. Проблему можно исправить, применив нужные свойства внутри компонентов.
Начнём с компонента Header: отцентруем текст, изменим размер шрифта и цвет заголовка. Откроем директорию landing/:`,
    code4: `└── landing/
├── Bed.js
├── Bed.css
├── Header.js
├── Header.css
└── <!-- остальные файлы -->`,
    text6: `У каждого компонента свой CSS-файл — в них будем указывать нужные стили. Сейчас оба файла стилей пустые.
Добавим стили в файл Header.css, применяя селектор класса .header-title:`,
    code5: `.header-title {
  text-align: center;
  color: #fff;
  font-size: 40px;
  max-width: 220px;
  margin: 0 auto 58px;
  text-transform: uppercase;
}`,
    text7: `Уже неплохо, но компонент Header пока не подозревает, что он должен применить эти стили. Чтобы сказать ему об этом, импортируем стили в Header.js и правильно назначим класс .header-title внутри JSX:`,
    code6: `// компонент Header теперь в Header.js
  import React from 'react';
  import './Header.css' // импортируем CSS-файл
  function Header() {
    return (
      <h1 className="header-title">Империя матрасов</h1> // применяем класс
    );
  }
export default Header;`,
    text8: `Готово.
Чтобы расположить изображение по центру, нужно изменить CSS внутри Bed.css, заменив text-align на свойства display: block; и margin: 0 auto; селектора .bed-logo. Когда CSS-файл будет готов к работе, нужно его импортировать в Bed.js:`,
    code7: `//Bed.js
import React from 'react';
import bedPath from '../../images/bed.png';
import './Bed.css' // импортируем CSS-файл
function Bed() {
  return (
    // не забудьте о className
    <img className="bed-logo" alt="A comfortable bed" src={bedPath}/>
  );
}
export default Bed;`,
  },
  {
    title: `Шрифты`,
    text1: `Иногда в проектах требуется подключить особенные шрифты. Например, когда приложение реализовано в фирменном стиле компании.
В открытом доступе можно найти множество шрифтов. Для этого удобно использовать библиотеки шрифтов, к примеру, библиотеку Google Fonts.
В этом уроке научимся подключать кастомные шрифты и приукрасим шапку приложения.
Мы подобрали шрифт, который одобрил заказчик приложения «Империя матрасов». Название шрифта — Roboto.
Разместим файл шрифта в новой директории fonts/:`,
    code1: `└── src/
├── components
├── images
├── fonts/
  └── Robotocondensed.woff
└── <!-- остальные файлы в директории src -->`,
    text2: `Применим этот шрифт к тегу h1 внутри компонента Header. Пропишем стили в файле Header.css`,
    code2: `@font-face {
  font-family: 'Roboto Condenced';
  src: url(../../fonts/Robotocondensed.woff) format('woff');
}
.header-title {
  text-align: center;
  color: #fff;
  font-size: 40px;
  font-family: 'Roboto Condenced', sans-serif;
  max-width: 220px;
  margin: 0 auto 58px;
  text-transform: uppercase;
}`,
    text3: `Мы задали шрифт Pacifico в свойстве font-family для селектора класса .header-title. Теперь шрифт нужно подключить.
Поскольку мы используем CRA со всеми преимуществами «Вебпака», внутри директивы @font-face укажем относительный путь к источнику.
Это нужно, чтобы при сборке все файлы оказались в правильном месте.
Кроме того, применить шрифт нужно только к шапке, поэтому объявим шрифт через @font-face в файле Header.css.
Впрочем, шрифты часто используются в разных местах приложения, поэтому мы также могли бы сделать это в index.css.`,
  },
  {
    title: `Добавление классового компонента`,
    text1: `Горькая правда лучше, чем сладкая ложь. Придётся признать: «Империи матрасов» пока ещё далеко до запуска. Добавим небольшую форму, в которой пользователь сможет указать свою электронную почту, чтобы узнать о заветном релизе и заказать матрас мечты.
Сперва создадим новый компонент для формы. До сих пор в этом проекте у нас не было необходимости использовать внутреннее состояние.
На этот раз оно нам понадобится, чтобы пользователь увидел изменения в интерфейсе после отправки формы. Поэтому применим классовый компонент. Сначала добавим в папку landing/ два новых файла –– InfoForm.js и InfoForm.css:`,
    code1: `└── landing/
├── Bed.js
├── Bed.css
├── Header.js
├── Header.css
├── InfoForm.js
├── InfoForm.css
└── <!-- остальное содержимое директории -->`,
    text2: `Следующим шагом настроим компонент InfoForm.js. Так выглядит полный код этого компонента:`,
    code2: `import React from 'react';
import './InfoForm.css';
class InfoForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      submitted: false,
    };
  }
  handleSubmit = () => {
    this.setState({ submitted: true });
  };
  render() {

    if (this.state.submitted) {
      return (
        <p className="infoForm-text">Благодарим вас за подписку. Мы свяжемся с вами, когда царство комфорта
        откроется!</p>
      );
    } else {
      return (
        <div className="infoForm-container">
          <p className="infoForm-text">Заполните форму ниже, чтобы узнать об открытии «Империи матрасов» первыми.</p>
          <form onSubmit={this.handleSubmit} className="infoForm-form">
            <input className="infoForm-input" type="email" placeholder={'Введите электронную почту'} />
            <button className="infoForm-button" type="submit">Удивите меня</button>
          </form>
        </div>
      );
    }
  }
}
export default InfoForm;`,
    text3: `Теперь разберём его подробнее.`,
    subtitle1: `Компонент в деталях`,
    text4: `В самом начале файла мы указываем два импорта: react — для корректной работы JSX-кода и InfoForm.css со стилями формы.
Внутри конструктора мы вызываем super, передавая props, и инициализируем компоненты state так, чтобы this.state.submitted был равен false.
Каждый раз, когда пользователь вводит электронную почту в форму и нажимает на кнопку, значение будет изменяться на true.
Далее мы определяем метод handleSubmit. Он будет переключать значение state с false на true при каждом вызове.
Изучим функцию render:`,
    code3: `render() {

  if (this.state.submitted) {
    return (
      <p className="infoForm-text">Благодарим вас за подписку. Мы свяжемся с вами, когда царство комфорта откроется!</p>
    );
  } else {
    return (
      <div className="infoForm-container">
        <p className="infoForm-text">Заполните форму ниже, чтобы узнать об открытии «Империи матрасов» первыми.</p>
        <form onSubmit={this.handleSubmit} className="infoForm-form">
          <input className="infoForm-input" type="email" placeholder={'Введите электронную почту'} />
          <button className="infoForm-button" type="submit">Удивите меня</button>
        </form>
      </div>
    );
  }
}
export default InfoForm;`,
    text5: `Вот что мы делаем в функции render:
Используем конструкцию if...else для отрисовки различного JSX-кода в зависимости от значения this.state.submitted. Если значение равно false, выведется элемент <div>, содержащий форму <form>. Если же значение true, отрисуется тег <p> с сообщением-подсказкой о подписке.
Привязываем метод onSubmit к <form>. Внутри JSX onSubmit вызывается при каждой отправке формы кликом на кнопку либо нажатием клавиши “Enter”. Для вызова метода значение this.handleSubmit передаётся в фигурных скобках, а значение state обновляется каждый раз, когда пользователь отправляет форму. Задаём значение "email" атрибута type внутри <input>. Это позволяет использовать встроенную валидацию формы: пользователь должен будет ввести в этом поле адрес электронной почты, чтобы кнопка submit стала активной.
Вы научились это делать в шестом спринте. В самом конце файла InfoForm.js мы добавили инструкцию export default InfoForm, В самом конце файла InfoForm.js мы добавили инструкцию export default InfoForm, чтобы экспортировать компонент для последующего использования в App.js.
Посмотрим, как теперь выглядит App.js:`,
    code4: `import React from 'react';
import Header from './landing/Header';
import Bed from './landing/Bed';
import InfoForm from './landing/InfoForm';
import './App.css';
function App() {
  return (
    <div className="App">
      <Header />
      <Bed />
      <InfoForm />
    </div>
  );
}
export default App;`,
    text6: `Добавился импорт компонента InfoForm, который мы затем включили в корневой элемент App.
Теперь у нашего приложения есть хоть и маленькая, но настоящая функциональность. На самом деле этого достаточно, чтобы задуматься одебаггинге приложения — поиске и исправлении ошибок. Ведь начиная с этого момента проект будет становиться сложнее.`,
  },
  {
    title: `Дебаггинг проекта`,
    text1: `Давным-давно, а именно — в четвёртом спринте, вы изучили способ отладки кода в веб-браузере. Всё это применимо и к проектам на «Реакте».
В нашем приложении мы ещё не научились обрабатывать данные, полученные от пользователя через форму. Доработаем код, чтобы исправить это. Затем проверим, что всё работает как надо с помощью инструментов, встроенных в браузер.`,
    subtitle1: `Доступ к значениям элементов форм в «Реакте»`,
    text2: `Сделаем всё это внутри файла InfoForm.js. Сначала добавим новое значение свойству state, чтобы хранить данные о почте пользователя:`,
    code1: {
      lang: "javascript",
      value: `this.state = {
  submitted: false,
  userEmail: '' // здесь пока пустая строка
}`},
    text3: `Добавим слушатель onChange к элементу <input>. Он будет срабатывать каждый раз, когда в поле ввода вносятся изменения. Например, если пользователь наберёт строку «хочу матрас», onChange сработает 11 раз — по одному на каждый символ в строке.
Затем создадим новый метод handleChange и назначим его в качестве обработчика события onChange. Вот как будет выглядеть элемент input:`,
    code2: {
      lang: "html",
      value: `<input onChange={this.handleChange} className="infoForm-input" type="email" placeholder="Введите электронную почту" />`},
    text4: `И метод handleChange:`,
    code3: `handleChange = (evt) => {
  this.setState({ userEmail: evt.target.value });
};`,
    text5: `Этот метод будет обновлять this.state.userEmail, чтобы в него попадало самое новое введённое значение. Возможно, сразу не очень понятно, что происходит с переменной evt в теле this.setState. Разобраться в этом вам поможет урок «Доступ к значениям элементов форм».
В этом уроке мы используем значения полей формы, чтобы обновить состояние компонента.`,
    subtitle2: `Базовая отладка в «Реакте»: console.log`,
    text6: `Разберём, какие инструменты отладки можно использовать в «Реакте». Добавим вызов console.log в обработчик handleSubmit, чтобы выводить в консоль значение this.state.userEmail каждый раз, когда пользователь отправляет форму:`,
    code4: `handleSubmit = () => {
  console.log(this.state.userEmail);
  this.setState({ submitted: true });
}`,
    text7: `Знакомый способ! Если открыть приложение и ввести, допустим, “vasyafrontend@yandex.ru” в поле формы, а затем открыть консоль браузера, мы тоже увидим там “vasyafrontend@yandex.ru”.`,
    subtitle3: `Отладка через debugger`,
    text8: `Установить в коде контрольные точки можно при помощи уже знакомой вам строки debugger;. Добавим её сразу после вызова console.log внутри функции handleSubmit. Так мы остановим выполнение кода до тех пор, пока не дадим соответствующую команду из браузера:`,
    code5: `handleSubmit = () => {
  console.log(this.state.userEmail);
  debugger;
  this.setState({ submitted: true });
}`,
    text9: `Наше приложение мало что умеет, поэтому эти методы отладки пока не принесут большой пользы, но она станет очевидной с развитием приложения. Для качественной отладки приложений на «Реакте» понадобится более мощный инструмент, который вы изучите позже.
А пока научимся применять основные инструменты разработчика.`,
    subtitle4: `Инструменты разработчика`,
    text10: `Инструменты разработчика открываются по-разному в зависимости от операционной системы и браузера. В следующем уроке установим специальное расширение, которое работает внутри Яндекс.Браузера, Chrome, и Firefox, поэтому сосредоточимся на этих браузерах:
В Яндекс.Браузере или Chrome нажмите сочетание клавиш Option + ⌘ + I (на macOS) либо Shift + Ctrl + I (на Windows или Linux);
В Firefox нажмите сочетание клавиш Option + ⌘ + I (на macOS) либо Ctrl + Shift + I или F12 (Windows или Linux).
После этого в Chrome вы увидите нечто подобное в верхней части открывшейся панели:
Инструменты разработчика очень похожи в этих двух браузерах. Для проверки DOM используют вкладку “Elements” в Chrome либо вкладку “Inspector” в Firefox. Чтобы открыть консоль в обоих браузерах, нужно просто выбрать вкладку “Console”.`,
    subtitle5: `Изучение DOM`,
    text11: `Открыв инструменты разработчика в браузере и проверив DOM нашего проекта, мы увидим такой HTML-код:`,
    image: "image11.png",
    text12: `С помощью инструментов разработчика можно получить много полезной информации о проекте.
Но для работы с «Реактом» нам нужны специальные инструменты`,
  },
  {
    title: `Использование расширения React DevTools`,
    text1: `Теперь, когда расширение React DevTools установлено, вернёмся к «Империи матрасов». Для этого запустите npm run start и перейдите по адресу http://localhost:3000/. Вы увидите, что иконка React DevTools стала красной. Чтобы узнать почему — кликните по ней.
Появится попап с сообщением «На этой странице используется сборка „Реакта“ для разработки». Значит, расширение обнаружило проект:`,
    image1: "image12.png",
    text2: `Внизу попапа появится текст: «Откройте инструменты разработчика. Вкладки “Components” и “Profiler” появятся справа».
Поговорим об инструментах разработчика в браузере подробнее.`,
    subtitle1: `Использование React DevTools в браузере`,
    text3: `В инструментах разработчика находится много вкладок. С некоторыми из них вы уже знакомы: например, “Console” и “Elements” или “Inspector” в Chrome. Рассмотрим остальные вкладки. Hажмите на символ “»”, расположенный справа от вкладок:`,
    image2: "image13.png",
    subtitle2: `Вкладка “Components” в React DevTools`,
    text4: `После установки расширения React DevTools появятся две вкладки: “Components” и “Profiler”. Сперва рассмотрим вкладку “Components”.
Вот что покажет инструмент, когда будет загружено приложение «Империя матрасов»:`,
    image3: "image14.png",
    text5: `Отобразится дерево компонентов проекта, в котором можно получить подробную информацию о каждом компоненте.
Рассмотрим на примере компонента InfoForm. Подробная информация о компоненте находится внизу вкладки:`,
    image4: "image15.png",
    text6: `Здесь можно посмотреть расположение файла, изучить пропсы компонента, его текущее состояние state и какой компонент отвечает за его отрисовку –– в нашем случае компонент App отрисовывает InfoForm.
Особого внимания заслуживают значения стейта компонента, которые обновляются в режиме реального времени. На скриншоте выше введённое в поле для электронной почты «видите?» автоматически появилось в инструментах разработчика.
Во вкладке “Components” есть ещё несколько кнопок: например, чтобы приостановить работу компонента там, где это возможно, или взглянуть на ту часть DOM-дерева, в которой находится компонент. Ещё есть кнопки для вывода данных о компоненте в консоль и для просмотра его исходного кода. Если использовать эти расширенные возможности вместе с console.log и debugger, можно более точно анализировать изменения состояния и оперативно отслеживать и устранять баги в проектах на «Реакте».`,
    subtitle3: `Вкладка “Profiler” в React DevTools`,
    text7: `Поговорим о сравнительно новой функции React DevTools — “Profiler”. Она позволяет детально изучить приложение: отслеживает, как часто оно отрисовывается, и указывает, какие части приложения могут тормозить его работу. Поскольку приложение небольшое, мы не сможем в полной мере ощутить преимущества этой функции. Но в больших проектах без неё не обойтись, ведь она помогает оптимизировать работу приложения.
Откроем вкладку “Profiler”:`,
    image5: "image16.png",
    text8: `Чтобы начать собирать данные, нужно нажать на кнопку записи. Сейчас в форме «Империи матрасов» есть только одно поле — для почтового адреса. Когда пользователь отправляет форму, она отрисовывается заново, и пользователь получает сообщение.
Чтобы перестать записывать данные, нужно ещё раз нажать на кнопку записи.
Вот что мы увидим, если соберём данные приложения «Империя матрасов»:`,
    image6: "image17.png",
    text9: `Мы узнаем, какие компоненты были отрисованы, когда и сколько времени это заняло.`,
  },
  {
    title: `Сборка проекта`,
    text1: `Во всех предыдущих уроках мы разрабатывали проект. Но пора уже его запускать, поэтому научимся собирать проект. Что для этого нужно?
Внутри файла package.json, который был создан с помощью CRA, хранится четыре готовых скрипта:`,
    code1: `"scripts": {
  "start": "react-scripts start",
  "build": "react-scripts build",
  "test": "react-scripts test",
  "eject": "react-scripts eject"
},`,
    text2: `Мы уже использовали скрипт "start", когда запускали проект на локальном сервере. При сборке проекта нам потребуется запустить скрипт "build".
При запуске команды npm run build через консоль скрипт генерирует оптимизированную сборку проекта. На практике это означает, что внутри проекта появится новая папка build/. Внутри build/static можно найти оптимизированные версии всего написанного кода, наряду с другими ресурсами: JS, CSS и шрифтами. Затем эти файлы можно разместить на любом сервере, к которому у нас есть доступ.
Иными словами, эти файлы можно использовать для деплоя веб-приложения в интернете.
Чтобы посмотреть, что получится, запустим проект из папки build/ на локальном сервере. Для этого понадобится установить ещё один пакет.
Из командной строки запустим команду npm i -g serve. Пакет установлен в вашей системе глобально — так же, как вы ранее установили Create React App. Далее остаётся только запустить serve -s build. В консоли отобразится сообщение, что проект выполняется на локальном сервере — по умолчанию адресом будет localhost:5000. Введите этот адрес в браузере и увидите свой проект!

Функциональный и классовый подходы довольно сильно отличаются с точки зрения внутреннего устройства, но в целом были призваны решать одни и те же задачи, а с появлением хуков во многом стали равноценными и взаимозаменяемыми. Изучив хуки, вы сможете использовать в своих проектах тот подход, который вам больше понравится.
Что же такое хуки? Хук — это специальная функция (обычно предоставляемая движком «Реакта»), которую можно вызывать в теле функционального компонента, чтобы осуществить доступ к его внутренним ресурсам.
    `,
  },
];
