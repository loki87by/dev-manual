export const REGEXPS = [
  {
    subtitle1: `регулярное выражение`,
    text1: `Чтобы создать регулярное выражение, нужно заключить шаблон в слеши: /.../. Эти символы зарезервированы для этого в JS.
        Разработчики называют /.../ «литералами регулярного выражения»:
        Чтобы лучше понимать аудиторию, вы хотите отобрать всех пользователей, пользующихся iPhone. Применим для этого регулярное выражение.`,
    code1: `const regex = /iPhone/; // метод test проверяет, есть ли искомая строка в тексте и возвращает true или false.
const iPhoneComments = comments.filter((item) => regex.test(item));
console.log(iPhoneComments);
// [
// Я пользуюсь iPhone 6s — всё летает.,
// Только последний iPhone — там улучшили водонепроницаемость.
// ]`,
    title: `Методы и флаги`,
    text2: `На поиск влияют три сущности:
        Спецсимволы — содержатся в самóм регулярном выражении и позволяют тоньше задать поиск. Например, искать сразу «Яндекс» и «Yandex».
        Методы — определяют, что нужно делать, когда строка найдена: заменить её или сообщить, где произошло совпадение.
        Флаги — кастомизируют работу метода. Например, выставив флаг, можно найти все совпадения с регуляркой или только одно.`,
    subtitle2: `Методы работы с регулярными выражениями`,
    text3: `Методы строк. Их вызывают как метод строки:`,
    code2: `const regex = /т/;
const word = 'лестница'; // test — метод объекта RegExp. Поэтому мы вызываем его
regex.test(word); // true — метод подтвердил, что в строке есть совпадение`,
    text4: `Методы регулярных выражений. Их вызывают как метод регулярки:`,
    code3: `const regex = /т/;
const word = 'лестница'; // test — метод объекта RegExp. Поэтому мы вызываем его
regex.test(word); // true — метод подтвердил, что в строке есть совпадение`,
    text5: `Запутаться тут очень легко. Поэтому будем писать имена методов вместе с объектом, в который они записаны: String.match и RegExp.test`,
    subtitle3: `Метод String.match`,
    text6: `Метод String.match принимает один аргумент — регулярное выражение. Если найти удалось, String.match вернёт массив с тем, что нашёл:`,
    code4: `const regex = /сс/;
const word = 'рассчитывать';
word.match(regex); // [ "сс" ]`,
    text7: `Если символ найти не удалось, String.match
        Если передать методу String.match регулярное выражение без флага g, полученному массиву будут определены дополнительные свойства:`,
    code5: `const str = 'тро-ло-ло';
const result = str.match(/ло/);
result[0]; // "ло"
result.index; // 4
result.input; // "тро-ло-ло"`,
    text8: "или",
    code6: `const str = 'тро-ло-ло';
const result = str.match(/ло/g);
result; // ["ло", "ло"]`,
    subtitle4: `Метод String.search`,
    text9: `Метод String.search принимает на вход регулярное выражение и возвращает индекс символа, на котором произошло совпадение:
        Метод String.search не работает с глобальным поиском — он всегда возвращает индекс первого совпадения
        const regex = /\\d/ig;
        const string = '12! равен 479001600';
        string.search(regex); // 0 - индекс первого совпадения, то есть "1".
        Если же совпадения не было вовсе — нам вернётся -1`,
    subtitle4: `Метод String.split`,
    text10: `Методу String.split можно передать на вход и регулярное выражение. Тогда на выходе мы получим массив элементов,
        которые находили между строчками, найденными нашей регуляркой`,
    code7: {
      lang: "javascript",
      value: `const regex = /\\n/im; // [
\`Мой дядя самых честных правил, // Мой дядя самых честных правил,,
Когда не в шутку занемог, // Когда не в шутку занемог,
Он уважать себя заставил // Он уважать себя заставил,
И лучше выдумать не мог.\`.split(regex); // И лучше выдумать не мог.
// ]`,
    },
    text11: `Обратите внимание: метод String.split ожидает, что какой-то элемент должен быть и до, и после разделителя.
        Поэтому если ваша строка начинается с разделителя или заканчивается разделителем,
        в полученном массиве первым или последним элементом будет пустая строка.`,
    subtitle5: `Метод RegExp.exec`,
    text12: `Метод RegExp.exec похож на String.match. Если в регулярном выражении нет флага g, String.match и RegExp.exec вернут одинаковый результат
        Но если установить флаг g, метод RegExp.exec будет вести себя совсем иначе. Он вернёт первое совпадение, а затем — запишет в свойство
        lastIndex регулярного выражения номер символа в тексте, на котором это совпадение произошло. Если запустить метод RegExp.exec снова,
        он будет искать не с начала строки, а с того символа, на котором остановился в прошлый раз. То есть с записанного в свойство lastIndex`,
    code8: {
      lang: "javascript",
      value: `const str = \`Идёт без проволочек // regex.exec(str); // ["Идёт без проволочек"]
И тает ночь, пока // regex.exec(str); // ["И тает ночь, пока"]
Над спящим миром лётчик // regex.exec(str); // ["Над спящим миром лётчик"]
Уходит в облака. // regex.exec(str); // ["Уходит в облака."]\`;
let regex = /.+/g;`,
    },
    text13: `RegExp.exec обновляет свойство lastIndex после каждого вызова.
        Таким образом, метод RegExp.exec помнит, где закончил поиски в прошлый раз.
        Если запустить этот метод в цикле, мы можем точно контролировать, сколько совпадений хотим найти
        Если очередной поиск не дал результатов, в свойство lastIndex регулярного выражения записывается 0. То есть новый поиск начнётся с начала`,
    subtitle6: `Метод RegExp.test`,
    text14: `Он вызывается на регулярном выражении, а строку принимает на вход. Результат работы метода — булево значение.
        Если совпадение найти удалось, RegExp.test вернёт true
        Если же совпадений с регулярным выражением в строке нет, получим false
        Метод RegExp.test тоже обладает памятью — как и RegExp.exec.
        Если передать ему регулярное выражение с флагом g, в свойство lastIndex этого регулярного выражения попадёт номер символа, где было
        найдено совпадение. И следующий поиск регулярного выражения начнётся с этого символа, а не с начала строки:`,
    subtitle7: `Метод String.replace`,
    text15: `Он позволяет на ходу собирать новый текст из исходного.
        Работает он так: ищет в тексте совпадение с регуляркой, составляет какую-то новую строку из полученной и возвращает её нам.
        Всего у метода два параметра. Первый — это шаблон регулярного выражения. Вторым аргументом может быть строка или функция.
        Именно второй параметр определяет, как именно будет составлена новая строка из совпадения.
        Чаще всего методу String.replace передают строку. Все совпадения в исходном тексте будут заменены этой строкой.`,
    code9: `const strObj = 'Пробел всегда нужно ставить после запятой ,а не до неё.';
const regex = /\\s,/g;
strObj.replace(regex, ', '); // "Пробел всегда нужно ставить после запятой, а не до неё."`,
    text16: `В этой строке можно использовать спецсимволы. Тогда движок не будет просто заменять совпадения какой-то строкой.`,
  },
  {
    title: `Флаги`,
    text1: `Флаг — это символ, который стоит в регулярном выражении в самом конце и задаёт настройки поиска. Всего их шесть: g, i, m, u, y, s.
        В регулярном выражении флагов может быть несколько, и они могут идти в любом порядке.
        Если установить флаг g, мы будем искать все совпадения, а не только первое:
        Если поставить флаг i, поиск не будет различать строчных и прописных букв:
        Если поставить флаг u, можно искать символы по их номеру в Юникоде.
        Чтобы найти символ по коду, используют такую конструкцию: \\u{номер символа}
        Флаг y позволяет проверить, есть ли искомая строка в строго определённом месте текста.
        Работает так: вы включаете флаг y при составлении регулярного выражения.
        А затем записываете в свойство lastIndex этого регулярного выражения номер символа, с которого нужно проверять`,
    subtitle1: `Флаг m`,
    text2: `Начало строки и конец строки
        Спецсимвол, обозначающий начало строки, — это шляпка ^, или карет. Она говорит, что нужно искать совпадение только с началом текста`,
    code1: `const regex = /^\\d+/g;
const newReg = /\\d+/g;
const str = '2001 год: Космическая одиссея, вышел в 1968 году';
str.match(regex); // [ "2001" ];
str.match(newReg); // [ "2001", "1968" ];`,
    text3: `Символ конца строки — знак доллара $. Аналогично указывает искать совпадение с концом текста:`,
    code2: {
      lang: "javascript",
      value: `const regex = /\\d+$/;
const str = 'https://praktikum.yandex.ru/trainer/frontend-developer/lesson/45';
str.match(regex); // ( ["45"] )`,
    },
    subtitle2: `Многострочные тексты`,
    text4: `Чтобы написать многострочный текст, перенос можно поставить \n или пользоваться обычными переносами в шаблонных строках
        Для нас перенос это строка закончилась. А для движка начало строки только то, что после открывающей кавычки, а конец до закрывающей
        Чтобы изменить это, нужно установить флаг m. Тогда движок будет считать каждый перенос концом одной строки и началом другой
        Это работает и с шаблонными строками, и с обычными: в них движок будет считать началом и концом строки комбинации \\n`,
  },
  {
    title: `Спецсимволы и их обратные классы`,
    subtitle1: `точка.`,
    text1: `В шаблоне регулярного выражения она заменяет любой символ.`,
    code1: `const str = \`
Не помню, как именно его зовут:
то ли Сортини, то ли Сордини.
Быть может, и Сардини, через «а».
\`;
const regex = /С.р.ини/g; // Точки в регулярном выражении заменяют любой символ.
str.match(regex); // [ "Сортини", "Сордини", "Сардини" ]`,
    text2: `Но у точки есть одна слабость: она не найдёт перенос строки
        Есть одиночные спецсимволы — точка, например. Но многие спецсимволы — это буквы. И чтобы движок понимал, что это не буква,
        в регулярном выражении такой символ нужно экранировать — то есть поставить перед ним обратный слеш \\`,
    subtitle2: `Спецсимвол \\w`,
    text3: `говорит движку искать любую цифру, латинскую букву или нижнее подчёркивание. \\W ищет всё, что угодно:
        знаки вопроса, пробелы, слеши, кириллические символы, — но только не цифры, буквы базовой латиницы и нижние подчёркивания.`,
    subtitle3: `Спецсимвол \\d`,
    text4: `Спецсимвол \\d совпадает с любой цифрой
        Обратный класс этого символа совпадает со всеми не-цифрами: буквами, пробелами, спецсимволами.`,
    subtitle4: `Спецсимвол \\s`,
    text5: `Спецсимвол \\s ищет «пустоты» в тексте: пробелы (в том числе неразрывные), переносы строк и табуляции.
        Его обратный класс \\S ищет любые символы, только не пробелы, табуляции и переносы`,
    subtitle5: `Спецсимвол \\b`,
    text6: `означает границу слова. Движок считает границей слова:
        начало строки;
        конец строки;
        любой символ, кроме цифр, латинских букв и нижнего подчёркивания."
        Обратите внимание: любая нелатинская буква прочитывается движком как отдельное слово. Поэтому с кириллицей спецсимвол \\b не работает.
        обратный класс \\B — он ищет не конец слова: цифру, латинскую букву или нижнее подчёркивание. Таким образом, \\B делает то же самое, что \\w`,
  },
  {
    title: `Наборы и диапазоны`,
    text1: `Наборы позволяют задать группу символов и искать совпадения с одним из них. Например, искать сразу и букву «а», и «б»:
        Чтобы создать набор, нужно перечислить подходящие символы в квадратных скобках
        Диапазоны позволяют указать промежуток доступных значений. Например, искать только цифры от 5 до 8 или только буквы от «М» до «Р».
        Диапазон — часть набора. Это два символа, разделённых дефисом.
        Диапазоны можно совмещать с наборами и другими диапазонами:`,
    code1: `const regex = /[a-z0-9\\-]/gi; // все латинские буквы, все цифры и дефис
const str = 'В Берлин я летал на boeing 737-800';
str.match(regex).join(''); // "boeing737-800"`,
    subtitle: `Исключающие наборы и диапазоны`,
    text2: `Чтобы сделать набор или диапазон исключающим, перед ним нужно поставить «шляпку» ^ (карет):`,
    code2: `const regex = /[^1-3]/g;`,
    text3: `Обратите внимание: если дефис стоит в регулярном выражении, движок и будет его искать. Сам по себе дефис спецсимволом не является.
        Однако, если он стоит в наборе между двумя символами, движок начнёт воспринимать это не как набор трёх символов, а как диапазон:
        /[ac-]/; // это набор из трёх символов: a, c и -
        /a-c/; // это уже диапазон из трёх символов: a, b и с
        Мы рекомендуем всегда экранировать дефис в регулярных выражениях: так можно избежать ошибок. То же самое касается вот этих символов:
        дефис -
точка .
плюс +
круглые скобки ()
карет (шляпка) ^
открывающая квадратная скобка [
        Их можно не экранировать в регулярном выражении. Но всё же мы рекомендуем это делать, чтобы не было путаницы.`,
  },
  {
    title: `Квантификаторы`,
    subtitle1: `От одного до бесконечности повторений — квантификатор +`,
    code1: `const str = 'Правильно писать «свиной», с одной «н»';
const regex = /свин+ой/; // такое регулярное выражение найдёт оба варианта: и с «н», и с «нн»
str.match(regex); // [ "свиной" ]`,
    subtitle2: `От нуля до бесконечности повторений — квантификатор *`,
    text1: `Другой квантификатор для поиска повторяющихся символов — это звёздочка (астериск): *. Работает почти как плюс, но есть одно отличие.
        Символ, после которого стоит плюс, обязательно должен быть в строке. То есть плюс как бы говорит движку:
        «Ищи вот этот символ и после него ещё может быть сколько угодно таких же символов».
        Звёздочку же устраивает и полное отсутствие того символа, который перед ней стоит.
        То есть если звёздочка стоит после символа, этого символа в найденной строке может вовсе не быть:`,
    code2: `const exc = 'экскаватор';
const esc = 'эскалатор';
const regex = /эк*ска[вл]атор/; // буква "к" может встречаться, а может и не встречаться
exc.match(regex); // [ "экскаватор" ]
esc.match(regex); // [ "эскалатор" ]`,
    subtitle3: `Необязательный символ — квантификатор ?`,
    text2: `Ещё один способ сделать символ необязательным: квантификатор ?. Если звёздочка приемлет от нуля до бесконечности символов,
        то знак вопроса строже — его устраивает лишь 0 и 1: либо есть один символ, либо его нет`,
    code3: {
      lang: "javascript",
      value: `/* делает букву u не обязательной и будет искать оба варинта написания favourite и favorite. */
const regex = /favou?rite/g;
const str = 'favourite for favorite';
str.match(regex); // ["favourite", "favorite"]`,
    },
    subtitle4: `Либо один символ, либо другой — квантификатор |`,
    text3: `Этим квантификатором можно искать либо один символ, либо другой. Т.е. если написать a|b, нам подойдёт и символ a, и символ b`,
    code4: `const someSimbol = /cent(er|re)/g
const str = 'center in centre';
console.log(str.match(someSimbol)); // ["center", "centre"]`,
    subtitle5: `Контроль повторов — квантификатор {}`,
    text4: `После символа можно поставить фигурные скобки и указать в них, сколько повторений этого символа мы хотим найти
        Можно также указывать не точное количество повторений, а диапазон. Например, когда нас устроит от 2 до 5 повторений
        Верхнюю границу числа повторений можно не указывать: например, можно искать от 5 до бесконечности.
        В таких случаях просто не указывайте в фигурных скобках второе число. Но запятую ставьте — она нужна.`,
    code5: `const someSymbol = /a{1,}/g;
const str = 'alohaa';
console.log(str.match(someSymbol)); // ["a", "aa"]`,
    subtitle6: `Ленивые и жадные квантификаторы`,
    text5: `У регулярного выражения бывает выбор: иногда подходят сразу две строки.
        Например, нужно найти строку, с первой буквой «э», последней «м» и от 2 до 11 символов в промежутке:`,
    code6: `const someSymbols = /э.{2,11}м/gi;
const str = 'Прогресс может оказаться совершенно безразличным к понятиям доброты и честности, как он был безразличен к этим понятиям до сих пор.';
console.log(str.match(someSymbols)); // ["этим понятиям"]`,
    text6: `Мы получили «этим понятиям». Но ведь и слово «этим» тоже подходит под регулярное выражение.
        Оно начинается на «э», заканчивается на «м» и содержит 2 буквы между первой и последней.
        Получается, движок предпочёл более длинное совпадение более короткому. Такое поведение называют «жадным».
        И это поведение квантификатора {} по умолчанию
        Ленивый квантификатор предпочтёт короткий вариант. Чтобы сделать квантификатор {} ленивым, поставьте после него знак вопроса: {}?.`,
    code7: `const someSymbols = /э.{2,11}?м/gi;
const str = 'Прогресс может оказаться совершенно безразличным к понятиям доброты и честности, как он был безразличен к этим понятиям до сих пор.';
console.log(str.match(someSymbols)); [ "этим" ] /* ленивый квантификатор нашёл самое короткое совпадение и дальше даже проверять не стал */`,
    text7: `Аналогично можно сделать ленивым квантификатор плюс +`,
    code8: `const someSymbols = /э.+?м/gi;
const str = 'Прогресс может оказаться совершенно безразличным к понятиям доброты и честности, как он был безразличен к этим понятиям до сих пор.';
console.log(str.match(someSymbols)); [ "этим" ]`,
  },
];
