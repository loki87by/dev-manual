export const SECURITY = [
  {
    title: `Межсайтовый скриптинг (XSS)`,
    text1: `Первый тип атак, с которым мы разберёмся — межсайтовый скриптинг (cross-site scripting). Вы уже встречались с этими атаками, когда знакомились со свойством innerHTML. Тогда мы рассказывали историю о Сэмми, который воспользовался недосмотром разработчиков
MySpace, собрал за несколько часов миллион друзей и «положил» тем самым сервер соцсети.
И хотя истории Сэмми уже больше 14 лет, XSS по-прежнему входит в десятку самых опасных уязвимостей веб-приложений.
Суть XSS-атак в том, чтобы внедрить вредоносный код в страницу, которую сервер отдаёт пользователю. Сэмми отредактировал свою страницу на MySpace, внедрив в неё вредоносный код. MySpace сохранил эту страницу у себя на сервере и выдавал другим пользователям.
Вредоносный код запускался у них на компьютерах и творил бесчинства.`,
    subtitle1: `Если отказаться от innerHTML, всё будет хорошо?`,
    text2: `К сожалению, нет. Есть множество способов осуществить межсайтовый скриптинг.
Виктор оставляет на сайте отзыв и передаёт внутри запроса имя:`,
    code1: {
      lang: "bash",
      value: `http://example.com/?name=Виктор`,
    },
    text3: `Сервер обрабатывает запрос, выкладывает отзыв и подписывает его переданным именем:`,
    code2: `const express = require('express');
const app = express();
// код для передачи отзыва
app.get('/', (req, res) => {
  res.send(\`Автор отзыва: \${req.query.name}\`);
});
app.listen(3000);`,
    text4: `Эту логику могут использовать хакеры. В ссылку можно вставить вредоносный код, а потом как-то вынудить другого пользователя эту ссылку открыть: сообщением о выигрыше в лотерею, скидкой 99% на автомобиль или предложением изменить размеры какого-нибудь органа:`,
    code3: `// Такая ссылка может прийти в письме «Перейдите по ссылке, чтобы получить свой выигрыш!»
http://example.com/?name=Виктор+<script>alert('Hacked!');</script>`,
    text5: `Мы в примере просто показываем окно с сообщением "Hacked", но хакеры предпочитают код повреднее.`,
    subtitle2: `Кто поможет, кто защитит?`,
    text6: `В борьбе с киберпреступностью вы не одиноки. Наш пример не сработает в браузерах на движке chromium: Яндекс-браузере, Гугл-хроме.
В самом движке предусмотрена защита, так что попытка открыть такую ссылку приведёт к ошибке: "The XSS Auditor refused to execute a script in 'http://example.com/?name=Viktor+<script>alert('Hacked!');</script>' because its source code was found within the request. The auditor was enabled as the server did not send an 'X-XSS-Protection' header." Что означает «XSS-аудитор отклонил выполнение скрипта на странице http://example.com/?name=Viktor+<script>alert('Hacked!');</script>', поскольку в запросе был найден исполняемый код. Аудитор включён, поскольку сервер не отправил заголовок „X-XSS-Protection“». Но в Internet Explorer никакой ошибки не выдаст, а послушно выполнит вредоносный код. Да и на хромиумы полагаться не стоит, от такого кода они не защитят:`,
    code4: `http://example.com/?name=Виктор+<b><a href="http://сайтхакера">YOU WON $100000</a>`,
    text7: `Хакер может пойти ещё дальше: сократить ссылку специальным сервисом, исполнить скрипт на компьютере пользователя и перенаправить его на исходный сайт. Так пользователь и не заметит, что произошло что-то неладное.`,
  },
  {
    title: `Что же делать?`,
    subtitle1: `Ограничивать пользовательский ввод`,
    text1: `Для этого применяют принцип «Что не разрешено — запрещено». Он заключается в том, чтобы заранее установить разрешённые для ввода символы в каждое поле: поле «автор» может содержать только кириллические буквы и пробел, номер телефона — цифры, знак «плюс» и скобки, email — латинские буквы, цифры, нижние подчёркивания, дефисы, точки и символ «собака». Если пользователь вводит неразрешённые символы, сайт либо их отбрасывает, либо сообщает об ошибке.`,
    subtitle2: `Экранировать символы`,
    text2: `Иногда нам нужно отправить символы, которые используются злоумышленниками. Например, < и > могут быть знаками «меньше» и «больше», а не границами тега. В этом случае мы не можем запретить их для ввода. В этом случае символы следует экранировать, тогда браузер не станет воспринимать их как код. Поэтому экранирование защищает от внедрения скриптов.`,
    subtitle3: `Экранирование символов в HTML`,
    text3: `Допустим, мы сделали сервис для решения математических неравенств. Пользователь отправляет пример:`,
    code1: `"x * 2 < 4";`,
    text4: `Сервер решает неравенство и возвращает ответ:`,
    code2: `"Неравенство x * 2 < 4 верно при x < 2";`,
    text5: `Мы не можем запретить символ <, но можем его экранировать. Для этого его следует заменить на символ с кодовым обозначением — мнемоникой. Для знака «меньше» это &lt;. Получится такая строка:`,
    code3: {
      lang: "bash",
      value: `"Неравенство x * 2 &lt; 4 верно при x &lt; 2";`,
    },
    text6: `Если злоумышленник отправит на сервер скрипт, мы не станем беспокоиться, что тот будет исполнен на компьютере пользователя.
Ведь все символы экранированы и браузер этот скрипт не запустит:`,
    code4: {
      lang: "javascript",
      value: `// Злоумышленник отправил:
Виктор+<script>alert('Hacked!');</script>
// Пользователь получил:
Виктор+&lt;script&gt;alert('Hacked!');&lt;/script&gt;`,
    },
    subtitle4: `Экранирование на практике`,
    text7: `В node.js уже есть модуль, подставляющий мнемоники: escape-html. Его можно импортировать в проект и использовать в коде:`,
    code5: `const escape = require('escape-html');`,
    text8: `Переменная escape содержит в себе функцию, которая принимает на вход строку со спецсимволами и заменяет их на мнемоники:
escape('<script>alert("hacked")</script>');
// '&lt;script&gt;alert(&quot;hacked&quot;)&lt;/script&gt;`,
  },
  {
    title: `Content Security Policy`,
    text1: `Основная защита от XSS — правильно написанный код веб-приложения: с ограниченным вводом и экранированием символов.
Но бывает всякое, и злоумышленник всё равно может найти способ внедрить скрипт в браузер пользователя.
На этот случай есть вторая линия защиты — инструкция Content Security Policy.
Эта инструкция позволяет ограничить источники, откуда сайт может загружать скрипты, изображения, файлы стилей и медиафайлы.
Есть два варианты установить инструкцию:`,
    subtitle1: `В метатеге. Можно добавить в раздел head тег meta и описать ограничения там:`,
    code1: `<meta http-equiv="Content-Security-Policy" content="ИНСТРУКЦИИ">`,
    subtitle2: `В HTTP-заголовке:`,
    code2: {
      lang: "javascript",
      value: `Content-Security-Policy: /* ИНСТРУКЦИИ */`,
    },
    subtitle3: `Как оформить инструкции`,
    text2: `Есть 5 видов инструкций:`,
    text3: `      default-src — обязательная инструкция, задаёт источник всех видов ресурсов по умолчанию;
      script-src — источник скриптов;
      img-src — изображений;
      media-src — аудио- и видео-файлов;
      style-src — файлов стилей.`,
    text4: `После имени инструкции указывают сами источники через пробел. Чтобы указать домен как источник, устанавливают ключевое слово 'self'.`,
    code3: {
      lang: "javascript",
      value: `"script-src 'self' *.site.com"; // скрипты можно загружать с самого сайта, либо с поддоменов site.com, например, с https://example.site.com`,
    },
    text5: `В конце каждой инструкции должна стоять точка с запятой:`,
    code4: {
      lang: "javascript",
      value: `Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com`,
    },
  },
  {
    title: `Контроль версии браузера`,
    text1: `Более новые браузеры обычно лучше защищены. Поэтому во имя безопасности можно запретить вход на сайт со старых браузеров.
Браузер отправляет свою версию в любом запросе внутри заголовка User-Agent. Этот заголовок имеет формат:`,
    code1: `User-Agent: <product> / <product-version> <comment>`,
    text2: `Например:`,
    code2: {
      lang: "bash",
      value: `user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36`,
    },
    text3: `Не пускать пользователя со старого браузера хорошо для безопасности. Но для пользователя это неудобно.
Это противоречие обуславливает два подхода:
поддерживать максимально возможное число браузеров, вплоть до старых версий Internet Explorer;
не пускать пользователей старых браузеров.
Второй подход используют Вконтакте:`,
    image: "image62.png",
    text4: `Какой подход выбрать — решать команде сервиса. Всегда взвешивайте, что важнее: безопасность или дружелюбие к пользователю.`,
    subtitle1: `Итого`,
    text5: `При любой XSS-атаке хакеры пользуются тем, что данные от пользователей попадают на сервер, а затем — обратно в браузер без каких-либо проверок. Поэтому чтобы защититься от XSS-атак:`,
    text6: `      По возможности не передавайте параметры в URL. Используйте POST для отправки данных форм.
      Экранируйте спецсимволы при получении и отображении данных.
      Устанавливайте Content Security Policy HTTP-заголовки или Meta-тэги.
      Контролируйте пользовательский ввод согласно принципу «что не разрешено — запрещено».
      Напоминайте посетителям обновить браузер.`,
  },
  {
    title: `Способы хранения JWT в браузере`,
    text1: `В предыдущей теме мы разбирали хранение JWT в localStorage. Это хороший способ, потому что с локальным хранилищем удобно работать.
Однако, у него есть большой недостаток — низкий уровень безопасности. Локальное хранилище доступно из JavaScript, поэтому при успешной XSS-атаке злоумышленник может украсть токен и совершать действия от лица пользователя.
Как бы хорошо ни был защищён сервер, он всё равно может быть подвержен XSS-атаке. Если на сайте много зависимостей, в одной из них может оказаться вредоносный код. Поэтому дополнительная защита токена не помешает.`,
    subtitle1: `Куки`,
    text2: `Данные в браузере можно сохранять в так называемые куки. Это фрагменты данных, относящихся к определённому домену.
Чтобы записать данные в куки браузера, сервер должен отправить заголовок Set-Cookie:`,
    code1: {
      lang: "javascript",
      value: `res.set('Set-Cookie', 'name=Стас');`,
    },
    text3: `Получив такой заголовок, браузер сохранит name=value в куках.
Вручную устанавливать куки неудобно. Зато это удобно делать в express — тут для этого есть метод res.cookie:`,
    code2: {
      lang: "javascript",
      value: `res.cookie('name', 'Стас');`,
    },
    text4: `Первый аргумент — это ключ, второй — значение.
Метод res.cookie особенно удобен для отправки опций, контролирующих поведение кук.
К примеру, куки являются сессионными по умолчанию. То есть, когда пользователь закрывает страницу — они удаляются.
Это поведение можно изменить, отправив опцию maxAge. Она хранит срок жизни куки:`,
    code3: {
      lang: "javascript",
      value: `// такая кука будет храниться час
res.cookie('name', 'Стас', { maxAge: 3600000 });
// а такая 7 дней
res.cookie('name', 'Стас', { maxAge: 3600000 * 24 * 7 });`,
    },
    text5: `Также по умолчанию к кукам есть доступ из JavaScript. Но в отличие от localStorage, это можно изменить опцией httpOnly:`,
    code4: {
      lang: "javascript",
      value: `res.cookie('name', 'Стас', {
  maxAge: 3600000,
  httpOnly: true
});`,
    },
    text6: `Такую куку нельзя прочесть из JavaScript. Защитим токен:`,
    code5: {
      lang: "javascript",
      value: `// отправим токен, браузер сохранит его в куках
res
  .cookie('jwt', token, {
    // token - наш JWT токен, который мы отправляем
    maxAge: 3600000,
    httpOnly: true
  })
  .end(); // если у ответа нет тела, можно использовать метод end`,
    },
    text7: `JWT сохранится в куках, к которым у JavaScript кода не будет доступа. А значит, токен не украсть при XSS-атаке.
А о том, как создавать токен на сервере мы расскажем в одной из следующих тем.`,
    subtitle2: `Говорим fetch отправлять куки`,
    text8: `Мы сохранили данные в куках, у которых нет доступа из JS кода, но запросы мы посылаем из JavaScript, используя fetch. Как быть?
Браузер автоматически пошлёт куки, если фронтенд и бэкенд работают на одном домене.
То есть если express сервер отвечает и за API и за раздачу фронтенда, то куки будут отправлены.
Если фронтенд и бэкенд работают на разных доменах, например, фронтенд мы разместили на Github Pages, а бэкенд ещё где-то, то в fetch нужно включить опцию credentials:`,
    code6: {
      lang: "javascript",
      value: `fetch('/posts', {
  method: 'GET',
  credentials: 'include', // теперь куки посылаются вместе с запросом
});`,
    },
    text9: `И браузер пошлёт куки в специальном заголовке Cookie.`,
    subtitle3: `Разбираем сookie на сервере`,
    text10: `С отправкой кук разобрались, переходим к их чтению на сервере. Для этого нужно извлечь данные из заголовка Cookie и затем разобрать полученную строку в объект. Это удобно сделать модулем cookie-parser. Установите его перед использованием и подключите как мидлвэр:`,
    code7: {
      lang: "javascript",
      value: `const express = require('express');
const cookieParser = require('cookie-parser');
const app = express();
app.use(cookieParser()); // подключаем парсер кук как мидлвэр`,
    },
    text11: `Теперь куки доступны в объекте req.cookies:`,
    code8: `const express = require('express');
const cookieParser = require('cookie-parser');
const app = express();
app.use(cookieParser());
app.get('/posts', (req, res) => {
  conole.log(req.cookies.jwt); // достаём токен
});`,
    subtitle4: `Проблемы такого подхода`,
    text12: `Подход httpOnly не защищает токен от XSS полностью. Если злоумышленнику удастся внедрить JS-код на сайт, он сможет отправить авторизованный запрос к серверу — так же как его отправляем мы. Но важно, что злоумышленник не сможет прочитать информацию, которая хранится в httpOnly-куке: он не сможет загрузить её к себе на сервер и проанализировать.`,
    subtitle5: `Ссылки`,
    link: {
      uri: "https://expressjs.com/ru/api.html#res.cookie",
      text: "Документация метода res.cookie",
    },
    link: {
      uri: "https://github.com/expressjs/cookie-parser",
      text: "Документация модуля cookie-parser",
    },
  },
  {
    title: `Межсайтовая подделка запроса (CSRF)`,
    text1: `В прошлом уроке мы изменили место хранения JWT: вместо localStorage стали использовать куки. Хотя мы и решили проблему доступности токена из JS-кода, появилась другая проблема — уязвимость к CSRF-атаке. CSRF-атака (Cross Site Request Forgery, англ. «межсайтовая подделка запроса») построена на том, что вместе с http-запросом браузер посылает куки соответствующего домена.
Если обратиться к сайту с другого домена, браузер всё равно отправит куки. Так злоумышленник может разместить на своём сайте форму, которая отправляет запрос на наш сервер. Пользователь зайдёт на этот вредоносный сайт, и от его имени будет отправлен авторизованный запрос на наш домен.`,
    subtitle1: `Это ужасно. Как защититься?`,
    text2: `Самый простой способ защиты от автоматической отправки кук — указать браузеру, чтобы тот посылал куки, только если запрос сделан с того же домена. Для этого есть опция sameSite:`,
    code1: {
      lang: "javascript",
      value: `res
  .cookie('jwt', token, {
    maxAge: 3600000,
    httpOnly: true,
    sameSite: true // добавили опцию
  })
  .end(); // если у ответа нет тела, можно использовать метод end`,
    },
    text3: `Так большинство пользователей оказываются защищены. Мы говорим «большинство», потому что same site — относительно новая опция, и в старых браузерах она не работает. Поэтому пользователей, у которых браузер не поддерживает sameSite, лучше попросить обновиться.`,
  },
  {
    title: `Использование внешних компонентов`,
    text1: `При разработке мы часто пользуемся внешними инструментами: загружаем библиотеки и файлы стилей, подключаем зависимости.
Такие инструменты удобны и упрощают жизнь разработчику. Но вместе с удобством приходят и потенциальные угрозы безопасности.
В этом уроке разберём, какие и как с этим быть.`,
    subtitle1: `Подключение внешних компонентов тегом <script>`,
    text2: `Многие библиотеки подключаются тегом <script> со ссылкой на сайт производителя библиотеки:`,
    code1: `<script src="https://code.jquery.com/jquery.slim.min.js"></script>`,
    text3: `Такой подход опасен, поскольку мы не контролируем чужой сервер: файл может быть изменён, и в нём могут появиться уязвимости.
Первый шаг в защите от изменений — явно указывать версии подключаемых компонентов.
Ссылка с указанием версии более надёжна, чем без указания:`,
    backState: "first-wrong_second-true",
    table: {
      title: ["МЕНЕЕ БЕЗОПАСНО", "БОЛЕЕ БЕЗОПАСНО"],
      td1: [
        `https://code.jquery.com/jquery.slim.min.js`,
        `https://code.jquery.com/jquery-3.4.1.slim.min.js`,
      ],
    },
    text4: `Ещё надежнее загружать код модуля в директорию с проектом и указывать локальный путь: /vendor/jquery-3.4.1.slim.min.js.
Но если модуль большой, такой подход чреват не только дублированием кода, но и увеличением кодовой базы и, как следствие, ростом времени сборки проекта.`,
    subtitle2: `Хеши против подмены файла`,
    text5: `Файлы можно заищитить ключом: так при загрузке браузер проверит, скачивает ли он тот самый файл, который мы указывали в процессе разработки. Для этого у тегов <script> и <link> есть атрибут integrity. В него записывают хеш-сумму — ключ, который рассчитывается, исходя из содержания файла. При скачивании файла с внешнего ресурса браузер рассчитает хеш-сумму файла и загрузит его, только если полученная сумма совпадает с той, что указана в атрибуте integrity. Это гарантирует, что файл не изменился.`,
    code2: `<script
  src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
  integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
  crossorigin="anonymous"
>
</script>`,
    text6: `Перед самой хеш-суммой через тире указывают алгоритм, по которому её следует рассчитывать, в нашем случае — sha384. Хеш-сумму файла нужно заранее посчитать.`,
    link: {
      uri: "https://www.srihash.org/",
      text: "Это можно сделать в специальном сервисе",
    },
    text7: `Атрибут crossorigin="anonymous" означает, что при запросе не будут передаваться никакие данные пользователя, даже если он авторизован на том сервере, с которого запрашивается файл.`,
    subtitle3: `Блокировка npm-зависимостей`,
    text8: `Уязвимости могут появиться и в новых версиях npm-пакетов, подключённых к проекту. Поэтому зависимости также следует контролировать.
В версии о вебпаке мы описывали зависимости в файле package.json. Для этого в терминале мы вызывали команду npm install, и в package.json появлялась новая зависимость:`,
    code3: `"bcryptjs": "^2.4.3"`,
    text9: `Перед номером версии стоит шляпка ^. Это значит, что если есть более новая версия с такими же первыми двумя цифрами и большей третьей, следует взять самую свежую версию. То есть установить не 2.4.3, а 2.4.4, если она доступна.
Что плохого в таком подходе:
у разных разработчиков могут быть разные версии зависимостей;
мы можем установить повышенную версию зависимости без своей на то воли.
Чтобы избежать подобного, в пятой версии npm появилась возможность зафиксировать зависимости.
Для этого в специальном файле package-lock.json перечисляют те пакеты, которые нужно установить строго в указанных версиях.
Это исключает апдейт версии без ведома разработчика. Если у вас в проекте нет package-lock.json, проверьте версию npm командой npm -v. Если версия ниже пятой — обновите npm командой npm install npm@latest -g.
Если установлена пятая или более новая версия npm , но package-lock.json всё равно нет, вызовите в терминале команду:`,
    code4: {
      lang: "bash",
      value: `npm config set package-lock true`,
    },
    text10: `или установите зависимости с ключом --package-lock:`,
    code5: {
      lang: "bash",
      value: `npm install --package-lock`,
    },
    subtitle4: `Проверка безопасности зависимостей`,
    text11: `В шестой версии npm появился инструмент для анализа безопасности пакетов. Чтобы воспользоваться им, запустите команду npm audit, находясь в папке проекта. Так npm сообщит о зависимостях, в которых есть уязвимости.`,
    subtitle5: `Github Security Alert`,
    text12: `Чтобы постоянно отслеживать уязвимости в пакетах, есть специальные инструменты. Они позволяют не вводить команду npm audit, поскольку берут мониторинг уязвимостей на себя.
Каждый сервис контроля версий разрабатывает собственный инструмент для контроля безопасности пакетов.
Например, в Gitlab есть функция Dependency Scanning, а в Github — Security Alert.
Чтобы подключить Github Security Alert, зайдите в репозиторий на Github, откройте настройки (Settings) и поставьте соответствующую галочку:`,
    image1: "image63.png",
    text13: `Если одна из зависимостей имеет известную уязвимость, на главной странице репозитория появится уведомление:`,
    image2: "image64.png",
    text14: `Чтобы узнать, какая именно зависимость небезопасна, кликните на View security alert:`,
    image3: "image65.png",
    text15: `Также тут можно открыть подробности: в чём суть уязвимости и до какой версии следует обновиться.`,
    image4: "image66.png",
    subtitle6: `Базы данных уязвимостей`,
    text16: `Угрозы безопасности также собирают в открытых базах данных. Любой компонент следует проверять на уязвимости по таким базам, чтобы оградить от злоумышленников свой проект. CVE Details — одна из крупнейших открытых баз данных общеизвестных уязвимостей.
Все компоненты следует проверять по этой базе, прежде чем использовать их в проекте. Можно искать по имени компании, продукта или типам уязвимостей. Разумеется, если компонента нет в базе, это не означает, что тот безопасен. Ведь в базу уязвимость попадает уже после того, как она была найдена. То есть тогда, когда ей кто-то воспользовался, и соответственно — пострадал.`,
  },
  {
    title: `Заключение. Чеклист безопасности`,
    text1: `Вот чеклист для проверки своего проекта. Проходитесь по нему перед тем, как вашим кодом начнут пользоваться реальные люди.
В одной из следующих тем мы расскажем об ещё одном пункте этого чеклиста — хранении ключей.`,
    subtitle1: `✅ Настройте заголовки ответа`,
    text2: `Есть ряд заголовков, отвечающих за разные аспекты безопасности: вы уже знакомы с Content-Security-Policy, которые позволяют ограничить источники скрипторв и других ресурсов.
Заголовки безопасности можно проставлять автоматически — для этого есть модуль Helmet.
Нужно установить его, импортировать и подключить как мидлвэр:`,
    code1: {
      lang: "javascript",
      value: `const helmet = require('helmet');
app.use(helmet());`,
    },
    link: {
      uri: "https://www.npmjs.com/package/helmet",
      text: "Документация Helmet",
    },
    subtitle2: `✅ Проверяйте, какие данные присылает пользователь`,
    text3: `Валидируйте данные на входе и заменяйте управляющие символы мнемониками.
Если фронтенд вставляет их в сайт небезопасно, пользуйтесь escape-html.`,
    subtitle3: `✅ Задумывайтесь о том, где хранятся данные на клиенте`,
    text4: `LocalStorage удобен и прост: он отлично подойдёт для хранения данных, которые нет нужды скрывать.
Но к localStorage есть доступ из JavaScript-кода, и это поведение нельзя запретить.
Поэтому для хранения секретных данных лучше подходят httpOnly куки.`,
    subtitle4: `✅ Помните о CSRF`,
    text5: `Если ваш сервис при авторизации запросов опирается на автоматическую отправку кук браузером, реализуйте хотя бы простейшую защиту от CSRF. В этом поможет опция same site.`,
    subtitle5: `✅ Будьте готовы к брутфорсу и DDоSу`,
    text6: `Чтобы защититься от множества автоматических запросов, воспользуйтесь специальным мидлвэром — express-rate-limit.
Он ограничивает количество запросов с одного IP-адреса в единицу времени.
После установки его можно импортировать, сконфигурировать и подключить:`,
    code2: {
      lang: "javascript",
      value: `const express = require('express');
const rateLimit = require('express-rate-limit');
const app = express();
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // за 15 минут
  max: 100 // можно совершить максимум 100 запросов с одного IP
});
// подключаем rate-limiter
app.use(limiter);`,
    },
    link: {
      uri: "express-rate-limit: https://www.npmjs.com/package/express-rate-limit",
      text: "Документация модуля",
    },
    subtitle6: `✅ Проверьте зависимости`,
    text7: `Запускайте команду npm audit, прежде чем выкатывать проект в продакшн. Также настройте Security Alert на платформе, где храните код.`,
    subtitle7: `✅ Не останавливайтесь`,
    text8: `Безопасность — неисчерпаемая тема. Крупные компании отдельно нанимают специалистов по информационной безопасности, чтобы защитить свои сервисы от атак. Это логично, ведь у таких компаний очень высокие ставки.`,
  },
  {
    title: `Дополнительные материалы спринта`,
    link: {
      uri: "https://medium.com/webbdev/23-%D1%80%D0%B5%D0%BA%D0%BE%D0%BC%D0%B5%D0%BD%D0%B4%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B5-node-js-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-e3fbc348f92",
      text: "Статья «23 рекомендации по защите Node.js приложений»",
    },
    link: {
      uri: "https://expressjs.com/ru/advanced/best-practice-security.html",
      text: "«Включите Helmet» и другие рекомендации по безопасности от express",
    },
    link: {
      uri: "https://blog.risingstack.com/node-js-security-checklist/",
      text: "Чеклист безопасности для Node.js приложения",
    },
    text: `Опасности подстерегают, даже если мы устанавливаем известный и проверенный npm-пакет. В 2018 у популярного npm-модуля event-stream
сменился разработчик. Он внедрил в event-stream бэкдор. Это был вредоносный код, позволяющий получить доступ к компьютеру,
на котором вирус был запущен. Этот бэкдор сообщество не могло обнаружить 2 месяца.`,
    link: {
      uri: "https://habr.com/ru/post/431360/",
      text: "Вот подробная статья с его описанием.",
    },
    link: {
      uri: "https://thecode.media/hash-brown/",
      text: "Статься о хешировании паролей",
    },
  },
  {
    title: `Создание и хранение секретных ключей`,
    text1: `В предыдущем уроке мы генерировали JWT так:`,
    code1: {
      lang: "javascript",
      value: `const token = jwt.sign({ _id: user._id }, 'super-strong-secret');`,
    },
    text2: `Как вы думаете, 'super-strong-secret' — это хороший секретный ключ? На самом деле, не очень.
Он состоит из осмысленных английских слов, такой секретный ключ подобрать проще, чем длинную комбинацию случайных символов.
И тут возникает вопрос: какой длины ключа достаточно, чтобы его нельзя было подобрать?`,
    subtitle1: `Криптостойкие псевдослучайные данные`,
    text3: `Что это значит:
Криптостойкость означает, что данные генерируются алгоритмом, который не поддаётся анализу.
Проще говоря, на подбор ключа уйдут сотни лет;
Псевдослучайность означает, что символы очень похожи на случайные, но всё же сформированы математическим алгоритмом.
Псевдослучайные данные гораздо проще генерировать, но почти также сложно подобрать. Поэтому они удовлетворяют нашей задаче.
Секретный ключ должен быть криптостойким и псевдослучайным.
Также нужно определиться с длиной пароля. Обычно сходятся на том, что оптимальный ключ должен быть последовательностью символов, которые в двоичном виде представляют собой цепочку нулей и единиц длиной 128 или 256 символов.
В Node.js есть встроенный модуль crypto, который генерирует такой ключ. На вход он принимает количество байт ключа, а не бит.
Поскольку в одном байте 8 бит, для получения 128-битного ключа нужно передать методу crypto на вход 16:`,
    code2: `const crypto = require('crypto'); // экспортируем crypto
const randomString = crypto
  .randomBytes(16) // сгенерируем случайную последовательность 16 байт (128 бит)
  .toString('hex'); // приведём её к строке
console.log(randomString); // 5cdd183194489560b0e6bfaf8a81541e`,
    text4: `Такой код писать не нужно, ведь ключ нужно сгенерировать единожды. Можно просто сделать это в консоли.
Такое выражение сгенерирует 256-битный (32-байтный) ключ и выведет его в консоль:`,
    code3: {
      lang: "bash",
      value: `node -e "console.log(require('crypto').randomBytes(32).toString('hex'));"`,
    },
    text5: `Такой ключ нельзя подобрать методом перебора и за сотню лет.
Конечно, есть вероятность, что завтра человечество изобретёт невероятно мощный компьютер, подбирающий такие ключи за секунды.
Если это произойдёт, мы вас предупредим. А пока 256-битного ключа достаточно.`,
    subtitle2: `Где хранить ключи`,
    text6: `Когда ключ сгенерирован, его нужно сохранить. В одном из предыдущих уроков, для примера мы держали его прямо в коде:`,
    code4: {
      lang: "javascript",
      value: `// super-strong-secret хранится прямо в коде
const token = jwt.sign({ _id: user._id }, 'super-strong-secret');`,
    },
    text7: `Никогда так не делайте, иначе вся криптостойкость и псевдослучайность окажется бесполезной: ключ просто украдут.
Обычно код хранят в удалённом репозитории, к которому есть доступ у множества людей: фронтенд- и бэкенд-разработчиков, продакт- и проджект-менеджеров, клиентов. Компьютер любого из них может быть взломан, а пострадают от этого пользователи.
Так что чем меньше людей имеют доступ к ключу, тем безопаснее.
Поэтому секретный ключ хранят только на сервере, где запущено приложение.
Ключ заносят в переменные окружения. Для этого создают файл с расширением .env в корне проекта, и в нём объявляют env-переменные:`,
    code5: `NODE_ENV=production
JWT_SECRET=eb28135ebcfc17578f96d4d65b6c7871f2c803be4180c165061d5c2db621c51b`,
    text8: `Чтобы загрузить этот файл в Node.js, нужно установить в проект модуль dotenv и импортировать его как можно раньше в app.js таким образом:`,
    code6: {
      lang: "javascript",
      value: `// app.js
require('dotenv').config();`,
    },
    text9: `После этого env-переменные из файла добавятся в process.env:`,
    code7: {
      lang: "javascript",
      value: `// app.js
require('dotenv').config();
console.log(process.env.NODE_ENV); // production`,
    },
    text10: `К ним можно обращаться при генерации токена:`,
    code8: {
      lang: "javascript",
      value: `const { NODE_ENV, JWT_SECRET } = process.env;
const token = jwt.sign(
  { _id: user._id },
  NODE_ENV === 'production' ? JWT_SECRET : 'dev-secret'
);`,
    },
    text11: `.env файл не нужно коммитить, поэтому его следует добавить в .gitignore:`,
    code9: `.env`,
    link: {
      uri: "https://www.npmjs.com/package/dotenv",
      text: "Документация модуля dotenv",
    },
  },
];
