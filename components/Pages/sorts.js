export const SORT_ALGORHITMS = [
  {
    title: `Пузырьковая сортировка и её улучшения`,
    subtitle1: `Сортировка пузырьком`,
    image1: "image1.gif",
    text1: `Сортировка пузырьком — один из самых известных алгоритмов сортировки. Здесь нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.
    Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы (их называют «черепахами») стоят в конце массива. Однако на нём основаны многие другие методы, например, шейкерная сортировка и сортировка расчёской.`,
    subtitle2: `Сложность по времени:`,
    text2: `Худшее время: O(N²),
    Среднее время: O(N²),
    Лучшее время: O(N)`,
    subtitle3: `Затраты памяти:`,
    text3: `O(1)`,
    code1: {
      lang: "c",
      value: `void BubbleSort(vector<int>& values) {
  for (size_t idx_i = 0; idx_i + 1 < values.size(); ++idx_i) {
    for (size_t idx_j = 0; idx_j + 1 < values.size() - idx_i; ++idx_j) {

      if (values[idx_j + 1] < values[idx_j]) {
        swap(values[idx_j], values[idx_j + 1]);
      }
    }
  }
}`,
    },
    subtitle4: `Сортировка перемешиванием (шейкерная сортировка)`,
    image2: "image2.gif",
    text4: `Шейкерная сортировка отличается от пузырьковой тем, что она двунаправленная: алгоритм перемещается не строго слева направо, а сначала слева направо, затем справа налево.`,
    subtitle5: `Сложность по времени:`,
    text5: `Худшее время: O(N²),
    Среднее время: O(N²),
    Лучшее время: O(N)`,
    subtitle6: `Затраты памяти:`,
    text6: `O(1)`,
    code2: {
      lang: "c",
      value: `void ShakerSort(vector<int>& values) {

  if (values.empty()) {
    return;
  }
  int left = 0;
  int right = values.size() - 1;
  while (left <= right) {
    for (int i = right; i > left; --i) {

      if (values[i - 1] > values[i]) {
        swap(values[i - 1], values[i]);
      }
    }
    ++left;
    for (int i = left; i < right; ++i) {

      if (values[i] > values[i + 1]) {
        swap(values[i], values[i + 1]);
      }
    }
    --right;
  }
}`,
    },
    subtitle7: `Сортировка перемешиванием (шейкерная сортировка)`,
    image3: "image3.gif",
    text7: `Сортировка расчёской — улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.
    Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины — фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247; на каждом последующем шаге расстояние будет снова делиться на фактор уменьшения — и так до окончания работы алгоритма.`,
    subtitle8: `Сложность по времени:`,
    text8: `Худшее время: O(N²),
    Среднее время: Ω(N²/2ⁿ), где n - количество инкрементов,
    Лучшее время: O(N log N)`,
    subtitle9: `Затраты памяти:`,
    text9: `O(1)`,
    code3: {
      lang: "c",
      value: `void CombSort(vector<int>& values) {
  const double factor = 1.247; // Фактор уменьшения
  double step = values.size() - 1;

  while (step >= 1) {
    for (int i = 0; i + step < values.size(); ++i) {

      if (values[i] > values[i + step]) {
        swap(values[i], values[i + step]);
      }
    }
    step /= factor;
  }
  // сортировка пузырьком
  for (size_t idx_i = 0; idx_i + 1 < values.size(); ++idx_i) {
    for (size_t idx_j = 0; idx_j + 1 < values.size() - idx_i; ++idx_j) {

      if (values[idx_j + 1] < values[idx_j]) {
        swap(values[idx_j], values[idx_j + 1]);
      }
    }
  }
}`,
    },
  },
  {
    title: `Простые сортировки`,
    subtitle1: `Сортировка вставками`,
    image1: "image4.gif",
    text1: `При сортировке вставками массив постепенно перебирается слева направо. При этом каждый последующий элемент размещается так, чтобы он оказался между ближайшими элементами с минимальным и максимальным значением.`,
    subtitle2: `Сложность по времени:`,
    text2: `Худшее время: O(N²) для сравнений и перестановок,
      Среднее время: O(N²) для сравнений и перестановок,
      Лучшее время: O(N) для сравнений и перестановок`,
    subtitle3: `Затраты памяти:`,
    text3: `O(n) основной O(1) дополнительный`,
    code1: {
      lang: "c",
      value: `void InsertionSort(vector<int>& values) {
  for (size_t i = 1; i < values.size(); ++i) {
    int x = values[i];
    size_t j = i;
    while (j > 0 && values[j - 1] > x) {
      values[j] = values[j - 1];
      --j;
    }
    values[j] = x;
  }
}`,
    },
    subtitle4: `Сортировка выбором`,
    image2: "image5.gif",
    text4: `Сначала нужно рассмотреть подмножество массива и найти в нём максимум (или минимум). Затем выбранное значение меняют местами со значением первого неотсортированного элемента. Этот шаг нужно повторять до тех пор, пока в массиве не закончатся неотсортированные подмассивы.`,
    subtitle5: `Сложность по времени:`,
    text5: `Худшее время: O(N²),
    Среднее время: O(N²),
    Лучшее время: O(N²)`,
    subtitle6: `Затраты памяти:`,
    text6: `O(n) основной O(1) дополнительный`,
    code2: {
      lang: "c",
      value: `void SelectionSort(vector<int>& values) {
  for (auto i = values.begin(); i != values.end(); ++i) {
    auto j = std::min_element(i, values.end());
    swap(*i, *j);
  }
}`,
    },
  },
  {
    title: `Эффективные сортировки`,
    subtitle1: `Быстрая сортировка`,
    image1: "image6.gif",
    text1: `Этот алгоритм состоит из трёх шагов. Сначала из массива нужно выбрать один элемент — его обычно называют опорным. Затем другие элементы в массиве перераспределяют так, чтобы элементы меньше опорного оказались до него, а большие или равные — после. А дальше рекурсивно применяют первые два шага к подмассивам справа и слева от опорного значения.
      Быструю сортировку изобрели в 1960 году для машинного перевода: тогда словари хранились на магнитных лентах, а сортировка слов обрабатываемого текста позволяла получить переводы за один прогон ленты, без перемотки назад.`,
    subtitle2: `Сложность по времени:`,
    text2: `Худшее время: O(N²),
      Среднее время: O(N log N),
      Лучшее время: O(N)`,
    subtitle3: `Затраты памяти:`,
    text3: `O(n)`,
    code1: {
      lang: "c",
      value: `int Partition(vector<int>& values, int l, int r) {
  int x = values[r];
  int less = l;
  for (int i = l; i < r; ++i) {

    if (values[i] <= x) {
      swap(values[i], values[less]);
      ++less;
    }
  }
  swap(values[less], values[r]);
  return less;
}
void QuickSortImpl(vector<int>& values, int l, int r) {

  if (l < r) {
    int q = Partition(values, l, r);
    QuickSortImpl(values, l, q - 1);
    QuickSortImpl(values, q + 1, r);
  }
}
void QuickSort(vector<int>& values) {

  if (!values.empty()) {
    QuickSortImpl(values, 0, values.size() - 1);
  }
}`,
    },
    subtitle4: `Сортировка слиянием`,
    image2: "image7.gif",
    text4: `Сортировка слиянием пригодится для таких структур данных, в которых доступ к элементам осуществляется последовательно (например, для потоков). Здесь массив разбивается на две примерно равные части и каждая из них сортируется по отдельности. Затем два отсортированных подмассива сливаются в один.`,
    subtitle5: `Сложность по времени:`,
    text5: `Худшее время: O(N log N),
    Среднее время: O(N log N),
    Лучшее время: O(N log N)`,
    subtitle6: `Затраты памяти:`,
    text6: `O(n) вспомогательной`,
    code2: {
      lang: "c",
      value: `void MergeSortImpl(vector<int>& values, vector<int>& buffer, int l, int r) {

  if (l < r) {
    int m = (l + r) / 2;
    MergeSortImpl(values, buffer, l, m);
    MergeSortImpl(values, buffer, m + 1, r);
    int k = l;
    for (int i = l, j = m + 1; i <= m || j <= r; ) {

      if (j > r || (i <= m && values[i] < values[j])) {
        buffer[k] = values[i];
        ++i;
      } else {
        buffer[k] = values[j];
        ++j;
      }
      ++k;
    }
    for (int i = l; i <= r; ++i) {
      values[i] = buffer[i];
    }
  }
}
void MergeSort(vector<int>& values) {

  if (!values.empty()) {
    vector<int> buffer(values.size());
    MergeSortImpl(values, buffer, 0, values.size() - 1);
  }
}`,
    },
    subtitle7: `Пирамидальная сортировка`,
    image3: "image8.gif",
    text7: `При этой сортировке сначала строится пирамида из элементов исходного массива. Пирамида (или двоичная куча) — это способ представления элементов, при котором от каждого узла может отходить не больше двух ответвлений. А значение в родительском узле должно быть больше значений в его двух дочерних узлах.`,
    image3: "image100.png",
    text8: `Пирамидальная сортировка похожа на сортировку выбором, где мы сначала ищем максимальный элемент, а затем помещаем его в конец. Дальше нужно рекурсивно повторять ту же операцию для оставшихся элементов.`,
    subtitle8: `Сложность по времени:`,
    text9: `Худшее время: O(N log N),
    Среднее время: O(N log N),
    Лучшее время: O(N log N) или O(N) при одинаковых ключах`,
    subtitle9: `Затраты памяти:`,
    text10: `O(n)`,
    code3: {
      lang: "c",
      value: `void HeapSort(vector<int>& values) {
std::make_heap(values.begin(), values.end());
for (auto i = values.end(); i != values.begin(); --i) {
std::pop_heap(values.begin(), i);
  }
}`,
    },
  },
];
