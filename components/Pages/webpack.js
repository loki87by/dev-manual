export const WEBPACK = [
  {
    title: `Установка NPM`,
    text1: `Поскольку NPM был придуман создателями Node.js, чтобы получить доступ к NPM-утилитам, Node.js нужно установить. Скачайте её с
официального сайта и поставьте на компьютер. Затем проверьте, что всё установилось правильно. Для этого введите в терминале команду:`,
    code1: `# проверим версию Node.js
node -v
# на этапе написания курса версия такая, она может отличатся от вашей
v12.16.3`,
    text2: `Раз Node.js установлена, то и NPM должен быть на месте. Проверить это можно так:
npm -v
# У вас появится такая же или более поздняя версия
6.11.2003`,
    subtitle1: `Как пользоваться NPM`,
    text3: `После установки NPM на вашем компьютере появились утилиты, которые умеют устанавливать библиотеки и инструменты в проект. Но этим
утилитам нужно знать, какие именно инструменты вам нужны. Список нужных инструментов прописывают в файле package.json. У него есть
строгие правила оформления. Чтобы о них не думать, можно создать package.json автоматически:`,
    code2: { lang: "bash", value: `npm init # в папке с проектом` },
    text4: `После этой команды терминал начнёт задавать вам вопросы о проекте. Вот их список, а также список наших ответов:
В результате получим вот такой файл package.json:`,
    code3: {
      lang: "javascript",
      value: `{
  "name": "yandex.praktikum",
  "version": "0.0.1",
  "description": "Learning platform",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Stas Basov",
  "license": ""
}`,
    },
    text5: `Если не захотите — можете не отвечать на все эти вопросы. Просто ничего не вводите и жмите Enter. Или сразу запустите команду вот так:`,
    code4: `npm init --yes`,
    text6: `Теперь, если вы зачем-то захотите добавить в проект библиотеку jQuery, сделаете это просто командой в терминале:`,
    code5: `# При этом нужно находиться в папке проекта
npm install jquery`,
    text7: `встроенные браузерные модули до сих пор используют редко.
Причины:
Не все браузеры поддерживают модули, поэтому иногда код пишут «по старинке».
Даже в браузерах, которые их поддерживают, функциональность модулей ограничена, а удобство работы с ними оставляет желать лучшего.
Но есть выход. Можно использовать модули при разработке, а перед загрузкой проекта в интернет собрать все получившиеся файлы в один и
подключить в HTML. К тому же в процессе такой сборки можно преобразовать код: сжать или сделать так, чтобы он работал в старых браузерах.
Поэтому разработка проектов обычно выглядит так: разработчик пишет код в отдельных модулях, а затем специальные инструменты
превращают модульный код в обычный. Такие инструменты называются сборщиками.`,
  },
  {
    title: `Что такое сборка?`,
    text1: `Сборка кода — это превращение всех ваших js- и css-файлов в один большой и подключение его в HTML. При этом код преобразуется:
JavaScript-код, написанный по новой спецификации, переделывается в точно такой же, но написанный по старой. Это позволяет пользоваться
всеми самыми современными инструментами языка и не беспокоиться о поддержке сайта старыми браузерами.
JavaScript и CSS минифицируются. Это значит, что внутри файла удаляются все пробелы, переносы строк и комментарии: браузеру они не нужны
, а файл с кодом становится короче и оттого — легче. Более лёгкий файл быстрее загрузится.
Вендорные префиксы тоже проставляются автоматически. Так что за поддержку css-кода старыми браузерами тоже можно не волноваться.
Сборку выполняют специальные программы-сборщики. Их несколько, например, Parcel, Rollup и Webpack. Последний
, «Вебпак», — самый популярный и гибкий инструмент, а потому и самый универсальный. Поэтому изучать мы будем его.
Если в будущем вам понадобятся знания других сборщиков, вы без труда их освоите, обладая навыками настройки «Вебпака».`,
  },
  {
    title: `Настраиваем сборку`,
    text1: `Cборка — процесс превращения множества файлов с кодом в один большой. У одного проекта может быть несколько сборок, по одной на цель.
Обычно в проекте 2 сборки: для разработки и для  пользователя. Разработка и использование — разные процессы, поэтому и требования разные:`,
    backState: true,
    table: {
      title: ["", "В СБОРКЕ ДЛЯ РАЗРАБОТКИ", "В СБОРКЕ ДЛЯ ИСПОЛЬЗОВАНИЯ"],
      td1: [
        `Старый синтаксис и вендорные префиксы`,
        `Не нужны. Они не несут полезной информации и засоряют код`,
        `Нужны. Закрывают проблему совместимости в разных браузерах.`,
      ],
      td2: [
        `Вебпак`,
        `Нужен. При изменении кода проект нужно собрать`,
        `Не нужен. Проект уже собран, не надо собирать его второй раз`,
      ],
    },
    text2: `«Вебпаку» нужно как-то объяснить, что в какую сборку включать, какие утилиты запускать и что делать с кодом.
Для всего этого есть специальные разделы внутри файла package.json. В уроке расскажем как раз об этих разделах, и как ими пользоваться.`,
    subtitle1: `Выбираем вид сборки. Раздел scripts`,
    text3: `Сборка кода осуществляется последовательностью команд. Каждая команда определяет действие: скопировать строки кода, удалить пробелы,
добавить префиксы. Получается длинная инструкция: какие файлы нужны, что с ними делать и куда в итоге всё складывать.
Сама логика каждой команды уже прописана под капотом у «Вебпака». Нам нужно организовать их в правильную последовательность — скрипт
Такие скрипты прописывают в разделе scripts файла package.json. «Из коробки» этот раздел выглядит так:`,
    code1: {
      lang: "javascript",
      value: `"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
}`,
    },
    text4: `Любой скрипт запускается командой npm run имя скрипта. В нашем файле package.json пока только один скрипт, он называется test. Запустим его:`,
    code2: `npm run test
# Появится сообщение об ошибке`,
    text5: `Нам такой скрипт не нужен — удалим его. И вместо него напишем скрипт для сборки проекта:`,
    code3: `"scripts": {
  "build": "webpack"
}`,
    text6: `Теперь у нас есть скрипт build. В него мы записали команду webpack.
Так мы скомандовали Node.js найти в папке node_modules модуль webpack и запустить его.`,
    subtitle2: `Не устанавливаем точку входа`,
    text7: `При модульном подходе у вас в проекте находится множество файлов. Одни файлы подключают к другим директивой import.
Во время сборки «Вебпак» заходит в файл и добавляет его код в итоговый код. Затем повторяет ту же операцию для каждого подключенного
через import файла. Так «Вебпак» собирает код всех файлов в один большой.
Но «Вебпаку» нужно как-то понять, куда идти в первую очередь, — точку входа. По умолчанию точка входа — файл index.js внутри папки src.
Поэтому создайте в папке своего проекта директорию src, а в ней — файл index.js.
Теперь всё готово к сборке. Запустите её командой npm run build.
В папке вашего проекта появится директория dist, а внутри неё — файл main.js. В этот файл попадает весь js-код вашего проекта.`,
    subtitle3: `Каждый раз новая сборка`,
    text8: `В течение этой темы вы настроите «Вебпак» так, что в папку dist будут попадать все файлы проекта: html, css, js, картинки, шрифты.
В процессе разработки проекта в нём могут появляться новые файлы, а старые, наоборот, удаляться.
Чтобы в папке dist не скапливались файлы, её лучше очищать перед каждой сборкой. Самый простой способ сделать это — добавить в скрипт
build удаление папки dist перед сборкой. Для этого допишите rm -rf dist && в build-скрипте:`,
    code4: `"scripts": {
  "build": "rm -rf dist && webpack", // добавили удаление папки
}`,
    text9: `Теперь перед каждой сборкой папка dist будет удаляться, а в сборку будут попадать только самые свежие файлы.`,
    subtitle4: `Настраиваем локальный сервер`,
    text10: `Директивы import и export не работают без сервера. Такова их внутренняя логика. Поэтому без сервера невозможно проверить,
как работает модульный код. На помощь приходит локальный сервер.
Это настоящий сервер у вас на компьютере, но подключиться к нему можете только вы. Для разработки как раз то, что нужно.
Устанавливаете локальный сервер → получаете все серверные возможности → в том числе и работу модулей.
В проектной работе прошлого спринта вы установили локальный сервер как расширение в текстовый редактор.
А сейчас установим локальный сервер как зависимость в проект. Такой локальный сервер интегрирован с «Вебпаком»: это упростит разработку.
Локальный сервер — тоже утилита. Её можно получить из NPM командой npm i webpack-dev-server --save-dev. Ещё один флаг, --open,
открывает проект в браузере сразу после сборки. После этого вы сможете открыть свой проект в браузере, введя адрес localhost:8080.`,
    subtitle5: `Создаём вторую сборку`,
    text11: `Одной сборки недостаточно. Мы не можем добавлять локальный сервер в финальную сборку — он нужен только при разработке.
Но и без локального сервера нам не обойтись. Всё, что остаётся, — создать отдельную сборку для разработки.
Для этого пропишем её в разделе scripts файла package.json:`,
    code5: `"scripts": {
  "build": "webpack",
  "dev": "webpack-dev-server --open"
}`,
    text12: `Теперь нам доступен ещё один скрипт — npm run dev. Команда webpack-dev-server запустит проект на локальном сервере.`,
    subtitle6: `Собираем проект`,
    text13: `Вызовите из терминала команду npm run dev. Откроется ваш проект на локальном сервере — по адресу localhost:8080.
Пока проект пустой, вы видите интерфейс для просмотра файлов на сервере, то есть файлов вашего проекта.
Обратите внимание: пока сервер работает, новых команд в Git bash создать не получится. Выхода два:
Завершить выполнение локального сервера. Для этого нажмите Ctrl + C. Если вы работаете в Git Bash для Windows,
это единственный способ продолжить работу с терминалом.
В терминале для macOS и Linux есть вкладки — прямо как в браузере. Вы можете открыть несколько вкладок, и работа в каждой из них не будет
влиять на работу других. Чтобы создать новую вкладку, нажмите Cmd + T (macOS) или Ctrl + T (Linux).
Вернёмся к проекту. Есть удобная функция: если добавить сборке флаг --watch, вкладка браузера с вашим сайтом будет обновляться всякий раз,
как вы сохраняете один из файлов проекта. Вам не нужно будет каждый раз нажимать «Обновить», чтобы увидеть изменения.
Для того чтобы изменения вступили в силу, нужно перезапустить сборку командой npm run dev:`,
    code6: `"scripts": {
  "build": "webpack",
  "dev": "webpack-dev-server --open --watch"
}`,
    text14: `Попробуйте написать код в файле index.js и сохранить его. Сборка перезапустится автоматически.
Теперь у нас настроено окружение: две отдельные сборки для разработки и для финальной версии продукта.
Кроме того, теперь у нас есть локальный сервер, а вместе с ним и модули JS.`,
  },
  {
    title: `Настроим Webpack`,
    text1: `До этого мы устанавливали пакеты: «Вебпак» и локальный сервер. Теперь нужно настроить их: объяснить правила, по которым «Вебпаку» предстоит собирать код.
Все эти правила прописывают в конфигурационном файле «Вебпака»: webpack.config.js. Создайте его в корне вашего проекта и откройте в редакторе кода.
Первым делом нужно создать объект module.exports. В него запишем все настройки:`,
    code1: {
      lang: "javascript",
      value: `module.exports = {
}
// module.exports — это синтаксис экспорта в Node.js`,
    },
    text2: `В прошлом уроке мы рассказывали о точке входа — файле, куда «Вебпак» заглядывает в первую очередь при сборке.
По умолчанию её создавать не нужно — «Вебпак» считает точкой входа файл index.js.
Однако если есть файл webpack.config.js, точку входа нужно указывать явно. Прямо первой инструкцией внутри объекта module.exports.
Точка входа — это объект entry. Ему нужно прописать путь к точке входа в свойстве main:`,
    code2: {
      lang: "javascript",
      value: `module.exports = {
  entry: { main: './src/index.js' }
}
// указали первое место куда заглянет webpack — файл index.js в папке src`,
    },
    text3: `Кроме точки входа есть точка выхода. Это итоговый файл, куда «Вебпак» сложит весь js-код. Её нужно указать в объекте output. У этого объекта 2 свойства:
путь к точке выхода и имя файла, куда «Вебпак» положит код:`,
    code3: {
      lang: "javascript",
      value: `module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: './dist/',
    filename: 'main.js'
  }
}
// указали в какой файл будет собираться весь js и дали ему имя`,
    },
    text4: `Есть трудность: «Вебпак» не понимает относительный путь для точки выхода. Поэтому в свойство path нужно обязательно записывать
абсолютный путь, то есть путь от корневой папки. Это можно сделать автоматически. В Node.js есть утилита, которая превращает
относительный путь в абсолютный. Она называется path, а подключить его в файл можно функцией require:`,
    code4: {
      lang: "javascript",
      value: `// webpack.config.js
const path = require('path'); // подключаем path к конфигу вебпак
module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js'
  }
}
// переписали точку выхода, используя утилиту path`,
    },
    text5: `Объявлена константа path. Она нужна, чтобы подключить к проекту новые методы для работы с путём.
Вместо относительного пути, который мы указали в свойстве path, теперь стоит вызов метода path.resolve. Ему переданы два аргумента:
ссылка на текущую папку __dirname и относительный путь к точке выхода.
Проверьте, всё ли работает. Сначала добавьте в index.js такой код:`,
    code5: `console.log('Hello, World!')`,
    text6: `Сейчас нужна финальная сборка, а не рабочая. Поэтому запустите сборку командой npm run build. Она соберёт весь код в точке выхода —
файле main.js. Откройте файл main.js в редакторе кода. В нём должен появиться наш код:`,
    code6: `console.log('Hello, World!')`,
    text7: `Кроме этого кода в файле main.js будет много другого. Этот код добавляется автоматически — он нужен для работы «Вебпака».
Сборка настроена. Это позволяет использовать модули. Но этим возможности «Вебпака» не ограничиваются.`,
  },
  {
    title: `Транспиляция JS: ставим Babel`,
    text1: `Мы уже не раз говорили о проблемах совместимости. Вы пишете код с классами и стрелочными функциями.
А в половине браузеров ваш сайт не работает: новый синтаксис ими не поддерживается.
Чтобы этого избежать, новый синтаксис при сборке превращают в старый. Этот процесс называется транспиляцией. И чтобы её выполнить,
нам нужен будет очередной NPM-пакет — Babel, или на жаргоне «бабель».`,
    subtitle1: `Установка бабеля`,
    text2: `С бабелем всё так же, как с «Вебпаком»: нужно установить сам пакет бабеля, а затем — несколько утилит для управления им.
Сначала установите сам бабель. Бабель устанавливается как dev-зависимость, потому что он используется только во время сборки.
Когда проект собран, бабель уже не нужен. Чтобы установить бабель, установите пакет @babel/core:`,
    code1: {
      lang: "bash",
      value: `npm i @babel/core --save-dev`},
    text3: `Бабель — это просто инструмент перевода одного кода в другой — своего рода станок. Но этому станку нужно лекало — набор правил,
по которым переводить код. Чтобы не писать эти правила вручную, в бабеле есть уже готовые наборы таких правил — пресеты.
Установите самый распространённый из них — @babel/preset-env:`,
    code2: {
      lang: "bash",
      value: `npm i @babel/preset-env --save-dev`},
    text4: `Этот пресет позволяет указать в каких версиях браузеров должен работать итоговый код, мы сделаем это позже.
Иногда «переделка» синтаксиса не помогает. Например, в старых версиях некоторых браузеров у массивов может не быть метода map
и банальным изменением синтаксиса этого не исправить.
Это можно обойти — загрузить недостающую функциональность в браузер пользователя вместе с нашим проектом.
Такие самодельные аналоги новой функциональности называются полифилы. Бабель использует библиотеку полифилов core-js, установите её:`,
    code3: {
      lang: "bash",
      value: `npm i core-js --save`},
    text5: `Флаг --save говорит о том, что core-js нужно установить как обычную зависимость, а не как зависимость для разработки. Всё потому,
что недостающую функциональность нужно загрузить в браузер пользователя, а значит она нужна в итоговой сборке.
Последнее, что нужно сделать — установить пакет, который позволяет подключить бабель к «Вебпаку». Это пакет babel-loader:`,
    code4: {
      lang: "bash",
      value: `npm i babel-loader --save-dev`},
    subtitle2: `Настройка бабеля`,
    text6: `Бабель нужно настроить. Это можно сделать в файле конфигурации «Вебпака», либо создать отдельный файл для конфигурации именно бабеля.
Мы будем придерживаться второго способа, потому что с ним код аккуратнее и в нём проще разобраться.
Создайте файл babel.config.js в корне проекта. Скопируйте в этот файл код:`,
    code5: {
      lang: "javascript",
      value: `const presets = [
  ['@babel/env', { // какой пресет использовать
    targets: { // какие версии браузеров поддерживать
      edge: '17',
      ie: '11',
      firefox: '50',
      chrome: '64',
      safari: '11.1'
    },
    // использовать полифиллы для браузеров из свойства target
    // по умолчанию babel использует поллифиллы библиотеки core-js
    useBuiltIns: "entry"
  }]
];
module.exports = { presets };`},
    text7: `Какие браузеры нужно поддерживать, обычно определяет заказчик проекта, а вы проставляете их в файле конфигурации.`,
    subtitle3: `Настройка «Вебпака»`,
    text8: `Бабель настроили. Но сборкой занимается «Вебпак», и он пока не знает, что файлы нужно пропускать через бабель, прежде чем
добавлять в сборку. Чтобы «Вебпак» задействовал бабель при сборке, нужно добавить код в файл конфигурации «Вебпака» — webpack.config.js:`,
    code6: {
      lang: "javascript",
      value: `const path = require('path');
module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js'
  },
  module: {
    rules: [ // rules — это массив правил
      // добавим в него объект правил для бабеля
      {
        // регулярное выражение, которое ищет все js файлы
        test: /\.js$/,
        // при обработке этих файлов нужно использовать babel-loader
        loader: 'babel-loader',
        // исключает папку node_modules, файлы в ней обрабатывать не нужно
        exclude: '/node_modules/'
      }
    ]
  }
};`},
    text8: `Наша задача — описать правила обработки файлов при сборке. Для этого мы создали свойство module, а внутри него — массив rules.
Здесь можно задать для «Вебпака» особые правила сборки.
Наше правило звучит так: «если тебе попадётся файл с расширением .js, сначала отдай этот файл модулю babel-loader,
а затем добавляй в сборку. Но не применяй это правило к пакетам, скачанным из NPM, которые лежат в папке node_modules».`,
  },
  {
    title: `HTML + Webpack = 🖤`,
    text1: `Обычно в проекте один или несколько html-файлов. Так в проектной работе курса по JS есть файл index.html — главная страница проекта Mesto.
Обычно в index.html мы подключаем скрипты вручную перед закрывающим тегом body. Но теперь они преобразуются бабелем и название скрипта
может измениться. Поэтому мы подключим index.js вручную, после сборки код может сломаться, ведь «Вебпак» переименовал файл. Поэтому
ручное подключение больше не подходит. Но есть хорошие новости: «Вебпак» умеет подключать сгенерированный js-код в HTML автоматически.
Мы не подключаем скрипты в конце body. Этим и займётся «Вебпак». Для этого нужен специальный плагин — html-webpack-plugin. Установите его:`,
    code1: {
      lang: "bash",
      value: `npm install html-webpack-plugin --save-dev`},
    text2: `Плагины — распространённая сущность во вселенной «Вебпака». Эта вселенная устроена так, что любой человек может реализовать свой плагин
и этим расширить базовую функциональность «Вебпака». Поэтому можно сказать, что html-webpack-plugin учит «Вебпак» работать с html-файлами.`,
    subtitle1: `Настройка HtmlWebpackPlugin`,
    text3: `После установки плагина его нужно подключить и настроить. Подключите его вверху файла webpack.config.js — там, где объявляются константы:`,
    code2: {
      lang: "javascript",
      value: `const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin'); // подключите плагин`},
    text4: `В конец объекта module.exports добавьте новое свойство — массив plugins: Подключенный в начале файла HtmlWebpackPlugin — это класс,
с помощью которого можно конструировать объекты. Поместите в массив plugins следующее:`,
    code3: {
      lang: "javascript",
      value: `plugins: [
  new HtmlWebpackPlugin({
    template: './src/index.html' // путь к файлу index.html
  })
]`},
    text5: `Эта информация всегда есть в документации плагина. Вот соответствующий раздел документации HtmlWebpackPlugin.
Итоговый файл должен выглядеть так:`,
    code4: `const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin'); // подключили плагин
module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/
      }
    ]
  },
  plugins: [
    // настроили плагин
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ]
};`,
  },
  {
    title: `Настраиваем обработку изображений и шрифтов`,
    text1: `Вы подключили HTML к «Вебпаку». Но если в ваших файлах были ссылки на картинки, которые хранятся локально, они не подключились.`,
    subtitle1: `Установка нужных пакетов`,
    text2: `Для добавления файлов в сборку нужно установить два пакета: file-loader и html-loader. Сделайте это:`,
    code1: {
      lang: "bash",
      value: `npm i file-loader --save-dev
npm i html-loader --save-dev`},
    text2: `Действительно, с пакетом file-loader всё логично: он нужен для добавления файлов в сборку. Но ссылки на эти файлы могут быть и в HTML.
Например, в шапке сайта может быть логотип. Если картинка логотипа берётся не со стороннего ресурса, а лежит в папке src/images, нужно,
чтобы «Вебпак» научился подставлять в ссылку правильный путь из папки dist. Для этого и нужен html-loader: он берёт HTML,
анализирует его и подставляет правильные пути файлов.`,
    subtitle2: `Настройка`,
    text3: `В webpack.config.js научите «Вебпак» обрабатывать файлы и заменять ссылки в HTML. Для этого добавьте в массив rules правила:`,
    code2: `module: {
  rules: [
    {
      test: /\.js$/,
      loader: 'babel-loader',
      exclude: '/node_modules/'
    },
    // добавили правило для обработки файлов
    {
      // регулярное выражение, которое ищет все файлы с такими расширениями
      test: /\.(png|svg|jpg|gif|woff2)$/,
      // при обработке этих файлов нужно использовать file-loader
      loader: 'file-loader'
    },
    // аналогично добавьте правило для работы с html
    {
      test: /\.html$/,
      loader: 'html-loader',
    },
  ]
}`,
    text4: `Теперь при сборке командой npm run build в папке dist появятся изображения и шрифты:
Теперь при сборке командой npm run build в папке dist появятся изображения и шрифты:
Вместо названия файла «Вебпак» подставляет хеш — строку, которая рассчитана на основе содержимого файла.
Если содержимое файла меняется, меняется и хеш.
У браузеров есть особенность: загрузив файлы однажды, они сохраняют их в специальном хранилище — кеше.
Когда пользователь зайдёт на сайт в следующий раз, браузер постарается не загружать файлы повторно.
Он проверит, нет ли в кеше файла с таким же именем, загруженного с того же сайта. Если файл найдётся, браузер возьмёт его из кеша.
У такого поведения есть одна проблема. Если мы изменили картинку, но загрузили её на сервер под тем же именем,
пользователь может получить её старую версию.
«Вебпак» делает такое поведение невозможным. Если картинка меняется, меняется и её имя.
А значит пользователь всегда получит свежий результат.`,
    subtitle3: `Ссылки на картинки в JavaScript`,
    text5: `И последнее. Пусть в index.js есть ссылки на локальные картинки в виде строк:`,
    code3: {
      lang: "javascript",
      value: `const whoIsTheGoat = [
  { name: 'Michael Jordan', image: './images/jordan.jpg' },
  { name: 'Lebron James', link: './images/james.jpg' },
  { name: 'Kobe Bryant', link: './images/bryant.jpg' },
];`},
    text6: `Мы используем этот массив объектов, чтобы создать DOM-элементы и затем добавить их на страницу.
Но только что мы выяснили, что в итоговой сборке имена картинок изменились на хеши,
поэтому в созданных DOM-элементах пути к картинкам будут неправильные.
Есть быстрое решение этой проблемы — отдать работу с такими картинками «Вебпаку»:`,
    code4: `// теперь картинки можно импортировать,
// вебпак добавит в переменные правильные пути
import jordanImage from './images/jordan.jpg';
import jamesImage from './images/james.jpg';
import bryantImage from './images/bryant.jpg';
const whoIsTheGoat = [
  // меняем исходные пути на переменные
  { name: 'Michael Jordan', image: jordanImage },
  { name: 'Lebron James', link: jamesImage },
  { name: 'Kobe Bryant', link: bryantImage },
];`,
    text7: `Сперва импорт картинок в JS может казаться странным. В чистом JS такое работать не будет, но теперь за все импорты в нашем проекте отвечает
«Вебпак». В начале темы мы настроили точку входа — файл index.js. Перед сборкой «Вебпак» первым делом заглянет туда. Когда он наткнётся на
импорты, то будет смотреть на расширения файлов и поручать обработку разных файлов разным пакетам и плагинам, которые вы подключили в
webpack.config.js. Так «Вебпак» сам подставит нужные пути картинок во время сборки. А нам осталось настроить подключение CSS.`,
  },
  {
    title: `Настраиваем обработку CSS`,
    text1: `В прошлых уроках вы узнали как связать html-, js- и другие файлы в проекте. Осталось подключить в сборку файлы стилей. Об этом и будет урок.`,
    subtitle1: `Установка нужных пакетов`,
    text2: `Для обработки CSS нужны два пакета, установите их:`,
    code1: {
      lang: "bash",
      value: `npm i css-loader --save-dev
npm i mini-css-extract-plugin --save-dev`},
    text3: `Тут аналогично с babel-loader, html-loader и file-loader. Пакет css-loader нужен для того, чтобы научить «Вебпак» работать с определённым типом
файлов — с CSS. Если вы пишете код с использованием методологии БЭМ, в проекте может быть много css-файлов, которые импортируются друг
в друга директивой @import. Во время разработки это удобно, но перед загрузкой проекта на сервер лучше объединить их в один. При прочих
равных один css-файл загрузится быстрее, чем несколько. Этой цели служит mini-css-extract-plugin. Он берёт много css-файлов и объединяет их.`,
    subtitle2: `Настройка`,
    text4: `В webpack.config.js научите «Вебпак» обрабатывать css-файлы. Для этого сначала подключите mini-css-extract-plugin в файл:`,
    code2: `const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
// подключите к проекту mini-css-extract-plugin
const MiniCssExtractPlugin = require('mini-css-extract-plugin');`,
    text5: `Затем добавьте правило для обработки css-файлов в массив rules:`,
    code3: `rules: [
  // правила для обработки js, html и других файлов
  // добавьте ещё одно правило:
  {
    // применять это правило только к CSS-файлам
    test: /\.css$/,
    // при обработке этих файлов нужно использовать
    // MiniCssExtractPlugin.loader и css-loader
    loader:  [MiniCssExtractPlugin.loader, 'css-loader']
  }
]`,
    text6: `Добавьте в массив plugins вызов MiniCssExtractPlugin с ключевым словом new. Это подключит плагин для объединения css-файлов:`,
    code4: {
      lang: "javascript",
      value: `plugins: [
  new HtmlWebpackPlugin({
    template: 'src/index.html'
  }),
  new MiniCssExtractPlugin() // подключение плагина для объединения файлов
]`},
    subtitle3: `Подключение стилей`,
    text7: `Когда всё настроено, уберите из index.html тег link со ссылкой на стили:`,
    code5: `<!DOCTYPE html>
<html lang="ru">
  <head>
    <!-- содержимое head -->
    <!-- уберите ссылку на файл стилей: -->
    <link rel="stylesheet" href="./style.css">
  </head>
  <body>
    <!-- содержимое body -->
  </body>
</html>`,
    text8: `Теперь за обработку файлов стилей и подключение их в HTML будет отвечать «Вебпак». Чтобы рассказать ему о CSS, импортируйте главный css-файл в index.js:`,
    code6: {
      lang: "javascript",
      value: `// index.js
import './styles/index.css'; // добавьте импорт главного файла стилей`},
    text9: `Здесь ситуация, как и с импортом картинок, — без «Вебпака» такое бы не сработало. Но после подключения css-loader
«Вебпак» умеет работать с css-файлами и обработает такой import по-своему.`,
  },
  {
    title: `Минификация CSS и добавление префиксов`,
    text1: `Пора сделать css-код лёгким и чтобы он везде поддерживался. В этом поможет минификация кода и автоматическая расстановка префиксов.
Для этого установим PostCSS — инструмент для трансформации CSS.`,
    subtitle1: `Установка`,
    text2: `Установите PostCSS и два плагина:`,
    code1: {
      lang: "bash",
      value: `npm i postcss-loader --save-dev
npm i autoprefixer --save-dev
npm i cssnano --save-dev`},
    text3: `Первый пакет postcss-loader нужен, чтобы подключить PostCSS к «Вебпаку».
Плагин autoprefixer научит PostCSS добавлять вендорные префиксы, а cssnano займётся минификацией css-кода.`,
    subtitle2: `Настройка PostCSS`,
    text4: `С установкой закончили — переходим к настройке.
Создайте в корне проекта файл postcss.config.js. В нём создайте объект module.exports со свойством plugins и подключите autoprefixer с cssnano:`,
    code2: `// postcss.config.js
// подключите плагины в файл
const autoprefixer = require('autoprefixer');
const cssnano = require('cssnano');
module.exports = {
  // подключите плагины к PostCSS
  plugins: [
    // подключите autoprefixer
    autoprefixer,
    // cssnano при подключении нужно передать объект опций
    // { preset: default } говорит о том, что нужно использовать
    // стандартные настройки минификации
    cssnano({ preset: 'default' })
  ]
};`,
    subtitle3: `Настройка «Вебпака»`,
    text5: `Отройте файл webpack.config.js. В правило для обработки css-файлов подключите плагин PostCSS.`,
    code3: `{
  test: /\.css$/,
  // добавьте postcss-loader
  loader: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']
}`,
    text6: `Если вы используете директиву @import в css-файлах, после подключения postcss-loader, нужно изменить то, как подключается css-loader.
Элемент в массиве loader может быть не строкой, а объектом. Такая запись аналогична записи выше:`,
    code4: `{
  test: /\.css$/,
  // заменили строку css-loader на объект
  // для «Вебпака» это то же самое
  loader: [MiniCssExtractPlugin.loader, { loader: 'css-loader' }, 'postcss-loader']
}`,
    text7: `Объект позволяет передавать опции при подключении css-loader. Нам необходимо передать опцию importLoaders со значением 1:`,
    code5: {
      lang: "javascript",
      value: `{
  test: /\.css$/,
  // заменили строку css-loader на объект
  // для «Вебпака» это то же самое
  loader: [
    MiniCssExtractPlugin.loader,
    {
      loader: 'css-loader',
      // добавьте объект options
      options: { importLoaders: 1 }
    },
    postcss-loader'
  ]
}`},
    text8: `Эта опция описана в документации сss-loader. Значение 1 говорит о том, что некоторые трансформации PostCSS нужно применить до css-loader.
Итоговый код webpack.config.js:`,
    code6: {
      lang: "javascript",
      value: `const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: '/node_modules/'
      },
      {
        test: /\.css$/,
        loader: [
          MiniCssExtractPlugin.loader,
          {
            loader: 'css-loader',
            options: {
              importLoaders: 1
            }
          },
          'postcss-loader'
        ],
      },
      {
        test: /\.html$/,
        loader: 'html-loader',
      },
      {
        test: /\.(png|svg|jpg|gif|woff2)$/,
        loader: 'file-loader',
      },
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: 'src/index.html'
    }),
    new MiniCssExtractPlugin()
  ]
};`},
    text9: `Теперь команда npm run build собирает в папке dist полноценный проект. Код минифицируется и транспилируется,
а префиксы расставляются автоматически.`,
  },
  {
    title: `Выкладываем сайт на сервер`,
    text1: `Фронтенд проекта Mesto готов. Но какой в этом толк, если ваш сайт никто не увидит? Пора его «задеплоить». Deploy — это размещение проекта
на сервере. После того, как вы задеплоите проект, им смогут пользоваться все — то есть сайт появится в интернете. Процесс деплоя — это не
всегда простое выкладывание файлов на сервер. Кроме этого деплой может включать: транспиляцию кода, подтягивание зависимостей и настройку
серверных сценариев. Поэтому и придуман термин «деплой», а то говорили бы просто «залить на сервер». Впрочем, в нашем проекте есть только
несколько статичных файлов. Потому сегодня вся эта магия деплоя нам не понадобится. Но в курсе по бэкенду деплой будет устроен сложнее.`,
    subtitle1: `Хостинг и Github Pages`,
    text2: `Чтобы сделать сайт доступным в интернете, нужен хостинг. Его предоставляет провайдер, на чей сервер вы выложите сайт. В реальных проектах
нужно подбирать правильный хостинг для сайта: они отличаются по стоимости и возможностям. Но для учебных проектов подойдёт Github Pages.
Это сервис «Гитхаба», который позволяет выложить сайт в интернет прямо из Гитхаб-репозитория.`,
    subtitle2: `Наcтройка Github Pages`,
    text3: `Чтобы добавить проект в сервис Github Pages нужно создать в репозитории ветку gh-pages и загрузить туда собранный проект. Но проще сделать это
специальным пакетом — gh-pages. Установите его:`,
    code1: {
      lang: "bash",
      value: `npm install gh-pages --save-dev`},
    text4: `В файле package.json в разделе devDependencies появится новая строка:`,
    code2: {
      lang: "javascript",
      value: `devDependencies: {
  ...
  "gh-pages": "^3.1.0"
  ...
}`},
    text5: `Добавьте в package.json новый скрипт — deploy. Этот скрипт должен вызывать пакет gh-pages и передавать ему папку, в которой
находится собранный проект. В нашем случае это папка dist:`,
    code3: {
      lang: "javascript",
      value: `scripts: {
  ...
  "deploy": "gh-pages -d dist"
}`},
    text6: `Обычно перед деплоем нужно собрать проект командой npm run build. Чтобы не делать это каждый раз вручную, можно сказать npm, чтобы перед
каждым вызовом скрипта deploy вызывался build. Для этого в раздел scripts добавьте скрипт predeploy:`,
    code4: {
      lang: "javascript",
      value: `scripts: {
  ...
  "predeploy": "npm run build",
  "deploy": "gh-pages -d dist"
}`},
    text7: `Такой скрипт будет вызываться при каждом вызове скрипта deploy. Все настройки готовы. Запустите команду npm run deploy.
Проект соберётся и содержимое папки dist попадёт в удалённую ветку gh-pages. Если при этом возникла ошибка:`,
    subtitle3: `Couldn't find remote ref refs/heads/gh-pages`,
    text8: `Введите команду npx gh-pages-clean и начните пункт 4 заново.
Зайдите на «Гитхаб» и убедитесь что ветка gh-pages со сборкой появилась там:
Теперь, после внесения изменений в проект, достаточно вызвать команду npm run deploy и изменения отобразятся на сайте.
Добавьте ссылку на сайт в описание репозитория на «Гитхабе». Пользователи, которые зайдут в него, смогут посмотреть не только код,
но и сам сайт и быстро протестировать его. Это удобно!
    `,
  },
];
